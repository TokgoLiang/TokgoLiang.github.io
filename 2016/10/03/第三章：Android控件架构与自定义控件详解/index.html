<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="原创,android,Android群英传,控件," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="本章内容大多来自CSDN而不是群英传
Android控件架构Android控件树在Android中控件只有两种，一种就是View，另一种是ViewGroup。
通过ViewGroup，整个控件就至上而下的形成了树形结构，即我们通常所说的控件树。
父控件负责相应子控件的绘制与测量，并向其传递交互事件。
只需要调用findViewbyid的方法就能够按照深度优先的方法找到每一个控件了。
在每个控件树最">
<meta property="og:type" content="article">
<meta property="og:title" content="第三章：Android控件架构与自定义控件详解">
<meta property="og:url" content="http://yoursite.com/2016/10/03/第三章：Android控件架构与自定义控件详解/index.html">
<meta property="og:site_name" content="TokgoLiang的博客">
<meta property="og:description" content="本章内容大多来自CSDN而不是群英传
Android控件架构Android控件树在Android中控件只有两种，一种就是View，另一种是ViewGroup。
通过ViewGroup，整个控件就至上而下的形成了树形结构，即我们通常所说的控件树。
父控件负责相应子控件的绘制与测量，并向其传递交互事件。
只需要调用findViewbyid的方法就能够按照深度优先的方法找到每一个控件了。
在每个控件树最">
<meta property="og:image" content="http://7xu1cb.com1.z0.glb.clouddn.com/Android%E6%8E%A7%E4%BB%B6%E6%A0%91.png">
<meta property="og:image" content="http://7xu1cb.com1.z0.glb.clouddn.com/Android%E7%95%8C%E9%9D%A2%E6%9E%B6%E6%9E%84.png">
<meta property="og:updated_time" content="2016-10-24T15:31:07.105Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第三章：Android控件架构与自定义控件详解">
<meta name="twitter:description" content="本章内容大多来自CSDN而不是群英传
Android控件架构Android控件树在Android中控件只有两种，一种就是View，另一种是ViewGroup。
通过ViewGroup，整个控件就至上而下的形成了树形结构，即我们通常所说的控件树。
父控件负责相应子控件的绘制与测量，并向其传递交互事件。
只需要调用findViewbyid的方法就能够按照深度优先的方法找到每一个控件了。
在每个控件树最">
<meta name="twitter:image" content="http://7xu1cb.com1.z0.glb.clouddn.com/Android%E6%8E%A7%E4%BB%B6%E6%A0%91.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2016/10/03/第三章：Android控件架构与自定义控件详解/"/>

  <title> 第三章：Android控件架构与自定义控件详解 | TokgoLiang的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">TokgoLiang的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                第三章：Android控件架构与自定义控件详解
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-03T22:15:58+08:00" content="2016-10-03">
              2016-10-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Android_读书笔记</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/Android群英传/" itemprop="url" rel="index">
                    <span itemprop="name">Android群英传</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/10/03/第三章：Android控件架构与自定义控件详解/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/10/03/第三章：Android控件架构与自定义控件详解/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><a href="http://blog.csdn.net/zizidemenghanxiao/article/details/50156467" title="本章内容大多来自CSDN而不是群英传" target="_blank" rel="external">本章内容大多来自CSDN而不是群英传</a></p>
<h1 id="Android控件架构"><a href="#Android控件架构" class="headerlink" title="Android控件架构"></a>Android控件架构</h1><h2 id="Android控件树"><a href="#Android控件树" class="headerlink" title="Android控件树"></a>Android控件树</h2><p>在Android中控件只有两种，一种就是View，另一种是ViewGroup。</p>
<p>通过ViewGroup，整个控件就至上而下的形成了树形结构，即我们通常所说的控件树。</p>
<p>父控件负责相应子控件的绘制与测量，并向其传递交互事件。</p>
<p>只需要调用findViewbyid的方法就能够按照深度优先的方法找到每一个控件了。</p>
<p>在每个控件树最顶端，都站立了一个Viewparent对象，这个对象也是这颗控件树的核心，所有的交互管理事件都是由这个大大负责统一分配和调度，从而起这一个整体宏观调控的效果。一个控件树架构如下图所示：</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/Android%E6%8E%A7%E4%BB%B6%E6%A0%91.png" alt="Android控件树架构图"></p>
<h2 id="Android界面架构"><a href="#Android界面架构" class="headerlink" title="Android界面架构"></a>Android界面架构</h2><p>通常情况下，在Activity中使用setContentView()方法来设置一个布局，在调用该方法后，布局内容才真正的显示出来。Android界面的架构图，如下：</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/Android%E7%95%8C%E9%9D%A2%E6%9E%B6%E6%9E%84.png" alt="Android界面架构图"></p>
<p>通过上图所示，我们可以得出这样的结论。</p>
<ol>
<li>每个activity都有一个window对象。</li>
<li>而每一个window对象通常是由PhoneWindow来实现。</li>
<li>每个PhoneWindow对象包含DecorView这个根视图对象，将其视图展示都是通过这个对象显示到PhoneWindow上。</li>
<li>而DecorView被一分为二，一个是TitleView，一个ContentView，TitleView显示相应的标题，ContentView显示具体布局，这些应该大家很熟悉。</li>
</ol>
<h1 id="ViewRoot和DecorView介绍"><a href="#ViewRoot和DecorView介绍" class="headerlink" title="ViewRoot和DecorView介绍"></a>ViewRoot和DecorView介绍</h1><h2 id="ViewRoot简介"><a href="#ViewRoot简介" class="headerlink" title="ViewRoot简介"></a>ViewRoot简介</h2><ol>
<li>ViewRoot对应于ViewRootImpl 类，它是连接 WindowManager 和 DecorView的纽带，View的三大流程（measure测量、layout布局、draw绘制）都是通过ViewRoot来完成的。</li>
<li>在ActivityThread 中，当Activity对象被创建完毕后，会将 DecorView 添加到Window中，同时会创建 ViewRootImpl对象，并将 ViewRootImpl对象和DecorView建立关联。</li>
<li><p>View的绘制流程是从ViewRoot 的 performTraversals 方法（源码在sources\android\view\ViewRootImpl.java）开始的，它经过 measure、layout和draw三个过程才能最终将一个View绘制出来，其中</p>
<ul>
<li>measure用来测量View的宽高</li>
<li>layout用来确定View在父容器中的放置位置</li>
<li>draw负责将View绘制在屏幕上</li>
</ul>
</li>
<li><p>Measure完成后，可以通过 getMeasuredWidth 和getMeasuredHeight 方法来获取到 View 测量后的宽高；Layout完成后，可以通过 getTop、getBottom、getLeft和getRight 来拿到View的四个顶点的位置，并可以通过 getWidth 和getHeight方法来拿到View的最终宽高；Draw完成后，View显示在屏幕上。</p>
</li>
</ol>
<h2 id="DecorView简介"><a href="#DecorView简介" class="headerlink" title="DecorView简介"></a>DecorView简介</h2><ol>
<li>DecorView作为顶级view，它的内部是一个竖直的LinearLayout,其中包括Title Bar和Content；</li>
<li>其中Activity中设置setContentView就是将布局文件加载在Content中；</li>
<li>Content是一个FrameLayout,可以布局优化；</li>
<li>可以通过ViewGroup content = findViewById(R.android.id.content);</li>
<li>可以通过content.getChildAt(index)获取View；</li>
</ol>
<h1 id="View的测量"><a href="#View的测量" class="headerlink" title="View的测量"></a>View的测量</h1><h2 id="MeasureSpec简介"><a href="#MeasureSpec简介" class="headerlink" title="MeasureSpec简介"></a>MeasureSpec简介</h2><ol>
<li>源码的位置android/view/View.java；</li>
<li>Android系统在绘制View之前，必须对View进行测量，这个过程在onMeasure()中进行，借助的是MeasureSpec类。MeasureSpec是一个32位的值，其中高两位代表测量模式SpecMode，低30位代表测量的大小SpecSize；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * A MeasureSpec encapsulates the layout requirements passed from parent to child.</div><div class="line">   * Each MeasureSpec represents a requirement for either the width or the height.</div><div class="line">   * A MeasureSpec is comprised of a size and a mode. There are three possible</div><div class="line">   * modes:</div><div class="line">   * &lt;dl&gt;</div><div class="line">   * &lt;dt&gt;UNSPECIFIED&lt;/dt&gt;</div><div class="line">   * &lt;dd&gt;</div><div class="line">   * The parent has not imposed any constraint on the child. It can be whatever size</div><div class="line">   * it wants.</div><div class="line">   * &lt;/dd&gt;</div><div class="line">   *</div><div class="line">   * &lt;dt&gt;EXACTLY&lt;/dt&gt;</div><div class="line">   * &lt;dd&gt;</div><div class="line">   * The parent has determined an exact size for the child. The child is going to be</div><div class="line">   * given those bounds regardless of how big it wants to be.</div><div class="line">   * &lt;/dd&gt;</div><div class="line">   *</div><div class="line">   * &lt;dt&gt;AT_MOST&lt;/dt&gt;</div><div class="line">   * &lt;dd&gt;</div><div class="line">   * The child can be as large as it wants up to the specified size.</div><div class="line">   * &lt;/dd&gt;</div><div class="line">   * &lt;/dl&gt;</div><div class="line">   *</div><div class="line">   * MeasureSpecs are implemented as ints to reduce object allocation. This class</div><div class="line">   * is provided to pack and unpack the &amp;lt;size, mode&amp;gt; tuple into the int.</div><div class="line">   */</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MeasureSpec</span> </span>&#123;</div><div class="line"><span class="comment">//位移用的，后面表示大小的30位</span></div><div class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</div><div class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK  = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line">      <span class="comment">/** <span class="doctag">@hide</span> */</span></div><div class="line">      <span class="meta">@IntDef</span>(&#123;UNSPECIFIED, EXACTLY, AT_MOST&#125;)</div><div class="line">      <span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</div><div class="line">      <span class="keyword">public</span> <span class="meta">@interface</span> MeasureSpecMode &#123;&#125;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Measure specification mode: The parent has not imposed any constraint</div><div class="line">       * on the child. It can be whatever size it wants.</div><div class="line">       */</div><div class="line"><span class="comment">//dp,px,父容器对子元素没有任何约束，子元素可以是任意大小</span></div><div class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Measure specification mode: The parent has determined an exact size</div><div class="line">       * for the child. The child is going to be given those bounds regardless</div><div class="line">       * of how big it wants to be.</div><div class="line">       */</div><div class="line"><span class="comment">//match_parent，父容器决定子元素大小，子元素和父容器一样大小</span></div><div class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Measure specification mode: The child can be as large as it wants up</div><div class="line">       * to the specified size.</div><div class="line">       */</div><div class="line"><span class="comment">//wrap_content,子元素不可以超过父容器的大小</span></div><div class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Creates a measure specification based on the supplied size and mode.</div><div class="line">       *</div><div class="line">       * The mode must always be one of the following:</div><div class="line">       * &lt;ul&gt;</div><div class="line">       *  &lt;li&gt;&#123;<span class="doctag">@link</span> android.view.View.MeasureSpec#UNSPECIFIED&#125;&lt;/li&gt;</div><div class="line">       *  &lt;li&gt;&#123;<span class="doctag">@link</span> android.view.View.MeasureSpec#EXACTLY&#125;&lt;/li&gt;</div><div class="line">       *  &lt;li&gt;&#123;<span class="doctag">@link</span> android.view.View.MeasureSpec#AT_MOST&#125;&lt;/li&gt;</div><div class="line">       * &lt;/ul&gt;</div><div class="line">       *</div><div class="line">       * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; On API level 17 and lower, makeMeasureSpec's</div><div class="line">       * implementation was such that the order of arguments did not matter</div><div class="line">       * and overflow in either value could impact the resulting MeasureSpec.</div><div class="line">       * &#123;<span class="doctag">@link</span> android.widget.RelativeLayout&#125; was affected by this bug.</div><div class="line">       * Apps targeting API levels greater than 17 will get the fixed, more strict</div><div class="line">       * behavior.&lt;/p&gt;</div><div class="line">       *</div><div class="line">       * <span class="doctag">@param</span> size the size of the measure specification</div><div class="line">       * <span class="doctag">@param</span> mode the mode of the measure specification</div><div class="line">       * <span class="doctag">@return</span> the measure specification based on size and mode</div><div class="line">       */</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(@IntRange(from = <span class="number">0</span>, to = (<span class="number">1</span> &lt;&lt; MeasureSpec.MODE_SHIFT)</span> - 1) <span class="keyword">int</span> size,</span></div><div class="line">                                        @MeasureSpecMode <span class="keyword">int</span> mode) &#123;</div><div class="line">          <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</div><div class="line">              <span class="keyword">return</span> size + mode;</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">              <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Like &#123;<span class="doctag">@link</span> #makeMeasureSpec(int, int)&#125;, but any spec with a mode of UNSPECIFIED</div><div class="line">       * will automatically get a size of 0. Older apps expect this.</div><div class="line">       *</div><div class="line">       * <span class="doctag">@hide</span> internal use only for compatibility with system widgets and older apps</div><div class="line">       */</div><div class="line"><span class="comment">//将size和mode打包成一个32位的int值返回</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeSafeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">          <span class="keyword">if</span> (sUseZeroUnspecifiedMeasureSpec &amp;&amp; mode == UNSPECIFIED) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">return</span> makeMeasureSpec(size, mode);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Extracts the mode from the supplied measure specification.</div><div class="line">       *</div><div class="line">       * <span class="doctag">@param</span> measureSpec the measure specification to extract the mode from</div><div class="line">       * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> android.view.View.MeasureSpec#UNSPECIFIED&#125;,</div><div class="line">       *         &#123;<span class="doctag">@link</span> android.view.View.MeasureSpec#AT_MOST&#125; or</div><div class="line">       *         &#123;<span class="doctag">@link</span> android.view.View.MeasureSpec#EXACTLY&#125;</div><div class="line">       */</div><div class="line">      <span class="meta">@MeasureSpecMode</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">          <span class="comment">//noinspection ResourceType</span></div><div class="line">          <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Extracts the size from the supplied measure specification.</div><div class="line">       *</div><div class="line">       * <span class="doctag">@param</span> measureSpec the measure specification to extract the size from</div><div class="line">       * <span class="doctag">@return</span> the size in pixels defined in the supplied measure specification</div><div class="line">       */</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">          <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> measureSpec, <span class="keyword">int</span> delta)</span> </span>&#123;</div><div class="line">          <span class="keyword">final</span> <span class="keyword">int</span> mode = getMode(measureSpec);</div><div class="line">          <span class="keyword">int</span> size = getSize(measureSpec);</div><div class="line">          <span class="keyword">if</span> (mode == UNSPECIFIED) &#123;</div><div class="line">              <span class="comment">// No need to adjust size for UNSPECIFIED mode.</span></div><div class="line">              <span class="keyword">return</span> makeMeasureSpec(size, UNSPECIFIED);</div><div class="line">          &#125;</div><div class="line">          size += delta;</div><div class="line">          <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</div><div class="line">              Log.e(VIEW_LOG_TAG, <span class="string">"MeasureSpec.adjust: new size would be negative! ("</span> + size +</div><div class="line">                      <span class="string">") spec: "</span> + toString(measureSpec) + <span class="string">" delta: "</span> + delta);</div><div class="line">              size = <span class="number">0</span>;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">return</span> makeMeasureSpec(size, mode);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Returns a String representation of the specified measure</div><div class="line">       * specification.</div><div class="line">       *</div><div class="line">       * <span class="doctag">@param</span> measureSpec the measure specification to convert to a String</div><div class="line">       * <span class="doctag">@return</span> a String with the following format: "MeasureSpec: MODE SIZE"</div><div class="line">       */</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">          <span class="keyword">int</span> mode = getMode(measureSpec);</div><div class="line">          <span class="keyword">int</span> size = getSize(measureSpec);</div><div class="line"></div><div class="line">          StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"MeasureSpec: "</span>);</div><div class="line"></div><div class="line">          <span class="keyword">if</span> (mode == UNSPECIFIED)</div><div class="line">              sb.append(<span class="string">"UNSPECIFIED "</span>);</div><div class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (mode == EXACTLY)</div><div class="line">              sb.append(<span class="string">"EXACTLY "</span>);</div><div class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (mode == AT_MOST)</div><div class="line">              sb.append(<span class="string">"AT_MOST "</span>);</div><div class="line">          <span class="keyword">else</span></div><div class="line">              sb.append(mode).append(<span class="string">" "</span>);</div><div class="line"></div><div class="line">          sb.append(size);</div><div class="line">          <span class="keyword">return</span> sb.toString();</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>MeasureSpec的测量模式有三种：</p>
<ol>
<li>EXACTLY：具体值或者 match_parent。onMeasure（）方法默认情况下只支持这种模式。</li>
<li>AT_MOST：wrap_content。不可以比父容器大就可以了，不过通常控件都会有一个默认值。</li>
<li>UNSPECIFIED：View想多大就多大，通常自定义View时使用。<br><strong>注意点：要让自定义View支持 wrap_content 属性，就必须重写onMeasure（）方法来指定wrap_content时的大小。</strong></li>
</ol>
<h2 id="MeasurSpec和LayoutParams的对应关系"><a href="#MeasurSpec和LayoutParams的对应关系" class="headerlink" title="MeasurSpec和LayoutParams的对应关系"></a>MeasurSpec和LayoutParams的对应关系</h2><ol>
<li>View在测量的时候，系统会将LayoutParams在父容器的约束下转换成对应的MeasureSpec，然后再根据MeasureSpec来确定View测量后的宽高；</li>
<li>MeasureSpec不仅有LayoutParams决定，还有父容器的大小影响；</li>
<li>DecorView比较特殊，它由LayoutParams和出口的尺寸来决定，他没有父容器；</li>
<li>MeasureSpec一旦确定，onMeasure中就可以确定View的测量宽高；</li>
</ol>
<p>下面看看DecorView在ViewRootImpl中的源码：</p>
<ol>
<li>DecorView的MeasureSpec创建过程，在measureHierarchy函数中有如下语句：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (baseSize != <span class="number">0</span> &amp;&amp; desiredWindowWidth &gt; baseSize) &#123;</div><div class="line">                childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width);</div><div class="line">                childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</div><div class="line">                performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>desiredWindowHeight指的是屏幕的高度，那个desiredWindowWidth不能超过baseSize，不然。。。。呵呵,不知道。<br>if下面的两句的作用是获得宽高，第三句就是通过performMeasure来设置宽高了。</p>
<ol>
<li>接下来看看里面的getRootMeasureSpec 方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Figures out the measure spec for the root view in a window based on it's</div><div class="line">     * layout params.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> windowSize</div><div class="line">     *            The available width or height of the window</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> rootDimension</div><div class="line">     *            The layout params for one dimension (width or height) of the</div><div class="line">     *            window.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> The measure spec to use to measure the root view.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> measureSpec;</div><div class="line">        <span class="keyword">switch</span> (rootDimension) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</div><div class="line">            <span class="comment">// Window can't resize. Force root view to be windowSize.</span></div><div class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</div><div class="line">            <span class="comment">// Window can resize. Set max size for root view.</span></div><div class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="comment">// Window wants to be an exact size. Force root view to be that size.</span></div><div class="line">            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> measureSpec;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这个方法很明显了，进来以后通过第二个参数来判断啦是用窗口大小还是用LinearLayout的值。其中的makeMeasureSpec是SpecMode和SpecSize的打包组合。</p>
<p>下面看看普通的View，这里是指我们布局中的View：</p>
<ol>
<li><p>View的measure过程由ViewGroup传递而来，先看一下ViewGroup的measureChildWithMargins 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * Ask one of the children of this view to measure itself, taking into</div><div class="line">    * account both the MeasureSpec requirements for this view and its padding</div><div class="line">    * and margins. The child must have MarginLayoutParams The heavy lifting is</div><div class="line">    * done in getChildMeasureSpec.</div><div class="line">    *</div><div class="line">    * <span class="doctag">@param</span> child The child to measure</div><div class="line">    * <span class="doctag">@param</span> parentWidthMeasureSpec The width requirements for this view</div><div class="line">    * <span class="doctag">@param</span> widthUsed Extra space that has been used up by the parent</div><div class="line">    *        horizontally (possibly by other children of the parent)</div><div class="line">    * <span class="doctag">@param</span> parentHeightMeasureSpec The height requirements for this view</div><div class="line">    * <span class="doctag">@param</span> heightUsed Extra space that has been used up by the parent</div><div class="line">    *        vertically (possibly by other children of the parent)</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></div><div class="line">           <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</div><div class="line">           <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed) &#123;</div><div class="line">       <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line"><span class="comment">/* 也是先获取子元素的MeasureSpec， </span></div><div class="line">    * getChildMeasureSpec这里的参数，第一个就变成了父类的大小， </div><div class="line">    * 第二个参数是上下左右的边距 </div><div class="line">    * 第三个参数是LinearLayout的宽高 </div><div class="line">    */  </div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">               mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</div><div class="line">                       + widthUsed, lp.width);</div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">               mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</div><div class="line">                       + heightUsed, lp.height);</div><div class="line">	<span class="comment">//得到子元素的MeasureSpec后，调用子元素的measure来设置宽高</span></div><div class="line">       child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>我们也来看看getChildMeasureSpec方法：其中的padding指的是父容器中已占用的空间大小。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    /**</div><div class="line">     * Does the hard part of measureChildren: figuring out the MeasureSpec to</div><div class="line">     * pass to a particular child. This method figures out the right MeasureSpec</div><div class="line">     * for one dimension (height or width) of one child view.</div><div class="line">     *</div><div class="line">     * The goal is to combine information from our MeasureSpec with the</div><div class="line">     * LayoutParams of the child to get the best possible results. For example,</div><div class="line">     * if the this view knows its size (because its MeasureSpec has a mode of</div><div class="line">     * EXACTLY), and the child has indicated in its LayoutParams that it wants</div><div class="line">     * to be the same size as the parent, the parent should ask the child to</div><div class="line">     * layout given an exact size.</div><div class="line">     *</div><div class="line">     * @param spec The requirements for this view</div><div class="line">     * @param padding The padding of this view for the current dimension and</div><div class="line">     *        margins, if applicable</div><div class="line">     * @param childDimension How big the child wants to be in the current</div><div class="line">     *        dimension</div><div class="line">     * @return a MeasureSpec integer for the child</div><div class="line">     */</div><div class="line">    public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123;</div><div class="line">        int specMode = MeasureSpec.getMode(spec);</div><div class="line">        int specSize = MeasureSpec.getSize(spec);</div><div class="line"></div><div class="line">        int size = Math.max(0, specSize - padding);</div><div class="line"></div><div class="line">        int resultSize = 0;</div><div class="line">        int resultMode = 0;</div><div class="line"></div><div class="line">        switch (specMode) &#123;</div><div class="line">        // Parent has imposed an exact size on us</div><div class="line">        case MeasureSpec.EXACTLY:</div><div class="line">            if (childDimension &gt;= 0) &#123;</div><div class="line">                resultSize = childDimension;</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">                // Child wants to be our size. So be it.</div><div class="line">                resultSize = size;</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">                // Child wants to determine its own size. It can't be</div><div class="line">                // bigger than us.</div><div class="line">                resultSize = size;</div><div class="line">                resultMode = MeasureSpec.AT_MOST;</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line"></div><div class="line">        // Parent has imposed a maximum size on us</div><div class="line">        case MeasureSpec.AT_MOST:</div><div class="line">            if (childDimension &gt;= 0) &#123;</div><div class="line">                // Child wants a specific size... so be it</div><div class="line">                resultSize = childDimension;</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">                // Child wants to be our size, but our size is not fixed.</div><div class="line">                // Constrain child to not be bigger than us.</div><div class="line">                resultSize = size;</div><div class="line">                resultMode = MeasureSpec.AT_MOST;</div><div class="line">            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">                // Child wants to determine its own size. It can't be</div><div class="line">                // bigger than us.</div><div class="line">                resultSize = size;</div><div class="line">                resultMode = MeasureSpec.AT_MOST;</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line"></div><div class="line">        // Parent asked to see how big we want to be</div><div class="line">        case MeasureSpec.UNSPECIFIED:</div><div class="line">            if (childDimension &gt;= 0) &#123;</div><div class="line">                // Child wants a specific size... let him have it</div><div class="line">                resultSize = childDimension;</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">                // Child wants to be our size... find out how big it should</div><div class="line">                // be</div><div class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;</div><div class="line">                resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">                // Child wants to determine its own size.... find out how</div><div class="line">                // big it should be</div><div class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;</div><div class="line">                resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        //noinspection ResourceType</div><div class="line">        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);</div><div class="line">    &#125;</div><div class="line">``` </div><div class="line"></div><div class="line">搞个表格来说明以下上面代码的逻辑：</div><div class="line"></div><div class="line">![普通View的MeasureSpec的创建规则](http://7xu1cb.com1.z0.glb.clouddn.com/MeasureSpec%E7%9A%84%E5%88%9B%E5%BB%BA%E8%A7%84%E5%88%99.png)</div><div class="line"></div><div class="line">就是说只要子元素的LinearLayout是精确值，那子元素就是精确值。</div><div class="line">子元素如果是match_parent，那子元素就和父容器一样大小。</div><div class="line">子元素如果是wrap_content，那子元素就不能超过父容器的剩余空间大小。</div><div class="line"></div><div class="line">## 看看具体的onMeasure实现和如何重写这个方法 ##</div><div class="line"></div><div class="line">1. 原始的onMeasure在源码中是这样的，也就是重写时它自动构成这样：</div><div class="line">``` java</div><div class="line">@Override  </div><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;  </div><div class="line">    super.onMeasure(widthMeasureSpec, heightMeasureSpec);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>然后我们去查看 super.onMeasure（）方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;  </div><div class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),  </div><div class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>可以发现超类中调用了setMeasuredDimension（）方法，它的两个参数是 MeasureSpec 类型变量，这个方法将测量后的宽高值设置进去，从而完成测量工作。</p>
<ol>
<li><p>所以当我们想要重写onMeasure（）方法时，可以直接重写超类中的setMeasuredDimension（）方法，同时自定义两个测量宽高的方法 measureWidth() 和 measureHeight() 来处理 MeasureSpec 类型变量，返回宽高值Size;在超类中是以getDefaultSize()来处理 MeasureSpec 类型变量的，这里我们换成自己写的 measureWidth() 和 measureHeight() 方法：（<strong>注意啦，这里getDefaultSize返回的是size大小，也就是说将MeasureSpec中的size部分返回。</strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;  </div><div class="line">    setMeasuredDimension(  </div><div class="line">            measureWidth(widthMeasureSpec),  </div><div class="line">            measureHeight(heightMeasureSpec));  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>下面就看看需要编写的measureWidth（）方法如何实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">measureWidth</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;  </div><div class="line">      </div><div class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;  </div><div class="line">      </div><div class="line">    <span class="comment">// 首先从MeasureSpec对象中提取出具体的测量模式和大小：  </span></div><div class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);  </div><div class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);  </div><div class="line">  </div><div class="line">    <span class="comment">// 直接返回精确值  </span></div><div class="line">    <span class="keyword">if</span> (specMode == MeasureSpec.EXACTLY) &#123;  </div><div class="line">        result = specSize;  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        <span class="comment">// 另外两种模式，200是默认大小  </span></div><div class="line">        result = <span class="number">200</span>;  </div><div class="line">        <span class="comment">// 但如果是AT_MOST即wrap_content时，还需要取两者的最小值。  </span></div><div class="line">        <span class="comment">// 所以通常情况下，如果我们不重写onMeasure（）方法时，都会给这个控件一个默认的比如说200的大小  </span></div><div class="line">        <span class="comment">// 但如果重写了，这里就可以为wrap_content设置一个其他的默认大小。  </span></div><div class="line">        <span class="keyword">if</span> (specMode == MeasureSpec.AT_MOST) &#123;  </div><div class="line">            result = Math.min(result, specSize);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">return</span> result;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="View的measure过程"><a href="#View的measure过程" class="headerlink" title="View的measure过程"></a>View的measure过程</h1><h2 id="View的measure过程-1"><a href="#View的measure过程-1" class="headerlink" title="View的measure过程"></a>View的measure过程</h2><ol>
<li>源码位置：sources\android\view\View.java</li>
<li>View的measure过程由measure方法来完成，measure方法是一个final类型的方法，意味着子类不能重写此方法，<br>在View的measure方法中会调用VIew的onMeasure 方法，所以只需要看onMeasure方法就可以了：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;  </div><div class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),  </div><div class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>代码很简单，setMeasuredDimension 方法会设置View宽高的测量值，因此我们主要看看getDefaultSize 这个方法，第一个参数是getSuggestedMinimumWidth返回值，第二个参数是MeasureSpec的测量宽值。</p>
<ol>
<li>getDefaultSize方法的实现：返回的是size值。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Utility to return a default size. Uses the supplied size if the</div><div class="line"> * MeasureSpec imposed no constraints. Will get larger if allowed</div><div class="line"> * by the MeasureSpec.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> size Default size for this view</div><div class="line"> * <span class="doctag">@param</span> measureSpec Constraints imposed by the parent</div><div class="line"> * <span class="doctag">@return</span> The size this view should be.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> result = size;</div><div class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">        result = size;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">        result = specSize;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>这里有关于wrap_content的重点：</strong><br>我们从这个方法可以得出，View的宽高是由specSize决定的，所以我们可以直接继承View的自定义控件需要重写onMeasure方法并设置wrap_content时的自身大小，<br>否则在布局中使用wrap_content就相当于使用match_parent。<br>什么意思呢？就是说默认情况下，上面代码中写的AT_MOST和EXACTLY这两种case的返回值都是specSize，<br>但是我们可以在自定义的View中设置wrap_content的大小，使得它有一个自己默认的大小。<br>所以在大多数的控件中，比如说TextView、ImageView等的源码就可以知道，针对wrap_content情形，它们的 onMeasure 方法均作了特殊的处理。<br>我们这里给一个自己可以重写onMeasure的代码（其实我们刚刚上面也给了一个重写的方法了啊，差不多的）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;  </div><div class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);  </div><div class="line">  </div><div class="line">    <span class="keyword">int</span> widthSpaceSize = MeasureSpec.getSize(widthMeasureSpec);  </div><div class="line">    <span class="keyword">int</span> widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);  </div><div class="line">    <span class="keyword">int</span> heightSpaceSize = MeasureSpec.getSize(heightMeasureSpec);  </div><div class="line">    <span class="keyword">int</span> heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST) &#123;  </div><div class="line">        setMeasuredDimension(mWidth, mHight);  </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (widthSpecMode == MeasureSpec.AT_MOST) &#123;  </div><div class="line">        setMeasuredDimension(mWidth, heightSpaceSize);  </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heightSpecMode == MeasureSpec.AT_MOST)&#123;  </div><div class="line">        setMeasuredDimension(widthSpaceSize, mHight);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>setMeasuredDimension 方法中的第一个参数是getSuggestedMinimumWidth方法返回的：<br>它返回的是View在UNSPECIFIED情况下的测量宽高。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * Returns the suggested minimum width that the view should use. This </div><div class="line"> * returns the maximum of the view's minimum width) </div><div class="line"> * and the background's minimum width </div><div class="line"> *  (&#123;<span class="doctag">@link</span> android.graphics.drawable.Drawable#getMinimumWidth()&#125;). </div><div class="line"> * &lt;p&gt; </div><div class="line"> * When being used in &#123;<span class="doctag">@link</span> #onMeasure(int, int)&#125;, the caller should still </div><div class="line"> * ensure the returned width is within the requirements of the parent. </div><div class="line"> * </div><div class="line"> * <span class="doctag">@return</span> The suggested minimum width of the view. </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>如果View没有设置背景，那么View的宽度就是mMinWidh，这个值对应于android:minWidth，这个值默认是为0的。<br>如果View设置了背景，那么View的宽度就是max(mMinWidth, mBackground.getMinimumWidth())。那mBackground.getMinimumWidth()呢？</p>
<ol>
<li>mBackground.getMinimumWidth()：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * Returns the minimum width suggested by this Drawable. If a View uses this </div><div class="line"> * Drawable as a background, it is suggested that the View use at least this </div><div class="line"> * value for its width. (There will be some scenarios where this will not be </div><div class="line"> * possible.) This value should INCLUDE any padding. </div><div class="line"> * </div><div class="line"> * <span class="doctag">@return</span> The minimum width suggested by this Drawable. If this Drawable </div><div class="line"> *         doesn't have a suggested minimum width, 0 is returned. </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumWidth</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> intrinsicWidth = getIntrinsicWidth();  </div><div class="line">    <span class="keyword">return</span> intrinsicWidth &gt; <span class="number">0</span> ? intrinsicWidth : <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>可以看到他返回的就是Drawable的原始宽度，前提是这个Drawable有原始宽度，否则就返回0.<br>那么Drawable在什么情况下有原始宽度呢？ShapeDrawable无原始宽高，而BitmapDrawable有原始宽高（图片的尺寸）。</p>
<h2 id="ViewGroup的measure过程"><a href="#ViewGroup的measure过程" class="headerlink" title="ViewGroup的measure过程"></a>ViewGroup的measure过程</h2><ol>
<li>源码位置：sources\android\view\ViewGroup.java</li>
<li>对于ViewGroup而言，除了完成自己的measure过程以外，还会去遍历去调用所有子元素的measure方法，各个子元素再递归去执行这个过程。</li>
<li><p>和View不同的是，ViewGroup是一个抽象类，因此它没有重写View的onMeasure方法，但它提供了一个叫 measureChildren的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * Ask all of the children of this view to measure themselves, taking into </div><div class="line"> * account both the MeasureSpec requirements for this view and its padding. </div><div class="line"> * We skip children that are in the GONE state The heavy lifting is done in </div><div class="line"> * getChildMeasureSpec. </div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> widthMeasureSpec The width requirements for this view </div><div class="line"> * <span class="doctag">@param</span> heightMeasureSpec The height requirements for this view </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;  </div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;  </div><div class="line">    <span class="keyword">final</span> View[] children = mChildren;  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;  </div><div class="line">        <span class="keyword">final</span> View child = children[i];  </div><div class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;  </div><div class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在measureChildren中有一个measureChild：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * Ask one of the children of this view to measure itself, taking into </div><div class="line"> * account both the MeasureSpec requirements for this view and its padding. </div><div class="line"> * The heavy lifting is done in getChildMeasureSpec. </div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> child The child to measure </div><div class="line"> * <span class="doctag">@param</span> parentWidthMeasureSpec The width requirements for this view </div><div class="line"> * <span class="doctag">@param</span> parentHeightMeasureSpec The height requirements for this view </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,  </span></span></div><div class="line">        <span class="keyword">int</span> parentHeightMeasureSpec) &#123;  </div><div class="line">    <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();  </div><div class="line">  </div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,  </div><div class="line">            mPaddingLeft + mPaddingRight, lp.width);  </div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,  </div><div class="line">            mPaddingTop + mPaddingBottom, lp.height);  </div><div class="line">  </div><div class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>取出子元素的LayoutParams，然后再通过getChildMeasureSpec来创建子元素的MeasureSpec，再然后将它直接传递给View的measure方法来进行测量。</p>
<ol>
<li>在ViewGroup中并没有定义其测量的具体过程，因为ViewGroup是一个抽象类，它的测量过程的onMeasure方法需要各个子类去实现，比如LinearLayout、RelativeLayout等，<br>因为不同的子类有不同的布局特性，这导致它们的测量细节各不相同。因此ViewGroup无法做统一实现。</li>
<li>我们以LinearLayout为例来讲一下ViewGroup：<br>源码位置：sources\android\widget\LinearLayout.java<br>先看看它的onMeasure方法：很简单<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;  </div><div class="line">        measureVertical(widthMeasureSpec, heightMeasureSpec);  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        measureHorizontal(widthMeasureSpec, heightMeasureSpec);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>再去看看measureVertical方法：比较长，我们删掉了很多，留下了一部分代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * Measures the children when the orientation of this LinearLayout is set </div><div class="line"> * to &#123;<span class="doctag">@link</span> #VERTICAL&#125;. </div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> widthMeasureSpec Horizontal space requirements as imposed by the parent. </div><div class="line"> * <span class="doctag">@param</span> heightMeasureSpec Vertical space requirements as imposed by the parent. </div><div class="line"> * </div><div class="line"> * <span class="doctag">@see</span> #getOrientation() </div><div class="line"> * <span class="doctag">@see</span> #setOrientation(int) </div><div class="line"> * <span class="doctag">@see</span> #onMeasure(int, int) </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">measureVertical</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;  </div><div class="line">  </div><div class="line">    ...  </div><div class="line">  </div><div class="line">    <span class="comment">// See how tall everyone is. Also remember max width.  </span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;  </div><div class="line">        <span class="keyword">final</span> View child = getVirtualChildAt(i);  </div><div class="line">  </div><div class="line">        ...  </div><div class="line">  </div><div class="line">            <span class="comment">// Determine how big this child would like to be. If this or  </span></div><div class="line">            <span class="comment">// previous children have given a weight, then we allow it to  </span></div><div class="line">            <span class="comment">// use all available space (and we will shrink things later  </span></div><div class="line">            <span class="comment">// if needed).  </span></div><div class="line">            <span class="comment">/* </span></div><div class="line">             * 遍历子元素并对子元素执行这个方法， </div><div class="line">             * 这个方法内部会调用子元素的measure方法， </div><div class="line">             * 这样各个子元素就开始一次进入measure过程， </div><div class="line">             * 并且系统会通过mTotalLength这个变量来存储LinearLayout在竖直方向的初步高度。 </div><div class="line">             * 没测量一个子元素，mTotalLength都会增加。 </div><div class="line">             * */  </div><div class="line">            measureChildBeforeLayout(  </div><div class="line">                   child, i, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec,  </div><div class="line">                   totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>);  </div><div class="line">  </div><div class="line">            <span class="keyword">if</span> (oldHeight != Integer.MIN_VALUE) &#123;  </div><div class="line">               lp.height = oldHeight;  </div><div class="line">            &#125;  </div><div class="line">  </div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();  </div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;  </div><div class="line">            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +  </div><div class="line">                   lp.bottomMargin + getNextLocationOffset(child));  </div><div class="line">  </div><div class="line">            ...  </div><div class="line">        &#125;  </div><div class="line">      </div><div class="line">    ...  </div><div class="line">  </div><div class="line">    <span class="comment">// Add in our padding  </span></div><div class="line">    mTotalLength += mPaddingTop + mPaddingBottom;  </div><div class="line">  </div><div class="line">    <span class="keyword">int</span> heightSize = mTotalLength;  </div><div class="line">  </div><div class="line">    <span class="comment">// Check against our minimum height  </span></div><div class="line">    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());  </div><div class="line">      </div><div class="line">    <span class="comment">// Reconcile our calculated size with the heightMeasureSpec  </span></div><div class="line">    <span class="keyword">int</span> heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, <span class="number">0</span>);  </div><div class="line">    heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;  </div><div class="line">      </div><div class="line">    ...  </div><div class="line">      </div><div class="line">    <span class="comment">// 等子元素都测量完毕后，LinearLayout测量自己的大小：  </span></div><div class="line">    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),<span class="comment">//这个方法在下面有介绍  </span></div><div class="line">            heightSizeAndState);  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (matchWidth) &#123;  </div><div class="line">        forceUniformWidth(count, heightMeasureSpec);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>针对竖直的LinearLayout而言，它的水平方向的测量遵循View的测量过程，在竖直方向的测量过程则和View有所不同。<br>具体来说，如果它的布局中高度采用的是match_parent或者具体数值，那么它的测量过程和View一致，即高度为specSize；<br>如果它的布局中高度曹勇的是wrap_content，那么它的高度是所有子元素所占用的高度总和，但是仍然不能超过它的父容器的剩余空间，<br>当然它的最终高度还需要考虑其在竖直方向的padding，这个过程可以参考如下的源码：这个方法是在View.java中实现的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">/** </div><div class="line"> * Utility to reconcile a desired size and state, with constraints imposed </div><div class="line"> * by a MeasureSpec.  Will take the desired size, unless a different size </div><div class="line"> * is imposed by the constraints.  The returned value is a compound integer, </div><div class="line"> * with the resolved size in the &#123;@link #MEASURED_SIZE_MASK&#125; bits and </div><div class="line"> * optionally the bit &#123;@link #MEASURED_STATE_TOO_SMALL&#125; set if the resulting </div><div class="line"> * size is smaller than the size the view wants to be. </div><div class="line"> * </div><div class="line"> * @param size How big the view wants to be </div><div class="line"> * @param measureSpec Constraints imposed by the parent </div><div class="line"> * @return Size information bit mask as defined by </div><div class="line"> * &#123;@link #MEASURED_SIZE_MASK&#125; and &#123;@link #MEASURED_STATE_TOO_SMALL&#125;. </div><div class="line"> */  </div><div class="line">public static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState) &#123;  </div><div class="line">    int result = size;  </div><div class="line">    int specMode = MeasureSpec.getMode(measureSpec);  </div><div class="line">    int specSize =  MeasureSpec.getSize(measureSpec);  </div><div class="line">    switch (specMode) &#123;  </div><div class="line">    case MeasureSpec.UNSPECIFIED:  </div><div class="line">        result = size;  </div><div class="line">        break;  </div><div class="line">    case MeasureSpec.AT_MOST:  </div><div class="line">        if (specSize &lt; size) &#123;  </div><div class="line">            result = specSize | MEASURED_STATE_TOO_SMALL;  </div><div class="line">        &#125; else &#123;  </div><div class="line">            result = size;  </div><div class="line">        &#125;  </div><div class="line">        break;  </div><div class="line">    case MeasureSpec.EXACTLY:  </div><div class="line">        result = specSize;  </div><div class="line">        break;  </div><div class="line">    &#125;  </div><div class="line">    return result | (childMeasuredState&amp;MEASURED_STATE_MASK);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到此为止，measure完成以后，通过 个图MeasuredWidth、MeasuredHeight方法就可以正确地获取到View的测量宽高。<br>注意点：在某些极端情况下，系统需要多次测量measure才能确定最终的测量宽高，这种情况下，在onMeasure方法中拿到的测量宽高很可能是不准确的。<br>一个比较好的习惯是在onLayout方法中去获取View的测量宽高或者说是最终宽高。</p>
<h2 id="解决View的measure过程和Activity生命周期不同步的问题"><a href="#解决View的measure过程和Activity生命周期不同步的问题" class="headerlink" title="解决View的measure过程和Activity生命周期不同步的问题"></a>解决View的measure过程和Activity生命周期不同步的问题</h2><ol>
<li><p>当我们想要在Activity已启动的时候就做一个任务，但是这个任务需要获取某个View 的宽高。但是由于View的measure和Activity的生命周期不同步执行，因此无法保证Activity执行了onCreate、onStart、onResume时某个View已经测量完毕了，如果View 还没有测量完毕，那么获得的宽高就是0，具体的解决方法有四种：</p>
</li>
<li><p>解决方法一：onWindowFocusChanged<br>源码位置：sources\android\view\View.java。<br>onWindowFocusChanged 这个方法的含义是：View已经初始化完毕了，宽高已经准备好了，这个时候获取宽高是没有问题的。<br>onWindowFocusChanged会被调用多次，当Activity的窗口得到焦点或失去焦点的时候都会被调用一次。<br>也就是说，当Activity继续执行或暂停执行的时候，onWindowFocusChanged就会被调用。<br>那如果频繁的onResume或onPause时，onWindowFocusChanged 也会被频繁的调用。<br>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * Called when the window containing this view gains or loses focus.  Note </div><div class="line"> * that this is separate from view focus: to receive key events, both </div><div class="line"> * your view and its window must have focus.  If a window is displayed </div><div class="line"> * on top of yours that takes input focus, then your own window will lose </div><div class="line"> * focus but the view focus will remain unchanged. </div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> hasWindowFocus True if the window containing this view now has </div><div class="line"> *        focus, false otherwise. </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasWindowFocus)</span> </span>&#123;  </div><div class="line">    InputMethodManager imm = InputMethodManager.peekInstance();  </div><div class="line">    <span class="keyword">if</span> (!hasWindowFocus) &#123;  </div><div class="line">        <span class="keyword">if</span> (isPressed()) &#123;  </div><div class="line">            setPressed(<span class="keyword">false</span>);  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">if</span> (imm != <span class="keyword">null</span> &amp;&amp; (mPrivateFlags &amp; PFLAG_FOCUSED) != <span class="number">0</span>) &#123;  </div><div class="line">            imm.focusOut(<span class="keyword">this</span>);  </div><div class="line">        &#125;  </div><div class="line">        removeLongPressCallback();  </div><div class="line">        removeTapCallback();  </div><div class="line">        onFocusLost();  </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm != <span class="keyword">null</span> &amp;&amp; (mPrivateFlags &amp; PFLAG_FOCUSED) != <span class="number">0</span>) &#123;  </div><div class="line">        imm.focusIn(<span class="keyword">this</span>);  </div><div class="line">    &#125;  </div><div class="line">    refreshDrawableState();  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>重写onWindowFocusChanged 代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasFocus)</span> </span>&#123;  </div><div class="line">    <span class="keyword">super</span>.onWindowFocusChanged(hasFocus);  </div><div class="line">    <span class="comment">// 如果重新获得焦点，那就获取宽高值：  </span></div><div class="line">    <span class="keyword">if</span>(hasFocus)&#123;  </div><div class="line">        <span class="keyword">int</span> width = view.getMeasuredWidth();  </div><div class="line">        <span class="keyword">int</span> height = view.getMeasureHeight();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li><p>解决方法二：view.post(runnable)<br>源码位置：sources\android\app\Activity.java。<br>通过post可以将一个runnable投递到消息队列的尾部，然后等待Looper调用此runnable的时候，View 也已经初始化好了。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">super</span>.onStart();  </div><div class="line">      </div><div class="line">    view.post(<span class="keyword">new</span> Runnable)&#123;  </div><div class="line">        <span class="meta">@Override</span>  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </div><div class="line">            <span class="keyword">int</span> width = view.getMeasuredWidth();  </div><div class="line">            <span class="keyword">int</span> height = view.getMeasuredHeight();  </div><div class="line">        &#125;  </div><div class="line">    &#125;;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>解决方法三：ViewTreeObserver</p>
</li>
<li><p>解决方法四：view.measure(int widthMeasureSpec， int heightMeasureSpec)<br>通过手动对View进行measure来得到View的宽高。这种方法比较复杂，这里要分情况处理，根据View的 LayoutParames 来分：<br><strong>match_parent：</strong><br>直接放弃，无法measure出具体的宽高。因为我们此时还没有办法知道父容器的剩余空间。<br><strong>具体的数值（dp/ps）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 比如宽高都是100px  </span></div><div class="line"><span class="keyword">int</span> widthMeasureSpec = MeasureSpec.makeMeasureSpec(<span class="number">100</span>, MeasureSpec.EXACTLY);  </div><div class="line"><span class="keyword">int</span> heightMeasureSpec = MeasureSpec.makeMeasureSpec(<span class="number">100</span>,MeasureSpec.EXACTLY);  </div><div class="line">  </div><div class="line">view.measure(widthMeasureSpec, heightMeasureSpec);</div></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>wrap_content：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> widthMeasureSpec = MeasureSpec.makeMeasureSpec( (<span class="number">1</span> &lt;&lt; <span class="number">30</span>) - <span class="number">1</span>, MeasureSpec.AT_MOST);  </div><div class="line"><span class="keyword">int</span> heightMeasureSpec = MeasureSpec.makeMeasureSpec( (<span class="number">1</span> &lt;&lt; <span class="number">30</span>) - <span class="number">1</span>,MeasureSpec.AT_MOST);  </div><div class="line">  </div><div class="line">view.measure(widthMeasureSpec, heightMeasureSpec);</div></pre></td></tr></table></figure></p>
<p>要知道的是(1 &lt;&lt; 30) - 1，VIew 的尺寸使用30位二进制表示，也就是说最大是30个1，也就是(1 &lt;&lt; 30) - 1。<br>在最大化模式下，我们使用View理论上能支持的最大值去构造MeasureSpec是合理的。</p>
<h2 id="常见Measure错误使用方法："><a href="#常见Measure错误使用方法：" class="headerlink" title="常见Measure错误使用方法："></a>常见Measure错误使用方法：</h2><p>无法通过错误的MeasureSpec去得出合法的SpecMode，从而导致measure过程出错，违背了系统内部的实现规范;其次不能保证一定能measure出正确结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> widthMeasureSpec = MeasureSpec.makeMeasureSpec( -<span class="number">1</span>, MeasureSpec.UNSPECIFIED);  </div><div class="line"><span class="keyword">int</span> heightMeasureSpec = MeasureSpec.makeMeasureSpec( -<span class="number">1</span>, MeasureSpec.UNSPECIFIED);  </div><div class="line">  </div><div class="line">view.measure(widthMeasureSpec, heightMeasureSpec);</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.measure(LayoutParames.WRAP_CONTENT, LayoutParames.WRAP_CONTENT);</div></pre></td></tr></table></figure>
<h1 id="View的layout过程"><a href="#View的layout过程" class="headerlink" title="View的layout过程"></a>View的layout过程</h1><ol>
<li>Layout的作用是ViewGroup用来确定子元素的位置，当ViewGroup的位置被确定后，它在 onLayout 中会遍历所有的子元素并调用其layout方法。<br>在layout方法中onLayout方法又会被调用。</li>
<li>layout方法会确定View本身的位置！！！！<br>而onLayout方法会确定所有子元素的位置！！！</li>
<li>先看View的layout方法：<br>源码位置：sources\android\view\View.java。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * Assign a size and position to a view and all of its </div><div class="line"> * descendants </div><div class="line"> * </div><div class="line"> * &lt;p&gt;This is the second phase of the layout mechanism. </div><div class="line"> * (The first is measuring). In this phase, each parent calls </div><div class="line"> * layout on all of its children to position them. </div><div class="line"> * This is typically done using the child measurements </div><div class="line"> * that were stored in the measure pass().&lt;/p&gt; </div><div class="line"> * </div><div class="line"> * &lt;p&gt;Derived classes should not override this method. </div><div class="line"> * Derived classes with children should override </div><div class="line"> * onLayout. In that method, they should </div><div class="line"> * call layout on each of their children.&lt;/p&gt; </div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> l Left position, relative to parent </div><div class="line"> * <span class="doctag">@param</span> t Top position, relative to parent </div><div class="line"> * <span class="doctag">@param</span> r Right position, relative to parent </div><div class="line"> * <span class="doctag">@param</span> b Bottom position, relative to parent </div><div class="line"> */  </div><div class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>&#125;)  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;  </div><div class="line">        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);  </div><div class="line">        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">int</span> oldL = mLeft;  </div><div class="line">    <span class="keyword">int</span> oldT = mTop;  </div><div class="line">    <span class="keyword">int</span> oldB = mBottom;  </div><div class="line">    <span class="keyword">int</span> oldR = mRight;  </div><div class="line">  </div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 首先通过setFrame方法来设定View的四个顶点的位置， </div><div class="line">     * 即初始化mLeft、mTop、mBottom、mRight这四个值， </div><div class="line">     * 这四个顶点一旦被确定，那么View在父容器中的位置也就确定了 </div><div class="line">     * */  </div><div class="line">    <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?  </div><div class="line">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;  </div><div class="line">        <span class="comment">/* </span></div><div class="line">         * 接着调用onLayout方法，这个方法的用途是父容器确定子元素的位置，和onMeasure方法类似。 </div><div class="line">         * onLayout的具体实现同样和具体的布局有关， </div><div class="line">         * 所以View和ViewGroup都没有真正实现onLayout方法。 </div><div class="line">         * */  </div><div class="line">        onLayout(changed, l, t, r, b);  </div><div class="line">        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;  </div><div class="line">  </div><div class="line">        ListenerInfo li = mListenerInfo;  </div><div class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;  </div><div class="line">            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =  </div><div class="line">                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();  </div><div class="line">            <span class="keyword">int</span> numListeners = listenersCopy.size();  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;  </div><div class="line">                listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;  </div><div class="line">    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>其中涉及到onLayout方法，我们看看View源码中是如何写的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * Called from layout when this view should </div><div class="line"> * assign a size and position to each of its children. </div><div class="line"> * </div><div class="line"> * Derived classes with children should override </div><div class="line"> * this method and call layout on each of </div><div class="line"> * their children. </div><div class="line"> * <span class="doctag">@param</span> changed This is a new size or position for this view </div><div class="line"> * <span class="doctag">@param</span> left Left position, relative to parent </div><div class="line"> * <span class="doctag">@param</span> top Top position, relative to parent </div><div class="line"> * <span class="doctag">@param</span> right Right position, relative to parent </div><div class="line"> * <span class="doctag">@param</span> bottom Bottom position, relative to parent </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>什么也没有是吧！</p>
<ol>
<li>那就去看看LinearLayout的onLayout方法：<br>源码位置：sources\android\widget\LinearLayout.java。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;  </div><div class="line">        layoutVertical(l, t, r, b);  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        layoutHorizontal(l, t, r, b);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>同样的，分为垂直和水平两种情况。下面去看看layoutVertical好了。</p>
<ol>
<li>layoutVertical方法，只看有注释的地方就可以了：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * Position the children during a layout pass if the orientation of this </div><div class="line"> * LinearLayout is set to &#123;<span class="doctag">@link</span> #VERTICAL&#125;. </div><div class="line"> * </div><div class="line"> * <span class="doctag">@see</span> #getOrientation() </div><div class="line"> * <span class="doctag">@see</span> #setOrientation(int) </div><div class="line"> * <span class="doctag">@see</span> #onLayout(boolean, int, int, int, int) </div><div class="line"> * <span class="doctag">@param</span> left </div><div class="line"> * <span class="doctag">@param</span> top </div><div class="line"> * <span class="doctag">@param</span> right </div><div class="line"> * <span class="doctag">@param</span> bottom </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutVertical</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;  </div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> paddingLeft = mPaddingLeft;  </div><div class="line">  </div><div class="line">    <span class="keyword">int</span> childTop;  </div><div class="line">    <span class="keyword">int</span> childLeft;  </div><div class="line">      </div><div class="line">    <span class="comment">// Where right end of child should go  </span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> width = right - left;  </div><div class="line">    <span class="keyword">int</span> childRight = width - mPaddingRight;  </div><div class="line">      </div><div class="line">    <span class="comment">// Space available for child  </span></div><div class="line">    <span class="keyword">int</span> childSpace = width - paddingLeft - mPaddingRight;  </div><div class="line">      </div><div class="line">    <span class="comment">// 获取子元素个数：  </span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount();  </div><div class="line">  </div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;  </div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;  </div><div class="line">  </div><div class="line">    <span class="keyword">switch</span> (majorGravity) &#123;  </div><div class="line">       <span class="keyword">case</span> Gravity.BOTTOM:  </div><div class="line">           <span class="comment">// mTotalLength contains the padding already  </span></div><div class="line">           childTop = mPaddingTop + bottom - top - mTotalLength;  </div><div class="line">           <span class="keyword">break</span>;  </div><div class="line">  </div><div class="line">           <span class="comment">// mTotalLength contains the padding already  </span></div><div class="line">       <span class="keyword">case</span> Gravity.CENTER_VERTICAL:  </div><div class="line">           childTop = mPaddingTop + (bottom - top - mTotalLength) / <span class="number">2</span>;  </div><div class="line">           <span class="keyword">break</span>;  </div><div class="line">  </div><div class="line">       <span class="keyword">case</span> Gravity.TOP:  </div><div class="line">       <span class="keyword">default</span>:  </div><div class="line">           childTop = mPaddingTop;  </div><div class="line">           <span class="keyword">break</span>;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 遍历所有的子元素，并调用setChildFrame： </div><div class="line">     * */  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;  </div><div class="line">        <span class="keyword">final</span> View child = getVirtualChildAt(i);  </div><div class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;  </div><div class="line">            childTop += measureNullChild(i);  </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;  </div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childWidth = child.getMeasuredWidth();  </div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();  </div><div class="line">              </div><div class="line">            <span class="keyword">final</span> LinearLayout.LayoutParams lp =  </div><div class="line">                    (LinearLayout.LayoutParams) child.getLayoutParams();  </div><div class="line">              </div><div class="line">            <span class="keyword">int</span> gravity = lp.gravity;  </div><div class="line">            <span class="keyword">if</span> (gravity &lt; <span class="number">0</span>) &#123;  </div><div class="line">                gravity = minorGravity;  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();  </div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);  </div><div class="line">            <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;  </div><div class="line">                <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:  </div><div class="line">                    childLeft = paddingLeft + ((childSpace - childWidth) / <span class="number">2</span>)  </div><div class="line">                            + lp.leftMargin - lp.rightMargin;  </div><div class="line">                    <span class="keyword">break</span>;  </div><div class="line">  </div><div class="line">                <span class="keyword">case</span> Gravity.RIGHT:  </div><div class="line">                    childLeft = childRight - childWidth - lp.rightMargin;  </div><div class="line">                    <span class="keyword">break</span>;  </div><div class="line">  </div><div class="line">                <span class="keyword">case</span> Gravity.LEFT:  </div><div class="line">                <span class="keyword">default</span>:  </div><div class="line">                    childLeft = paddingLeft + lp.leftMargin;  </div><div class="line">                    <span class="keyword">break</span>;  </div><div class="line">            &#125;  </div><div class="line">  </div><div class="line">            <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;  </div><div class="line">                childTop += mDividerHeight;  </div><div class="line">            &#125;  </div><div class="line">  </div><div class="line">            childTop += lp.topMargin;  </div><div class="line">            <span class="comment">/* </span></div><div class="line">             * 在这里设置子元素的四个顶点值， </div><div class="line">             * 其中的childTop会不断增大， </div><div class="line">             * 这就意味着后面的子元素会被放置在靠下的位置， </div><div class="line">             * 这刚好符合竖直方向的LinearLayout的特性。 </div><div class="line">             * 但在setChildFrame中，其实它仅仅是调用了子元素的layout方法而已， </div><div class="line">             * */  </div><div class="line">            setChildFrame(child, childLeft, childTop + getLocationOffset(child),  </div><div class="line">                    childWidth, childHeight);  </div><div class="line">            childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);  </div><div class="line">  </div><div class="line">            i += getChildrenSkipCount(child, i);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>其中的setChildFrame方法是这样写的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setChildFrame</span><span class="params">(View child, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;          </div><div class="line">    child.layout(left, top, left + width, top + height);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>还可以发现在setChildFrame中的width和height实际上就是子元素的测量宽高，就是在setChildFrame中的后两个参数是这样获取的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> childWidth = child.getMeasuredWidth();  </div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</div></pre></td></tr></table></figure></p>
<ol>
<li>这样父元素在layout方法中完成自己的定位以后，就通过onLayout方法去调用子元素的layout方法，子元素又会通过自己的layout方法来确定自己的位置，这样一层一层地传递下去就完成了整个View树的layout过程。</li>
<li>测量宽高和最终宽高之间的联系：<br>源码位置：sources\android\view\View.java。<br>getHeight获取的是最终高度：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * Return the height of your view. </div><div class="line"> * </div><div class="line"> * <span class="doctag">@return</span> The height of your view, in pixels. </div><div class="line"> */  </div><div class="line"><span class="meta">@ViewDebug</span>.ExportedProperty(category = <span class="string">"layout"</span>)  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> mBottom - mTop;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>getMeasuredHeight获取的是测量高度：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">/** </div><div class="line"> * Like &#123;@link #getMeasuredHeightAndState()&#125;, but only returns the </div><div class="line"> * raw width component (that is the result is masked by </div><div class="line"> * &#123;@link #MEASURED_SIZE_MASK&#125;). </div><div class="line"> * </div><div class="line"> * @return The raw measured height of this view. </div><div class="line"> */  </div><div class="line">public final int getMeasuredHeight() &#123;  </div><div class="line">    return mMeasuredHeight &amp; MEASURED_SIZE_MASK;  </div><div class="line">&#125;  </div><div class="line">``` </div><div class="line"></div><div class="line">其实本质上来说他们两个是相同的，</div><div class="line">只是测量宽高形成于View的measure过程，而最终宽高形成于View的layout过程，即两者的赋值时机不同，测量宽高的赋值时机稍微早一些。</div><div class="line"></div><div class="line">ViewGroup需要负责子View显示的大小。当ViewGroup的大小为wrap_content时，ViewGroup就需要遍历子View，以便获得所有子View的大小，从而决定自己的大小。而在其他模式下则会通过具体的指定值来设置自身的大小。</div><div class="line">ViewGroup在测量时通过遍历所有子View，从而调用子View的Measure方法来获得每一个子View的测量结果。</div><div class="line">当子View测量完毕后，就需要将子View放到合适的位置，这个过程就是View 的Layout过程。ViewGroup在执行Layout过程时，同样是使用遍历来调用子View的Layout方法，并指定其具体显示的位置，从而来决定其布局位置。</div><div class="line">在自定义ViewGroup时，通常会去重写onLayout（）方法来控制其子View显示位置的逻辑。同样，如果需要支持wrap_content属性，那么它还必须重写onMeasure（）方法，这点与View是相同的。</div><div class="line"></div><div class="line"># View的绘制draw #</div><div class="line"></div><div class="line">1. 当测量好一个View之后，我们就可以简单的重写 onDraw（）方法，并在 Canvas 对象上来绘制所需要的图形。Canvas是onDraw（）方法的一个参数。</div><div class="line">要想在Android界面中绘制相应的图像，就必须在 Canvas 上进行绘制。 它就像一个画板，使用 Paint 就可以在上面作画了。</div><div class="line">2. 通常我们要在onDraw外创建一个Canvas对象，创建时还要引入布局中的一个bitmap对象：Canvas canvas = new Canvas(bitmap);  </div><div class="line">这里必须是一个bitmap对象，他与Canvas画布是紧紧联系在一起的，这个过程叫做 装载画布。</div><div class="line">3. bitmap用来存储所有绘制在 Canvas 上的像素信息，都是设置给bitmap的。</div><div class="line">举例：</div><div class="line">``` java</div><div class="line">//绘制两个bitmap：这两个是在onDraw中绘制的  </div><div class="line">canvas.drawBitmap(bitmap1,0,0,null);  </div><div class="line">canvas.drawBitmap(bitmap2.0,0,null);  </div><div class="line">// 现在将bitmap2装载到onDrow（）之外的Canvas对象中：  </div><div class="line">mCanvas = new Canvas(bitmap2);  </div><div class="line">// 然后通过mCanvas对bitmap2进行绘图：  </div><div class="line">mCanvas.drawXXX;</div></pre></td></tr></table></figure></p>
<p>这样通过mCanvas对bitmap2的绘制，刷新View后bitmap2就会发生相应的改变了。所以说所有的Canvas的绘制都是作用在bitmap上的，与在哪里，与哪个Canvas无关。</p>
<ol>
<li>Draw过程比较简单，它的作用是将View绘制到屏幕上面。</li>
<li>View的绘制过程遵循如下几步：<br>绘制背景 background.draw(canvas)<br>绘制自己 （onDraw）<br>绘制children （dispatchDraw）<br>绘制装饰 （onDrawScrollBars）</li>
<li><p>下面看看draw方法的源码：<br>源码位置：sources\android\view\View.java。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * Manually render this view (and all of its children) to the given Canvas. </div><div class="line"> * The view must have already done a full layout before this function is </div><div class="line"> * called.  When implementing a view, implement </div><div class="line"> * &#123;<span class="doctag">@link</span> #onDraw(android.graphics.Canvas)&#125; instead of overriding this method. </div><div class="line"> * If you do need to override this method, call the superclass version. </div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> canvas The Canvas to which the View is rendered. </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (mClipBounds != <span class="keyword">null</span>) &#123;  </div><div class="line">        canvas.clipRect(mClipBounds);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> privateFlags = mPrivateFlags;  </div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;  </div><div class="line">            (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);  </div><div class="line">    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;  </div><div class="line">  </div><div class="line">    <span class="comment">/* </span></div><div class="line">     * Draw traversal performs several drawing steps which must be executed </div><div class="line">     * in the appropriate order: </div><div class="line">     * </div><div class="line">     *      1. Draw the background </div><div class="line">     *      2. If necessary, save the canvas' layers to prepare for fading </div><div class="line">     *      3. Draw view's content </div><div class="line">     *      4. Draw children </div><div class="line">     *      5. If necessary, draw the fading edges and restore layers </div><div class="line">     *      6. Draw decorations (scrollbars for instance) </div><div class="line">     */  </div><div class="line">  </div><div class="line">    <span class="comment">// Step 1, draw the background, if needed 绘制背景  </span></div><div class="line">    <span class="keyword">int</span> saveCount;  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (!dirtyOpaque) &#123;  </div><div class="line">        <span class="keyword">final</span> Drawable background = mBackground;  </div><div class="line">        <span class="keyword">if</span> (background != <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> scrollX = mScrollX;  </div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> scrollY = mScrollY;  </div><div class="line">  </div><div class="line">            <span class="keyword">if</span> (mBackgroundSizeChanged) &#123;  </div><div class="line">                background.setBounds(<span class="number">0</span>, <span class="number">0</span>,  mRight - mLeft, mBottom - mTop);  </div><div class="line">                mBackgroundSizeChanged = <span class="keyword">false</span>;  </div><div class="line">            &#125;  </div><div class="line">  </div><div class="line">            <span class="keyword">if</span> ((scrollX | scrollY) == <span class="number">0</span>) &#123;  </div><div class="line">                background.draw(canvas);  </div><div class="line">            &#125; <span class="keyword">else</span> &#123;  </div><div class="line">                canvas.translate(scrollX, scrollY);  </div><div class="line">                background.draw(canvas);  </div><div class="line">                canvas.translate(-scrollX, -scrollY);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">// skip step 2 &amp; 5 if possible (common case)  </span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;  </div><div class="line">    <span class="keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;  </div><div class="line">    <span class="keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;  </div><div class="line">    <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;  </div><div class="line">        <span class="comment">// Step 3, draw the content 绘制自己  </span></div><div class="line">        <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);  </div><div class="line">  </div><div class="line">        <span class="comment">// Step 4, draw the children 绘制Children  </span></div><div class="line">        dispatchDraw(canvas);  </div><div class="line">  </div><div class="line">        <span class="comment">// Step 6, draw decorations (scrollbars) 绘制装饰  </span></div><div class="line">        onDrawScrollBars(canvas);  </div><div class="line">  </div><div class="line">        <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;  </div><div class="line">            mOverlay.getOverlayView().dispatchDraw(canvas);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="comment">// we're done...  </span></div><div class="line">        <span class="keyword">return</span>;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在View.java中有dispatchDraw方法，但它是空的，其他的继承了View的比如说ViewGroup就要去重写这个方法去实现对子元素的绘制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * Called by draw to draw the child views. This may be overridden </div><div class="line"> * by derived classes to gain control just before its children are drawn </div><div class="line"> * (but after its own view has been drawn). </div><div class="line"> * <span class="doctag">@param</span> canvas the canvas on which to draw the view </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">  </div><div class="line">&#125; </div><div class="line">``` </div><div class="line"><span class="number">8</span>. ViewGroup通常不需要绘制，因为他本身就没有需要绘制的东西，如果不是指定了ViewGroup的背景颜色，那么ViewGroup的onDrow（）方法都不会被调用。</div><div class="line">但是，ViewGroup会使用dispatchDraw（）方法绘制其子View，其过程同样是遍历所有的子View，并调用子View的绘制方法来完成绘制工作。</div><div class="line">关于ViewGroup中dispatchDraw 方法的具体实现我们就在这里不列举了。</div><div class="line"><span class="number">9</span>. View中还有一个特殊的方法：setWillNotDraw：</div><div class="line">``` java</div><div class="line"><span class="comment">/** </span></div><div class="line"> * If this view doesn't do any drawing on its own, set this flag to </div><div class="line"> * allow further optimizations. By default, this flag is not set on </div><div class="line"> * View, but could be set on some View subclasses such as ViewGroup. </div><div class="line"> * </div><div class="line"> * Typically, if you override &#123;<span class="doctag">@link</span> #onDraw(android.graphics.Canvas)&#125; </div><div class="line"> * you should clear this flag. </div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> willNotDraw whether or not this View draw on its own </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWillNotDraw</span><span class="params">(<span class="keyword">boolean</span> willNotDraw)</span> </span>&#123;  </div><div class="line">    setFlags(willNotDraw ? WILL_NOT_DRAW : <span class="number">0</span>, DRAW_MASK);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>如果一个View不需要绘制任何内容，那么设置这个标记位为true以后，系统就会进行相应的优化。默认情况下，View并没有启用这个优化标记位，但是ViewGroup会默认启用这个优化标记位。<br>这个标记位对实际开发的意义是：当我们的自定义控件继承于ViewGroup并且本身不具备绘制功能时，就可以开启这个标记位从而便于系统进行后续的优化。<br>当然，当明确知道一个ViewGroup需要通过onDraw来绘制内容时，我们需要显式的关闭WILL_NOT_DRAW 这个标志位。</p>
<h1 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h1><p>……..</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/原创/" rel="tag">#原创</a>
          
            <a href="/tags/android/" rel="tag">#android</a>
          
            <a href="/tags/Android群英传/" rel="tag">#Android群英传</a>
          
            <a href="/tags/控件/" rel="tag">#控件</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/09/21/第一章：Android体系与系统架构丶第二章：Android开发工具新接触/" rel="next" title="第一章：Android体系与系统架构丶第二章：Android开发工具新接触">
                <i class="fa fa-chevron-left"></i> 第一章：Android体系与系统架构丶第二章：Android开发工具新接触
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/10/03/第三章：Android控件架构与自定义控件详解/"
           data-title="第三章：Android控件架构与自定义控件详解" data-url="http://yoursite.com/2016/10/03/第三章：Android控件架构与自定义控件详解/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://7xu1cb.com1.z0.glb.clouddn.com/IMG_0273.JPG"
               alt="TokgoLiang" />
          <p class="site-author-name" itemprop="name">TokgoLiang</p>
          <p class="site-description motion-element" itemprop="description">In me the tiger sniffs the rose.</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">17</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://qiushao.net/" title="qiushao的博客" target="_blank">qiushao的博客</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Android控件架构"><span class="nav-number">1.</span> <span class="nav-text">Android控件架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Android控件树"><span class="nav-number">1.1.</span> <span class="nav-text">Android控件树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android界面架构"><span class="nav-number">1.2.</span> <span class="nav-text">Android界面架构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ViewRoot和DecorView介绍"><span class="nav-number">2.</span> <span class="nav-text">ViewRoot和DecorView介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ViewRoot简介"><span class="nav-number">2.1.</span> <span class="nav-text">ViewRoot简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DecorView简介"><span class="nav-number">2.2.</span> <span class="nav-text">DecorView简介</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#View的测量"><span class="nav-number">3.</span> <span class="nav-text">View的测量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MeasureSpec简介"><span class="nav-number">3.1.</span> <span class="nav-text">MeasureSpec简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MeasurSpec和LayoutParams的对应关系"><span class="nav-number">3.2.</span> <span class="nav-text">MeasurSpec和LayoutParams的对应关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#View的measure过程"><span class="nav-number">4.</span> <span class="nav-text">View的measure过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#View的measure过程-1"><span class="nav-number">4.1.</span> <span class="nav-text">View的measure过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ViewGroup的measure过程"><span class="nav-number">4.2.</span> <span class="nav-text">ViewGroup的measure过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解决View的measure过程和Activity生命周期不同步的问题"><span class="nav-number">4.3.</span> <span class="nav-text">解决View的measure过程和Activity生命周期不同步的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见Measure错误使用方法："><span class="nav-number">4.4.</span> <span class="nav-text">常见Measure错误使用方法：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#View的layout过程"><span class="nav-number">5.</span> <span class="nav-text">View的layout过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#自定义View"><span class="nav-number">6.</span> <span class="nav-text">自定义View</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TokgoLiang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"tokgoliang"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
