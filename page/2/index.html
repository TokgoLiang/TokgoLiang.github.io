<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="In me the tiger sniffs the rose.">
<meta property="og:type" content="website">
<meta property="og:title" content="TokgoLiang的博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="TokgoLiang的博客">
<meta property="og:description" content="In me the tiger sniffs the rose.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TokgoLiang的博客">
<meta name="twitter:description" content="In me the tiger sniffs the rose.">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/2/"/>

  <title> TokgoLiang的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">TokgoLiang的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/12/第二章：Android网络底层框架设计/" itemprop="url">
                  第二章：Android网络底层框架设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-12T23:29:38+08:00" content="2016-09-12">
              2016-09-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Android_读书笔记</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/App研发录/" itemprop="url" rel="index">
                    <span itemprop="name">App研发录</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/12/第二章：Android网络底层框架设计/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/12/第二章：Android网络底层框架设计/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="网络底层封装"><a href="#网络底层封装" class="headerlink" title="网络底层封装"></a>网络底层封装</h1><p>网络请求的格式：    </p>
<p>对于网络请求，我们一般定义为GET和POST即可，GET为请求数据，POST为修改数据（增删改）</p>
<h2 id="Request格式："><a href="#Request格式：" class="headerlink" title="Request格式："></a>Request格式：</h2><p>所有的MobileAPI都也可以写作<a href="http://www.xxx.com/aaa.api的形式" target="_blank" rel="external">http://www.xxx.com/aaa.api的形式</a></p>
<p>对于GET，我们可以写作<a href="http://www.xxx.com/aaa.api?k1=v1&amp;ke=v2的形式，也就是说，把key-value这样的键值对存放在URL上，之所以这样设计，是为了更方便地定义数据缓存，我们尽量使GET的参数都是String，int这样的简单类型" target="_blank" rel="external">http://www.xxx.com/aaa.api?k1=v1&amp;ke=v2的形式，也就是说，把key-value这样的键值对存放在URL上，之所以这样设计，是为了更方便地定义数据缓存，我们尽量使GET的参数都是String，int这样的简单类型</a></p>
<p>对于POST，我们将key-value这样的键值对存放在From表单中，进行提交。POST经常会提交大量数据，所以有些键值对要定义成集合或者复杂的自定义实体，这时候我们就需要将这样的值转换为JSON字符串进行提交，由App传递到MobileAPI后，再将JSON字符串转换为对应的实体。</p>
<p>上述介绍只是一家之言，不同公司有不同的实现方式，这取决于服务器端的设计。</p>
<h2 id="Response格式："><a href="#Response格式：" class="headerlink" title="Response格式："></a>Response格式：</h2><p>一般使用JSON作为MobileAPI返回结果。规范的JSON数据返回格式如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">          "isError" : false,</div><div class="line">          "errorType" : 0,</div><div class="line">          "errorMessage" : " ",</div><div class="line">          "result" : &#123;</div><div class="line">                  "cinemaId" : 1,</div><div class="line">                  "cinemaName" : "name"</div><div class="line">          &#125;</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<h2 id="AsyncTask的使用和缺点"><a href="#AsyncTask的使用和缺点" class="headerlink" title="AsyncTask的使用和缺点"></a>AsyncTask的使用和缺点</h2><ol>
<li>对于耗时的操作，我们的一般方法是开启“子线程”。如果需要更新UI，则需要使用handler</li>
<li>如果耗时的操作太多，那么我们需要开启太多的子线程，这就会给系统带来巨大的负担，随之也会带来性能方面的问题。在这种情况下我们就可以考虑使用类AsyncTask来异步执行任务，不需要子线程和handler，就可以完成异步操作和刷新UI。</li>
<li>AsyncTask：对线程间的通讯做了包装，是后台线程和UI线程可以简易通讯：后台线程执行异步任务，将result告知UI线程。</li>
<li>使用方法：共分为两步，自定义AsyncTask，在耗时的地方调用自定义的AsyncTask。可以参照以下代码示例。</li>
</ol>
<p><strong>step1：继承AsyncTask<params,progress,result></params,progress,result></strong></p>
<ul>
<li>Params:输入参数。对应的是调用自定义的AsyncTask的类中调用excute()方法中传递的参数。如果不需要传递参数，则直接设为Void即可。</li>
<li>Progress：子线程执行的百分比</li>
<li>Result：返回值类型。和doInBackground（）方法的返回值类型保持一致。</li>
</ul>
<p><strong>step2：实现以下几个方法：执行时机和作用看示例代码，以下对返回值类型和参数进行说明</strong></p>
<ul>
<li>onPreExecute()：无返回值类型。不传参数</li>
<li>doInBackground(Params… params)：返回值类型和Result保持一致。参数：若无就传递Void；若有，就可用Params</li>
<li>publishProgress(Params… params)：在执行此方法的时候会直接调用onProgressUpdate(Params… values)</li>
<li>onProgressUpdate(Params… values)：无返回值类型。参数：若无就传递Void；若有，就可用Progress</li>
<li>onPostExecute(Result  result) ：无返回值类型。参数：和Result保持一致。</li>
</ul>
<p><strong>step3：在调用自定义的AsyncTask类中生成对象；</strong></p>
<p>执行  ：对象.excute(Params… params);</p>
<p>小注：</p>
<ul>
<li>Task的实例必须在UI thread中创建</li>
<li>execute方法必须在UI thread中调用</li>
<li>不要手动的调用onPreExecute(), onPostExecute(Result)，doInBackground=\’#\’” onProgressUpdate(Progress…)这几个方法</li>
<li>该task只能被执行一次，否则多次调用时将会出现异常</li>
</ul>
<p>参照连接</p>
<blockquote>
<p><a href="http://blog.csdn.net/cjjky/article/details/6684959" target="_blank" rel="external">http://blog.csdn.net/cjjky/article/details/6684959</a><br><a href="http://blog.csdn.net/zhenyongyuan123/article/details/5850389" target="_blank" rel="external">http://blog.csdn.net/zhenyongyuan123/article/details/5850389</a><br><a href="http://www.eoeandroid.com/thread-102664-1-1.html" target="_blank" rel="external">http://www.eoeandroid.com/thread-102664-1-1.html</a><br><a href="http://www.cnblogs.com/suinuaner/archive/2013/04/11/android_fifty.html" target="_blank" rel="external">http://www.cnblogs.com/suinuaner/archive/2013/04/11/android_fifty.html</a></p>
</blockquote>
<p>致命缺点，不能灵活控制其内部的线程池</p>
<ul>
<li>AsyncTast没有暴露出取消请求的方法，也就是我们熟知的CancelRequest方法，所以，一旦从A页面跳转到B页面，那么在A页面发起的请求，如果还没有返回，并不会被取消。</li>
<li>使用原生的ThreadPoolExecutor+Runnable+Handler</li>
<li>源码下载地址：<a href="http://files.cnblogs.com/files/Jax/2.1.4.zip" target="_blank" rel="external">http://files.cnblogs.com/files/Jax/2.1.4.zip</a></li>
</ul>
<h1 id="App数据缓存设计"><a href="#App数据缓存设计" class="headerlink" title="App数据缓存设计"></a>App数据缓存设计</h1><p>访问MobileAPI速度慢，主要慢在一来一回的传输速度上，</p>
<p><strong>对应措施，例如减少MobileAPI的调用次数，</strong></p>
<p>对于一个App页面，它一次性可能需要3部分数据，分别从3个MobileAPI接口获取，那么可以做一个新的MobileAPI接口，将这3部分数据都获取到一次性返回。</p>
<p>更极端的做法，APP在调用一次MobileAPI接口后，在一段时间内不再调用，仍然使用上次返回的数据，这些数据保存在APP上，我们称之为APP缓存，这个时间段我们称之为APP缓存时间。</p>
<p>App缓存智能针对GET类型接口，不适用于POST，对于GET类型接口也要看情况来设定缓存时间，或者不缓存。</p>
<p><strong>强制更新</strong></p>
<p>缓存是一把双刃剑，设置时间长了，数据长期不更新，用户体验就会不好，因此需要提供一个强制刷新的接口。</p>
<h1 id="MockService"><a href="#MockService" class="headerlink" title="MockService"></a>MockService</h1><p>（看起来像测试里面的桩模块。。。。）</p>
<p>因为App与MobileAPI之间的依赖，在MobileAPI接口还没好二APP又急等着用，或者随着App开发，App开发人员发现原来约定好的字段不够用等问题，要求MobileAPI开发人员频繁修改Mock接口并部署到测试环境。</p>
<p>为了提高效率，我们需要解除这种依赖，为此我们在App端设计自己的MockService，在App端Mock自己的数据。</p>
<h1 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h1><p><strong>登录成功后的各种场景</strong></p>
<p>情形1：点击登录按钮，进入登录页面，登陆成功后直接进入个人中心页面，一路执行startActivity即可</p>
<p>情形2：在页面A，想要跳转到页面B，并携带一些参数，却发现没有登录，于是先跳转到登录页面，登陆成功后跳转到B页面，同时仍携带那些参数</p>
<p>情形3：在页面A，执行某个操作，发现没有登录，于是跳转到登录界面，登录成功后，饭后页面A继续执行操作</p>
<p><strong>处理方法：</strong></p>
<p>1.对于情形2，在页面A，使用startActivityForResult，<br>2.在LoginActivity整合逻辑，通过判断，处理登录之后的操作，if(needCallback) setResult()，finish();<br>3.在LoginMainActivity重写onActivityResult毁掉函数switch(requestCode) </p>
<p><strong>自动登录</strong></p>
<p>最直接的做法是，登录之后，本地保存用户名和密码，重启App之后检测本地是否有保存用户名和密码，如果有，则将用户名和密码传入到登录接口，模拟用户登录行为。但是会有安全风险以及验证码的问题。</p>
<p>抛弃每次启动就进行一次登录的机制，使用在Web中很成熟的Cookie机制，也有人管Cookie叫Token，是用户身份的唯一性标志</p>
<p><strong>App端</strong></p>
<ol>
<li>每次发起MobileAPI请求时，都要把本地保存的Cookie取出来，放到HttpRequest的header中。</li>
<li>每次接受MobileAPI的响应结果是，都把HttpResponse的header中的Cookie取出来，覆盖本地保存的Cookie，不管Cookie是否有值。</li>
</ol>
<p><strong>服务器端相应操作</strong></p>
<ol>
<li>如果是用户信息相关操作，则判断HttpRequest中Cookie是否有效，如果有效，就去执行后去操作并返回结构，否则，返回Cookie过期失效的错误信息。</li>
<li>如果是用户无关的，则不需要检查HttpRequest中的Cookie，继续执行就可以了。</li>
</ol>
<p><strong>还有几个需要注意的地方</strong></p>
<ul>
<li>用户注销，清空本地保存的Cookie。</li>
<li>用户注册，因为验证码问题，不能直接调用登录接口，解决方案是，注册之后直接跳转到登录页面，让用户手动输入一次。或者把注册和登录接口绑定在一起，注册成功之后进入个人中心页面，不需要再登录一次。</li>
<li><p><strong>Cookie过期的统一处理</strong></p>
</li>
<li><p>服务器返回Cookie过期的错误消息</p>
</li>
<li>在RequestCallback中增加一种onCookieExpired回调方法，</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RequestCallback</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String conntent)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFail</span><span class="params">(String errorMessage)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCookieExpired</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在网络底层对JSON返回结果进行解析，如果发现是属于Cookie过期的错误类型，就直接回调onCookieExpired方法、</li>
</ul>
<p><strong>防止黑客刷库</strong></p>
<ul>
<li>使用验证码</li>
<li>MobileAPI发现有同一个IP短时间内频繁访问某一个MobileAPI接口是，就直接返回一段HTML5，要求用户输入验证码。App接收到这段代码时，就在页面上显示一个浮层，里面一个WebView，显示这个要求用户输入验证码的HTML5.</li>
</ul>
<h1 id="HTTP头中的奥妙"><a href="#HTTP头中的奥妙" class="headerlink" title="HTTP头中的奥妙"></a>HTTP头中的奥妙</h1><p>HTTP请求，分为HTTPRequest和HTTPResponse两种，但是无论哪种请求都由header和body两部分组成。</p>
<h2 id="HTTP-body"><a href="#HTTP-body" class="headerlink" title="HTTP body"></a>HTTP body</h2><p>对于get形式的HTTPRequest，要发送的数据都是以键值对的形式存放在URL上，比如aaa.api?k1=v1&amp;ke=v2。它的body是空的</p>
<p>对于post形式的HTTPRequest，要发送的数据都存在body里面，也是以键值对的形式。</p>
<h2 id="HTTP-header"><a href="#HTTP-header" class="headerlink" title="HTTP header"></a>HTTP header</h2><p>与body相比，header要丰富的多，它由很多键值对组成，其中有些key是标准的，兼容于各大浏览器，比如</p>
<ul>
<li>accept</li>
<li>accept-language</li>
<li>referrer</li>
<li>user-agent</li>
<li>accept-encoding</li>
</ul>
<p>此外我们还可以在MobileAPI端自定义一些键值对，然后要求App在调用MobileAPI时吧这些信息传递过来。</p>
<p><strong>时间校准</strong></p>
<p>MobileAPI端，永远使用UTC时间，包括入参合返回值，都不要使用Data格式，而是减去UTC时间1970年1月1日的差值，这是一个long型。</p>
<p>App端，每次调用MobileAPI，就取出HTTPRequest头的Data值，转换为GMT时间后，再减去本地取出的时间，得到一个差值delta。我们将这个delta保存下来，那么每次取本地时间的时候，再额外加上这个delta值，就得到服务GTM时间。</p>
<p><strong>开启gzip压缩</strong></p>
<p>使用gzip的流程如下：</p>
<ol>
<li>在App发起请求时，在HTTPRequest头中，添加要求支持gzip的key-value，这里的key是Accept-Encoding，value是gzip.</li>
<li>MobileAPI的逻辑是，检查HTTP请求头中的Accept-Encoding是否有gzip值，如果有，就会执行gzip压缩，如果执行了gzip压缩，那么返回值也就是HTTPResponse的头中，有一个content-encoding字段，会带有gzip的值；，否则，就没有这个值</li>
<li>App检查HTTPResponse头中的content-encoding字段是否包含gzip，这个值的有无，导致了App解析HTTPResponse的姿势不同。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/12/第一章：重构，夜未眠/" itemprop="url">
                  第一章：重构，夜未眠
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-12T22:34:39+08:00" content="2016-09-12">
              2016-09-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Android_读书笔记</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/App研发录/" itemprop="url" rel="index">
                    <span itemprop="name">App研发录</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/12/第一章：重构，夜未眠/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/12/第一章：重构，夜未眠/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="重新规划Android项目的目录结构"><a href="#重新规划Android项目的目录结构" class="headerlink" title="重新规划Android项目的目录结构"></a>重新规划Android项目的目录结构</h1><p>第一步：建立AndroidLib类库，将与业务无关的逻辑转移到AndroidLib</p>
<p>AndroidLib中业务无关逻辑至少包括五大部分，</p>
<ul>
<li>activity包，存放与业务无关的Activity积累，Activity基类要分两层，AndroidLib下的基类BaseActivity封装的是业务无关的公用逻辑，主项目中的AppBaseActivity基类封装的事业务相关的公用逻辑。</li>
<li>net包，存放网络底层封装，如AsyncTase</li>
<li>cache包，存放的是缓存数据和图片相关的处理</li>
<li>ui包，存放自定义控件</li>
<li>utils包，存放各种与业务逻辑无关的公用方法，比如对SharedPreferences的封装</li>
</ul>
<p>第二步：将主项目中的类分门别类的进行规划，放置在各种包中，</p>
<ul>
<li>activity包，按照模块继续拆分，将不同模块Activity划分到不同的包下</li>
<li>adapter包，所有适配器都放在一起</li>
<li>entity包，将所有实体都放在一起</li>
<li>db包，SQLLite相关逻辑的封装</li>
<li>engine包，将业务相关的类都放在一起</li>
<li>ui包，将自定义控件都放在一起</li>
<li>uitils包，将所有公用方法</li>
<li>interfaces包，真正意义上的接口，命名以“I”作为开头</li>
<li>listener包，基于Listener的接口，命名以“On”开头</li>
</ul>
<h1 id="为Activity定义新的生命周期"><a href="#为Activity定义新的生命周期" class="headerlink" title="为Activity定义新的生命周期"></a>为Activity定义新的生命周期</h1><p>例如，把onCreate方法中拆成三个子方法</p>
<ul>
<li>initVariables：初始化变量，包括Intent带的数据和Activity内的变量</li>
<li>initViews：加载Layout布局文件，初始化控件，为控件挂上事件的方法</li>
<li>loadData：获取数据</li>
</ul>
<h1 id="统一事件编程模型"><a href="#统一事件编程模型" class="headerlink" title="统一事件编程模型"></a>统一事件编程模型</h1><p><strong>方式一：实现Listener，在onClick方法中使用switch…case…，作者不建议使用</strong></p>
<blockquote>
<p>我不希望R这个类在程序中反复出现，这回扰乱面向对象编程的风格，按照我的设想，我们在initViews方法中一次性把所有的控件都初始化了，今后就再也不会私用R.id了。</p>
</blockquote>
<p><strong>方式二：匿名内部类</strong></p>
<p>作者比较推崇的方法，有以下两个有点：</p>
<ol>
<li>直接在btn按钮对象上曾经点击事件，是面向对象的写法。</li>
<li>将onClick方面的实现，封装成一个对应的方法，这样onClick事件方法就不那么臃肿了。</li>
</ol>
<h1 id="实体化编程"><a href="#实体化编程" class="headerlink" title="实体化编程"></a>实体化编程</h1><h2 id="使用fastJSON（阿里巴巴）和GSON（Google）"><a href="#使用fastJSON（阿里巴巴）和GSON（Google）" class="headerlink" title="使用fastJSON（阿里巴巴）和GSON（Google）"></a>使用fastJSON（阿里巴巴）和GSON（Google）</h2><p>作者使用fastJSON之后遇到的一个问题，表现为</p>
<ol>
<li>加了符号Annotation的实体属性，一使用就奔溃</li>
<li>当有泛型是，一使用就崩溃</li>
</ol>
<p>在调试的时候没事，每次打签名混淆包，就会出现上述问题，原因：</p>
<ul>
<li>–keepattributes Signature                //避免混淆泛型</li>
<li>–keepattributes <em>Annotation</em>            //不混淆注解</li>
</ul>
<h2 id="在页面跳转中使用实体"><a href="#在页面跳转中使用实体" class="headerlink" title="在页面跳转中使用实体"></a>在页面跳转中使用实体</h2><p>一个页面中，数据的来源有两种：</p>
<ul>
<li>调用MobileAPI获取JSON数据,使用fastJSON或者GSON</li>
<li>从上一个页面传递过来,Activity之间的数据传递</li>
</ul>
<p><strong>方法一：使用全局变量</strong></p>
<p>不建议使用，App一旦被切换到后台，当内存不足的时候，就会回收这些全局变量，从而当App再次切回到前台是，再继续使用全局变量，就会因为他们为空二崩溃</p>
<p>如果必须使用全局变量，就一定要把它们序列化到本地，这样即使全局变量味浓，也能从本地文件中恢复</p>
<p><strong>方法二：使用Intent在页面间传递数据实体</strong></p>
<p>注，如果使用Fragment可以使用Fragment来传递数据。。。（我自己加的）</p>
<h1 id="Adapter模板"><a href="#Adapter模板" class="headerlink" title="Adapter模板"></a>Adapter模板</h1><p>作者建议所有的Adapter都继承自BaseAdapter，从构造函数注入List&lt;自定义实体&gt;这样的数据集合，从而完成ListView的填充工作，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CinemaAdapter</span> <span class="keyword">extends</span> <span class="title">BaseAdapter</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;CinemaBean&gt; cinemaList;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AppBaseActivity context;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CinemaAdapter</span><span class="params">(ArrayList&lt;CinemaBean&gt; cinemaList,</span></span></div><div class="line">			AppBaseActivity context) &#123;</div><div class="line">		<span class="keyword">this</span>.cinemaList = cinemaList;</div><div class="line">		<span class="keyword">this</span>.context = context;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> cinemaList.size();</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> CinemaBean <span class="title">getItem</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> cinemaList.get(position);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getItemId</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> position;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> position, View convertView,</span></span></div><div class="line">			<span class="keyword">final</span> ViewGroup parent) &#123;</div><div class="line">		<span class="keyword">final</span> Holder holder;</div><div class="line">		<span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</div><div class="line">			holder = <span class="keyword">new</span> Holder();</div><div class="line">			convertView = context.getLayoutInflater().inflate(</div><div class="line">					R.layout.item_cinemalist, <span class="keyword">null</span>);</div><div class="line">			holder.tvCinemaName = (TextView) convertView</div><div class="line">					.findViewById(R.id.tvCinemaName);</div><div class="line">			holder.tvCinemaId = (TextView) convertView</div><div class="line">					.findViewById(R.id.tvCinemaId);</div><div class="line">			convertView.setTag(holder);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			holder = (Holder) convertView.getTag();</div><div class="line">		&#125;</div><div class="line">		CinemaBean cinema = cinemaList.get(position);</div><div class="line">		holder.tvCinemaName.setText(cinema.getCinemaName());</div><div class="line">		holder.tvCinemaId.setText(cinema.getCinemaId());</div><div class="line">		<span class="keyword">return</span> convertView;</div><div class="line">	&#125;</div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</div><div class="line">		TextView tvCinemaName;</div><div class="line">		TextView tvCinemaId;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于每个自定义的Adapter都要实现以下四个方法</p>
<ul>
<li>getCount()</li>
<li>getItem()</li>
<li>getItemId()</li>
<li>getView()<br>此外还要内置一个ViewHolder</li>
</ul>
<h1 id="类型安全转换函数"><a href="#类型安全转换函数" class="headerlink" title="类型安全转换函数"></a>类型安全转换函数</h1><p><strong>对于一个Object类型的对象，我们对其直接使用字符串操作函数toString，当其为null是就会奔溃</strong></p>
<p>比较好的做法就是，编写一个类型安全转换函数，实现如下，核心思想是，如果转换失败就返回默认值： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">convertToInt</span><span class="params">(Object value, <span class="keyword">int</span> defaultValue)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (value == <span class="keyword">null</span> || <span class="string">""</span>.equals(value.toString().trim())) &#123;</div><div class="line">		<span class="keyword">return</span> defaultValue;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="keyword">return</span> Integer.valueOf(value.toString());</div><div class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">return</span> Double.valueOf(value.toString()).intValue();</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e1) &#123;</div><div class="line">			<span class="keyword">return</span> defaultValue;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>如果长度不够，那么执行subString函数就会崩溃</strong></p>
<p>所以每次使用subString函数的时候，都要判断start和end两个参数是否越界了。</p>
<p>以上两类问题的根源，都来自MobileAPI返回的数据，由此引出另一个很严肃的问题，对于从MobileAPI返回的数据，可信度到底有多高呢？</p>
<p>首先，不能让App崩溃，应该在解析JSON数据的外面包一层try…catch…语句，将截获到的异常在catch中进行处理，例如发送错误日志给服务器。</p>
<p>其次，对数据要分级对待，例如：</p>
<p>1.对于那些不需要加工就能直接展示的数据，我们不担心，因为即使为空，页面上也就是不显示而已，不会引起逻辑的问题</p>
<p>2.对于那些很重要的数据，比如设计支付的金额不能为空的逻辑，这个时候就应该弹出提示框提示用户当前服务不可用，并停止接下里的操作</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/11/Java输入输出流/" itemprop="url">
                  Java输入输出流
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-11T14:56:05+08:00" content="2016-09-11">
              2016-09-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java-基础/" itemprop="url" rel="index">
                    <span itemprop="name">java_基础</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/11/Java输入输出流/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/11/Java输入输出流/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://blog.csdn.net/hguisu/article/details/7418161" target="_blank" rel="external">TokgoLiang——转载别人的原文链接一定要写在开头</a></p>
<h2 id="什么是IO"><a href="#什么是IO" class="headerlink" title="什么是IO"></a>什么是IO</h2><p>　　Java中I/O操作主要是指使用Java进行输入，输出操作. Java所有的I/O机制都是基于数据流进行输入输出，这些数据流表示了字符或者字节数据的流动序列。Java的I/O流提供了读写数据的标准方法。任何Java中表示数据源的对象都会提供以数据流的方式读写它的数据的方法。  </p>
<p>　　Java.io是大多数面向数据流的输入/输出类的主要软件包。此外，Java也对块传输提供支持，在核心库 java.nio中采用的便是块IO。</p>
<p>　　IO的好处是简单易用，缺点是效率较低。块IO效率很高，但编程比较复杂。 </p>
<p>　　Java IO模型：<br>　　Java的IO模型设计非常优秀，它使用Decorator模式，按功能划分Stream，您可以动态装配这些Stream，以便获得您需要的功能。例如，您需要一个具有缓冲的文件输入流，则应当组合使用FileInputStream和BufferedInputStream。 </p>
<h2 id="数据流的基本概念"><a href="#数据流的基本概念" class="headerlink" title="数据流的基本概念"></a>数据流的基本概念</h2><p>数据流是一串连续不断的数据的集合，就象水管里的水流，在水管的一端一点一点地供水，而在水管的另一端看到的是一股连续不断的水流。数据写入程序可以是一段、一段地向数据流管道中写入数据，这些数据段会按先后顺序形成一个长的数据流。对数据读取程序来说，看不到数据流在写入时的分段情况，每次可以读取其中的任意长度的数据，但只能先读取前面的数据后，再读取后面的数据。不管写入时是将数据分多次写入，还是作为一个整体一次写入，读取时的效果都是完全一样的。 </p>
<p><strong>“流是磁盘或其它外围设备中存储的数据的源点或终点。”</strong></p>
<p>　　在电脑上的数据有三种存储方式，一种是外存，一种是内存，一种是缓存。比如电脑上的硬盘，磁盘，U盘等都是外存，在电脑上有内存条，缓存是在CPU里面的。外存的存储量最大，其次是内存，最后是缓存，但是外存的数据的读取最慢，其次是内存，缓存最快。这里总结从外存读取数据到内存以及将数据从内存写到外存中。对于内存和外存的理解，我们可以简单的理解为容器，即外存是一个容器，内存又是另外一个容器。那又怎样把放在外存这个容器内的数据读取到内存这个容器以及怎么把内存这个容器里的数据存到外存中呢？</p>
<p>　　<strong>Java类库中，IO部分的内容是很庞大的，因为它涉及的领域很广泛:</strong></p>
<p>　　<strong>标准输入输出，文件的操作，网络上的数据流，字符串流，对象流，zip文件流等等，java中将输入输出抽象称为流</strong>，就好像水管，将两个容器连接起来。将数据冲外存中读取到内存中的称为输入流，将数据从内存写入外存中的称为输出流。</p>
<p>　　流是一个很形象的概念，当程序需要读取数据的时候，就会开启一个通向数据源的流，这个数据源可以是文件，内存，或是网络连接。类似的，当程序需要写入数据的时候，就会开启一个通向目的地的流。</p>
<p>　　<strong>总结的基本概念如下：</strong></p>
<h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p>　　一组有序，有起点和终点的字节的数据序列。包括输入流和输出流。</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/1355473547_6986.jpg" alt="数据流"></p>
<h4 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h4><p>　　程序从输入流读取数据源。数据源包括外界(键盘、文件、网络…)，即是将数据源读入到程序的通信通道</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/%E8%BE%93%E5%85%A5%E6%B5%81.jpg" alt="输入流"></p>
<h4 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h4><p>　　程序向输出流写入数据。将程序中的数据输出到外界（显示器、打印机、文件、网络…）的通信通道。</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/%E8%BE%93%E5%87%BA%E6%B5%81.jpg" alt="输出流"></p>
<p>　　采用数据流的目的就是使得输出输入独立于设备。</p>
<ul>
<li>Input Stream不关心数据源来自何种设备（键盘，文件，网络）</li>
<li>Output Stream不关心数据的目的是何种设备（键盘，文件，网络）</li>
</ul>
<h4 id="数据流分类"><a href="#数据流分类" class="headerlink" title="数据流分类"></a>数据流分类</h4><p>　　流序列中的数据既可以是未经加工的原始二进制数据，也可以是经一定编码处理后符合某种格式规定的特定数据。因此Java中的流分为两种：</p>
<ul>
<li>字节流：数据流中最小的数据单元是字节</li>
<li>字符流：数据流中最小的数据单元是字符， Java中的字符是Unicode编码，一个字符占用两个字节。</li>
</ul>
<h2 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h2><p>　　Java程序可通过命令行参数与外界进行简短的信息交换，同时，也规定了与标准输入、输出设备，如键盘、显示器进行信息交换的方式。而通过文件可以与外界进行任意数据形式的信息交换。</p>
<h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArgs</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;  </div><div class="line">            System.out.println(<span class="string">"args["</span> + i + <span class="string">"] is &lt;"</span> + args[i] + <span class="string">"&gt;"</span>);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>运行命令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java Java C VB</div></pre></td></tr></table></figure>
<p><strong>运行结果：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">args[0] is &lt;Java&gt;</div><div class="line">args[1] is &lt;C&gt;</div><div class="line">args[2] is &lt;VB&gt;</div></pre></td></tr></table></figure>
<h4 id="标准输入，输出数据流"><a href="#标准输入，输出数据流" class="headerlink" title="标准输入，输出数据流"></a>标准输入，输出数据流</h4><p>java系统自带的标准数据流：java.lang.System:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">java.lang.System   </div><div class="line">public final class System  extends Object&#123;   </div><div class="line">   static  PrintStream  err;//标准错误流（输出）  </div><div class="line">   static  InputStream  in;//标准输入(键盘输入流)  </div><div class="line">   static  PrintStream  out;//标准输出流(显示器输出流)  </div><div class="line">&#125; </div><div class="line">``` </div><div class="line"></div><div class="line">注意：</div><div class="line">1. System类不能创建对象，只能直接使用它的三个静态成员。</div><div class="line">1. 每当main方法被执行时,就自动生成上述三个对象。</div><div class="line"></div><div class="line">###### 标准输出流 System.out</div><div class="line"></div><div class="line">System.out向标准输出设备输出数据，其数据类型为PrintStream。方法：</div><div class="line"></div><div class="line">- Void print(参数)</div><div class="line">- Void println(参数)</div><div class="line"></div><div class="line">###### 标准输入流 System.in</div><div class="line"></div><div class="line">System.in读取标准输入设备数据（从标准输入获取数据，一般是键盘），其数 据类型为InputStream。方法：</div><div class="line"></div><div class="line">- int read()  //返回ASCII码。若,返回值=-1，说明没有读取到任何字节读取工作结束。</div><div class="line">- int read(byte[] b)//读入多个字节到缓冲区b中返回值是读入的字节数</div><div class="line"></div><div class="line">例如：</div><div class="line"></div><div class="line">``` java</div><div class="line">import java.io.*;  </div><div class="line">public class StandardInputOutput &#123;  </div><div class="line">    public static void main(String args[]) &#123;  </div><div class="line">        int b;  </div><div class="line">        try &#123;  </div><div class="line">            System.out.println("please Input:");  </div><div class="line">            while ((b = System.in.read()) != -1) &#123;  </div><div class="line">                System.out.print((char) b);  </div><div class="line">            &#125;  </div><div class="line">        &#125; catch (IOException e) &#123;  </div><div class="line">            System.out.println(e.toString());  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>等待键盘输入，键盘输入什么，就打印出什么：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">please Input:</div><div class="line">tokgoliang</div><div class="line">tokgoliang</div></pre></td></tr></table></figure>
<h6 id="标准错误流"><a href="#标准错误流" class="headerlink" title="标准错误流"></a>标准错误流</h6><p>System.err输出标准错误，其数据类型为PrintStream。可查阅API获得详细说明。</p>
<p>　　标准输出通过System.out调用println方法输出参数并换行，而print方法输出参数但不换行。println或print方法都通 过重载实现了输出基本数据类型的多个方法，包括输出参数类型为boolean、char、int、long、float和double。同时，也重载实现 了输出参数类型为char[]、String和Object的方法。其中，print（Object）和println（Object）方法在运行时将调 用参数Object的toString方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.BufferedReader;  </div><div class="line"><span class="keyword">import</span> java.io.IOException;  </div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardInputOutput</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;  </div><div class="line">        String s;  </div><div class="line">        <span class="comment">// 创建缓冲区阅读器从键盘逐行读入数据  </span></div><div class="line">        InputStreamReader ir = <span class="keyword">new</span> InputStreamReader(System.in);  </div><div class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(ir);  </div><div class="line">        System.out.println(<span class="string">"Unix系统: ctrl-d 或 ctrl-c 退出"</span>  </div><div class="line">                + <span class="string">"\nWindows系统: ctrl-z 退出"</span>);  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            <span class="comment">// 读一行数据，并标准输出至显示器  </span></div><div class="line">            s = in.readLine();  </div><div class="line">            <span class="comment">// readLine()方法运行时若发生I/O错误，将抛出IOException异常  </span></div><div class="line">            <span class="keyword">while</span> (s != <span class="keyword">null</span>) &#123;  </div><div class="line">                System.out.println(<span class="string">"Read: "</span> + s);  </div><div class="line">                s = in.readLine();  </div><div class="line">            &#125;  </div><div class="line">            <span class="comment">// 关闭缓冲阅读器  </span></div><div class="line">            in.close();  </div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123; <span class="comment">// Catch any IO exceptions.  </span></div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="java-IO层次体系结构"><a href="#java-IO层次体系结构" class="headerlink" title="java.IO层次体系结构"></a>java.IO层次体系结构</h2><p>在整个Java.io包中最重要的就是5个类和一个接口。5个类指的是File、OutputStream、InputStream、Writer、Reader；一个接口指的是Serializable.掌握了这些IO的核心操作那么对于Java中的IO体系也就有了一个初步的认识了</p>
<p>Java I/O主要包括如下几个层次，包含三个部分：</p>
<ol>
<li>流式部分――IO的主体部分；</li>
<li>非流式部分――主要包含一些辅助流式部分的类，如：File类、RandomAccessFile类和FileDescriptor等类；</li>
<li>其他类–文件读取部分的与安全相关的类，如：SerializablePermission类，以及与本地操作系统相关的文件系统的类，如：FileSystem类和Win32FileSystem类和WinNTFileSystem类。</li>
</ol>
<p><strong>主要的类如下：</strong></p>
<ol>
<li>File（文件特征与管理）：用于文件或者目录的描述信息，例如生成新目录，修改文件名，删除文件，判断文件所在路径等。</li>
<li>InputStream（二进制格式操作）：抽象类，基于字节的输入操作，是所有输入流的父类。定义了所有输入流都具有的共同特征。</li>
<li>OutputStream（二进制格式操作）：抽象类。基于字节的输出操作。是所有输出流的父类。定义了所有输出流都具有的共同特征。<br><strong>Java中字符是采用Unicode标准，一个字符是16位，即一个字符使用两个字节来表示。为此，JAVA中引入了处理字符的流。</strong></li>
<li>Reader（文件格式操作）：抽象类，基于字符的输入操作。</li>
<li>Writer（文件格式操作）：抽象类，基于字符的输出操作。</li>
<li>RandomAccessFile（随机文件操作）：它的功能丰富，可以从文件的任意位置进行存取（输入输出）操作。</li>
</ol>
<p>Java中IO流的体系结构如图：<br><img src="http://7xu1cb.com1.z0.glb.clouddn.com/Java%E4%B8%ADIO%E6%B5%81%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.jpg" alt="Java中IO流的体系结构"></p>
<h2 id="非流式文件类–File类"><a href="#非流式文件类–File类" class="headerlink" title="非流式文件类–File类"></a>非流式文件类–File类</h2><p>　　在Java语言的java.io包中，由File类提供了描述文件和目录的操作与管理方法。但File类不是InputStream、OutputStream或Reader、Writer的子类，因为它不负责数据的输入输出，而专门用来管理磁盘文件与目录。</p>
<p>作用：File类主要用于命名文件、查询文件属性和处理文件目录。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Serializable</span>,<span class="title">Comparable</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>File类共提供了三个不同的构造函数，以不同的参数形式灵活地接收文件和目录名信息。构造函数：</p>
<p><strong>1）File (String   pathname)  </strong><br>　　例:File  f1=new File(“FileTest1.txt”); //创建文件对象f1，f1所指的文件是在当前目录下创建的FileTest1.txt<br><strong>2）File (String  parent  ,  String child)</strong><br>　　例:File f2=new  File(“D:\dir1”,”FileTest2.txt”) ;//  注意：D:\dir1目录事先必须存在，否则异常<br><strong>3）File (File    parent  , String child)</strong><br>　　例:File  f4=new File(“\dir3”);<br>　　File  f5=new File(f4,”FileTest5.txt”);  //在如果 \dir3目录不存在使用f4.mkdir()先创建一个对应于某磁盘文件或目录的File对象一经创建， 就可以通过调用它的方法来获得文件或目录的属性。    </p>
<ul>
<li>public boolean exists( ) 判断文件或目录是否存在</li>
<li>public boolean isFile( ) 判断是文件还是目录 </li>
<li>public boolean isDirectory( ) 判断是文件还是目录</li>
<li>public String getName( ) 返回文件名或目录名</li>
<li>public String getPath( ) 返回文件或目录的路径。</li>
<li>public long length( ) 获取文件的长度 </li>
<li>public String[ ] list ( ) 将目录中所有文件名保存在字符串数组中返回。<br>File类中还定义了一些对文件或目录进行管理、操作的方法，常用的方法有：</li>
<li>public boolean renameTo( File newFile );    重命名文件</li>
<li>public void delete( );   删除文件</li>
<li>public boolean mkdir( ); 创建目录</li>
</ul>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.File;  </div><div class="line"><span class="keyword">import</span> java.io.IOException;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFile</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;  </div><div class="line">        File dir = <span class="keyword">new</span> File(<span class="string">"\\root"</span>);  </div><div class="line">        File f1 = <span class="keyword">new</span> File(dir, <span class="string">"fileOne.txt"</span>);  </div><div class="line">        File f2 = <span class="keyword">new</span> File(dir, <span class="string">"fileTwo.java"</span>);  </div><div class="line">        <span class="comment">// 文件对象创建后，指定的文件或目录不一定物理上存在  </span></div><div class="line">        <span class="keyword">if</span> (!dir.exists())  </div><div class="line">            dir.mkdir();  </div><div class="line">        <span class="keyword">if</span> (!f1.exists())  </div><div class="line">            f1.createNewFile();  </div><div class="line">        <span class="keyword">if</span> (!f2.exists())  </div><div class="line">            f2.createNewFile();  </div><div class="line">        System.out.println(<span class="string">"f1's AbsolutePath=  "</span> + f1.getAbsolutePath());  </div><div class="line">        System.out.println(<span class="string">"f1 Canread="</span> + f1.canRead());  </div><div class="line">        System.out.println(<span class="string">"f1's len= "</span> + f1.length());  </div><div class="line">        String[] FL;  </div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;  </div><div class="line">        FL = dir.list();  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; FL.length; i++) &#123;  </div><div class="line">            count++;  </div><div class="line">            System.out.println(FL[i] + <span class="string">"is in \\root"</span>);  </div><div class="line">        &#125;  </div><div class="line">        System.out.println(<span class="string">"there are"</span> + count + <span class="string">"file in //root"</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说明：File类的方法:</p>
<ul>
<li>exists()测试磁盘中指定的文件或目录是否存在</li>
<li>mkdir()创建文件对象指定的目录（单层目录）</li>
<li>createNewFile()创建文件对象指定的文件</li>
<li>list()返回目录中所有文件名字符串</li>
</ul>
<h2 id="Java-IO流类库"><a href="#Java-IO流类库" class="headerlink" title="Java.IO流类库"></a>Java.IO流类库</h2><h4 id="io流的四个基本类"><a href="#io流的四个基本类" class="headerlink" title="io流的四个基本类"></a>io流的四个基本类</h4><p>　　java.io包中包含了流式I/O所需要的所有类。在java.io包中有四个基本类：InputStream、OutputStream及Reader、Writer类，它们分别处理字节流和字符流：</p>
<table>
<thead>
<tr>
<th>输入/输出</th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入流</td>
<td>Inputstream</td>
<td>Reader</td>
</tr>
<tr>
<td>输出流</td>
<td>OutputStream</td>
<td>Writer</td>
</tr>
</tbody>
</table>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/IO%E6%A1%86%E6%9E%B6.jpg" alt="IO框架"></p>
<p>　　JDK1.4版本开始引入了新I/O类库，它位于java.nio包中，新I/O类库利用通道和缓冲区等来提高I/O操作的效率。</p>
<p>　　在java.io包中， java.io.InputStream 表示字节输入流， java.io.OutputStream表示字节输出流，处于java.io包最顶层。这两个类均为抽象类，也就是说它们不能被实例化，必须生成子类之后才能实现一定的功能。</p>
<h4 id="io流的具体分类"><a href="#io流的具体分类" class="headerlink" title="io流的具体分类"></a>io流的具体分类</h4><p><strong>按I/O类型来总体分类：</strong></p>
<ul>
<li><p>Memory<br>　　1）从/向内存数组读写数据: CharArrayReader、 CharArrayWriter、ByteArrayInputStream、ByteArrayOutputStream<br>　　2）从/向内存字符串读写数据 StringReader、StringWriter、StringBufferInputStream</p>
</li>
<li><p>Pipe管道  实现管道的输入和输出（进程间通信）: PipedReader、PipedWriter、PipedInputStream、PipedOutputStream</p>
</li>
<li><p>File 文件流。对文件进行读、写操作 ：FileReader、FileWriter、FileInputStream、FileOutputStream</p>
</li>
<li><p>ObjectSerialization 对象输入、输出 ：ObjectInputStream、ObjectOutputStream</p>
</li>
<li><p>DataConversion数据流 按基本数据类型读、写（处理的数据是Java的基本类型（如布尔型，字节，整数和浮点数））：DataInputStream、DataOutputStream</p>
</li>
<li><p>Printing 包含方便的打印方法 ：PrintWriter、PrintStream</p>
</li>
<li><p>Buffering缓冲  在读入或写出时，对数据进行缓存，以减少I/O的次数：BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream</p>
</li>
<li><p>Filtering 滤流，在数据进行读或写时进行过滤：FilterReader、FilterWriter、FilterInputStream、FilterOutputStream过</p>
</li>
<li><p>Concatenation合并输入 把多个输入流连接成一个输入流 ：SequenceInputStream </p>
</li>
<li><p>Counting计数  在读入数据时对行记数 ：LineNumberReader、LineNumberInputStream</p>
</li>
<li><p>Peeking Ahead 通过缓存机制，进行预读 ：PushbackReader、PushbackInputStream</p>
</li>
<li><p>Converting between Bytes and Characters 按照一定的编码/解码标准将字节流转换为字符流，或进行反向转换（Stream到Reader,Writer的转换类）：InputStreamReader、OutputStreamWriter</p>
</li>
</ul>
<p><strong>按数据来源（去向）分类：</strong></p>
<ul>
<li>File（文件）： FileInputStream, FileOutputStream, FileReader, FileWriter </li>
<li>byte[]：ByteArrayInputStream, ByteArrayOutputStream </li>
<li>Char[]: CharArrayReader, CharArrayWriter </li>
<li>String: StringBufferInputStream, StringReader, StringWriter </li>
<li>网络数据流：InputStream, OutputStream, Reader, Writer </li>
</ul>
<h2 id="字节流InputStream-OutputStream"><a href="#字节流InputStream-OutputStream" class="headerlink" title="字节流InputStream/OutputStream"></a>字节流InputStream/OutputStream</h2><h4 id="InputStream抽象类"><a href="#InputStream抽象类" class="headerlink" title="InputStream抽象类"></a>InputStream抽象类</h4><p>　　InputStream 为字节输入流，它本身为一个抽象类，必须依靠其子类实现各种功能，此抽象类是表示字节输入流的所有类的超类。 继承自InputStream  的流都是向程序中输入数据的，且数据单位为字节（8bit）；</p>
<p>　　InputStream是输入字节数据用的类，所以InputStream类提供了3种重载的read方法.Inputstream类中的常用方法： </p>
<ul>
<li>public abstract int read( )：读取一个byte的数据，返回值是高位补0的int类型值。若返回值=-1说明没有读取到任何字节读取工作结束。</li>
<li>public int read(byte b[ ])：读取b.length个字节的数据放到b数组中。返回值是读取的字节数。该方法实际上是调用下一个方法实现的 </li>
<li>public int read(byte b[ ], int off, int len)：从输入流中最多读取len个字节的数据，存放到偏移量为off的b数组中。 </li>
<li>public int available( )：返回输入流中可以读取的字节数。注意：若输入阻塞，当前线程将被挂起，如果InputStream对象调用这个方法的话，它只会返回0，这个方法必须由继承InputStream类的子类对象调用才有用， </li>
<li>public long skip(long n)：忽略输入流中的n个字节，返回值是实际忽略的字节数, 跳过一些字节来读取 </li>
<li>public int close( ) ：我们在使用完后，必须对我们打开的流进行关闭. </li>
</ul>
<p><strong>主要的子类：</strong></p>
<ul>
<li>FileInputStream把一个文件作为InputStream，实现对文件的读取操作     </li>
<li>ByteArrayInputStream：把内存中的一个缓冲区作为InputStream使用 </li>
<li>StringBufferInputStream：把一个String对象作为InputStream </li>
<li>PipedInputStream：实现了pipe的概念，主要在线程中使用 </li>
<li>SequenceInputStream：把多个InputStream合并为一个InputStream </li>
</ul>
<h4 id="OutputStream抽象类"><a href="#OutputStream抽象类" class="headerlink" title="OutputStream抽象类"></a>OutputStream抽象类</h4><p>　　OutputStream提供了3个write方法来做数据的输出，这个是和InputStream是相对应的。 </p>
<ul>
<li>public void write(byte b[ ])：将参数b中的字节写到输出流。 </li>
<li>public void write(byte b[ ], int off, int len) ：将参数b的从偏移量off开始的len个字节写到输出流。 </li>
<li>public abstract void write(int b) ：先将int转换为byte类型，把低字节写入到输出流中。 </li>
<li>public void flush( ) : 将数据缓冲区中数据全部输出，并清空缓冲区。 </li>
<li>public void close( ) : 关闭输出流并释放与流相关的系统资源。 </li>
</ul>
<p>主要的子类：</p>
<p>ByteArrayOutputStream：把信息存入内存中的一个缓冲区中<br>FileOutputStream：把信息存入文件中<br>PipedOutputStream：实现了pipe的概念，主要在线程中使用<br>SequenceOutputStream：把多个OutStream合并为一个OutStream </p>
<p>流结束的判断：方法read()的返回值为-1时；readLine()的返回值为null时。</p>
<h4 id="文件输入流：-FileInputStream类"><a href="#文件输入流：-FileInputStream类" class="headerlink" title="文件输入流： FileInputStream类"></a>文件输入流： FileInputStream类</h4><p>　　FileInputStream可以使用read()方法一次读入一个字节，并以int类型返回，或者是使用read()方法时读入至一个byte数组，byte数组的元素有多少个，就读入多少个字节。在将整个文件读取完成或写入完毕的过程中，这么一个byte数组通常被当作缓冲区，因为这么一个byte数组通常扮演承接数据的中间角色。</p>
<p>作用：以文件作为数据输入源的数据流。或者说是打开文件，从文件读数据到内存的类。<br>使用方法(1)<br>File  fin=new File(“d:/abc.txt”);<br>FileInputStream in=new FileInputStream( fin);<br>使用方法(2)<br>FileInputStream  in=new  FileInputStream(“d: /abc.txt”);</p>
<p>程序举例：将InputFromFile.java的程序的内容显示在显示器上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.IOException;  </div><div class="line"><span class="keyword">import</span> java.io.FileInputStream;  </div><div class="line">;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFile</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;  </div><div class="line">        <span class="keyword">try</span>&#123;      </div><div class="line">               FileInputStream rf=<span class="keyword">new</span>   FileInputStream(<span class="string">"InputFromFile.java"</span>);  </div><div class="line">               <span class="keyword">int</span> n=<span class="number">512</span>;   <span class="keyword">byte</span>  buffer[]=<span class="keyword">new</span>  <span class="keyword">byte</span>[n];     </div><div class="line">               <span class="keyword">while</span>((rf.read(buffer,<span class="number">0</span>,n)!=-<span class="number">1</span>)&amp;&amp;(n&gt;<span class="number">0</span>))&#123;  </div><div class="line">                   System.out.println(<span class="keyword">new</span> String(buffer) );  </div><div class="line">                &#125;  </div><div class="line">                System.out.println();  </div><div class="line">                rf.close();  </div><div class="line">        &#125; <span class="keyword">catch</span>(IOException  IOe)&#123;        </div><div class="line">              System.out.println(IOe.toString());  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="文件输出流-FileOutputStream类"><a href="#文件输出流-FileOutputStream类" class="headerlink" title="文件输出流:FileOutputStream类"></a>文件输出流:FileOutputStream类</h4><p>作用：用来处理以文件作为数据输出目的数据流；或者说是从内存区读数据入文件</p>
<p>FileOutputStream类用来处理以文件作为数据输出目的数据流；一个表示文件名的字符串，也可以是File或FileDescriptor对象。 </p>
<p>创建一个文件流对象有两种方法：<br>方式1：<br>File   f=new  File (“d:/myjava/write.txt “);<br>FileOutputStream  out= new FileOutputStream (f);<br>　　<br>方式2：<br>FileOutputStream out=new FileOutputStream(“d:/myjava/write.txt “);<br>　　<br>方式3：构造函数将 FileDescriptor()对象作为其参数。<br>FileDescriptor() fd=new FileDescriptor();<br>FileOutputStream f2=new FileOutputStream(fd);<br>　　<br>方式4：构造函数将文件名作为其第一参数，将布尔值作为第二参数。<br>FileOutputStream f=new FileOutputStream(“d:/abc.txt”,true); </p>
<p><strong>注意： （1）文件中写数据时，若文件已经存在，则覆盖存在的文件；（2）的读/写操作结束时，应调用close方法关闭流。</strong> </p>
<p>程序举例：使用键盘输入一段文章，将文章保存在文件write.txt中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.IOException;  </div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFile</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            System.out.println(<span class="string">"please Input from      Keyboard"</span>);  </div><div class="line">            <span class="keyword">int</span> count, n = <span class="number">512</span>;  </div><div class="line">            <span class="keyword">byte</span> buffer[] = <span class="keyword">new</span> <span class="keyword">byte</span>[n];  </div><div class="line">            count = System.in.read(buffer);  </div><div class="line">            FileOutputStream wf = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:/myjava/write.txt"</span>);  </div><div class="line">            wf.write(buffer, <span class="number">0</span>, count);  </div><div class="line">            wf.close(); <span class="comment">// 当流写操作结束时，调用close方法关闭流。  </span></div><div class="line">            System.out.println(<span class="string">"Save to the write.txt"</span>);  </div><div class="line">        &#125; <span class="keyword">catch</span> (IOException IOe) &#123;  </div><div class="line">            System.out.println(<span class="string">"File Write Error!"</span>);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="FileInputStream流和FileOutputStream的应用"><a href="#FileInputStream流和FileOutputStream的应用" class="headerlink" title="FileInputStream流和FileOutputStream的应用"></a>FileInputStream流和FileOutputStream的应用</h4><p>利用程序将文件file1.txt 拷贝到file2.txt中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.File;  </div><div class="line"><span class="keyword">import</span> java.io.IOException;  </div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;  </div><div class="line"><span class="keyword">import</span> java.io.FileInputStream;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFile</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            File inFile = <span class="keyword">new</span> File(<span class="string">"copy.java"</span>);  </div><div class="line">            File outFile = <span class="keyword">new</span> File(<span class="string">"copy2.java"</span>);  </div><div class="line">            FileInputStream finS = <span class="keyword">new</span> FileInputStream(inFile);  </div><div class="line">            FileOutputStream foutS = <span class="keyword">new</span> FileOutputStream(outFile);  </div><div class="line">            <span class="keyword">int</span> c;  </div><div class="line">            <span class="keyword">while</span> ((c = finS.read()) != -<span class="number">1</span>) &#123;  </div><div class="line">                foutS.write(c);  </div><div class="line">            &#125;  </div><div class="line">            finS.close();  </div><div class="line">            foutS.close();  </div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </div><div class="line">            System.err.println(<span class="string">"FileStreamsTest: "</span> + e);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="缓冲输入输出流-BufferedInputStream-BufferedOutputStream"><a href="#缓冲输入输出流-BufferedInputStream-BufferedOutputStream" class="headerlink" title="缓冲输入输出流 BufferedInputStream/ BufferedOutputStream"></a>缓冲输入输出流 BufferedInputStream/ BufferedOutputStream</h4><p>　　计算机访问外部设备非常耗时。访问外存的频率越高，造成CPU闲置的概率就越大。为了减少访问外存的次数，应该在一次对外设的访问中，读写更多的数据。为此，除了程序和流节点间交换数据必需的读写机制外，还应该增加缓冲机制。缓冲流就是每一个数据流分配一个缓冲区，一个缓冲区就是一个临时存储数据的内存。这样可以减少访问硬盘的次数,提高传输效率。</p>
<p>　　BufferedInputStream:当向缓冲流写入数据时候，数据先写到缓冲区，待缓冲区写满后，系统一次性将数据发送给输出设备。</p>
<p>　　BufferedOutputStream :当从向缓冲流读取数据时候，系统先从缓冲区读出数据，待缓冲区为空时，系统再从输入设备读取数据到缓冲区。</p>
<p>1）将文件读入内存：<br>将BufferedInputStream与FileInputStream相接<br>FileInputStream in=new  FileInputStream( “file1.txt ” );<br>BufferedInputStream bin=new  BufferedInputStream( in); </p>
<p>2）将内存写入文件：<br>将BufferedOutputStream与 FileOutputStream相接<br>FileOutputStreamout=new FileOutputStream(“file1.txt”);<br>BufferedOutputStream  bin=new BufferedInputStream(out);</p>
<p>3）键盘输入流读到内存<br>将BufferedReader与标准的数据流相接<br>InputStreamReader sin=new InputStreamReader (System.in) ；<br>BufferedReader bin=new             BufferedReader(sin);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteToFile</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;  </div><div class="line">        InputStreamReader sin = <span class="keyword">new</span> InputStreamReader(System.in);  </div><div class="line">        BufferedReader bin = <span class="keyword">new</span> BufferedReader(sin);  </div><div class="line">        FileWriter out = <span class="keyword">new</span> FileWriter(<span class="string">"myfile.txt"</span>);  </div><div class="line">        BufferedWriter bout = <span class="keyword">new</span> BufferedWriter(out);  </div><div class="line">        String s;  </div><div class="line">        <span class="keyword">while</span> ((s = bin.readLine()).length() &gt; <span class="number">0</span>) &#123;  </div><div class="line">            bout.write(s, <span class="number">0</span>, s.length());  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序说明：<br>从键盘读入字符，并写入到文件中BufferedReader类的方法：String readLine()<br>作用：读一行字符串，以回车符为结束。<br>BufferedWriter类的方法：bout.write(String s,offset,len)<br>作用：从缓冲区将字符串s从offset开始，len长度的字符串写到某处。</p>
<h2 id="字符流Writer-Reader"><a href="#字符流Writer-Reader" class="headerlink" title="字符流Writer/Reader"></a>字符流Writer/Reader</h2><p>　　Java中字符是采用Unicode标准，一个字符是16位，即一个字符使用两个字节来表示。为此，JAVA中引入了处理字符的流。</p>
<h4 id="Reader抽象类"><a href="#Reader抽象类" class="headerlink" title="Reader抽象类"></a>Reader抽象类</h4><p>　　用于读取字符流的抽象类。子类必须实现的方法只有 read(char[], int, int) 和 close()。但是，多数子类将重写此处定义的一些方法，以提供更高的效率和/或其他功能。</p>
<p>1) FileReader :与FileInputStream对应<br>主要用来读取字符文件，使用缺省的字符编码，有三种构造函数：<br>(1）将文件名作为字符串 ：FileReader f=new FileReader(“c:/temp.txt”);<br>(2）构造函数将File对象作为其参数。<br>File f=new file(“c:/temp.txt”);<br>FileReader f1=new FileReader(f);<br>(3) 构造函数将FileDescriptor对象作为参数<br>FileDescriptor() fd=new FileDescriptor()<br>FileReader f2=new FileReader(fd);<br>(1) 用指定字符数组作为参数：CharArrayReader(char[])<br>(2) 将字符数组作为输入流:CharArrayReader(char[], int, int)<br>读取字符串，构造函数如下： public StringReader(String s);<br>2) CharArrayReader：与ByteArrayInputStream对应<br>3) StringReader : 与StringBufferInputStream对应<br>4) InputStreamReader<br>从输入流读取字节，在将它们转换成字符:Public inputstreamReader(inputstream is);<br>5) FilterReader: 允许过滤字符流<br>protected filterReader(Reader r);<br>6) BufferReader :接受Reader对象作为参数，并对其添加字符缓冲器，使用readline()方法可以读取一行。<br>Public BufferReader(Reader r); </p>
<p>主要方法：</p>
<ul>
<li>public int read() throws IOException; //读取一个字符，返回值为读取的字符 </li>
<li>public int read(char cbuf[]) throws IOException; /<em>读取一系列字符到数组cbuf[]中，返回值为实际读取的字符的数量</em>/ </li>
<li>public abstract int read(char cbuf[],int off,int len) throws IOException; /<em>读取len个字符，从数组cbuf[]的下标off处开始存放，返回值为实际读取的字符数量，该方法必须由子类实现</em>/ </li>
</ul>
<h4 id="Writer抽象类"><a href="#Writer抽象类" class="headerlink" title="Writer抽象类"></a>Writer抽象类</h4><p>　　写入字符流的抽象类。子类必须实现的方法仅有 write(char[], int, int)、flush() 和 close()。但是，多数子类将重写此处定义的一些方法，以提供更高的效率和/或其他功能。 其子类如下：</p>
<p>1） FileWrite: 与FileOutputStream对应<br>　　将字符类型数据写入文件，使用缺省字符编码和缓冲器大小。<br>　　Public FileWrite(file f);<br>2)  chararrayWrite:与ByteArrayOutputStream对应 ,将字符缓冲器用作输出。<br>　　    Public CharArrayWrite();<br>3) PrintWrite:生成格式化输出<br>　　    public PrintWriter(outputstream os);<br>4) filterWriter:用于写入过滤字符流<br>　　    protected FilterWriter(Writer w);<br>5) PipedWriter：与PipedOutputStream对应<br>6) StringWriter：无与之对应的以字节为导向的stream  </p>
<p>主要方法：</p>
<ul>
<li>public void write(int c) throws IOException； //将整型值c的低16位写入输出流 </li>
<li>public void write(char cbuf[]) throws IOException； //将字符数组cbuf[]写入输出流 </li>
<li>public abstract void write(char cbuf[],int off,int len) throws IOException； //将字符数组cbuf[]中的从索引为off的位置处开始的len个字符写入输出流 </li>
<li>public void write(String str) throws IOException； //将字符串str中的字符写入输出流 </li>
<li>public void write(String str,int off,int len) throws IOException； //将字符串str 中从索引off开始处的len个字符写入输出流 </li>
<li>flush( ) //刷空输出流，并输出所有被缓存的字节。 </li>
<li>close()   关闭流 public abstract void close() throws IOException</li>
</ul>
<h4 id="InputStream与Reader差别-OutputStream与Writer差别"><a href="#InputStream与Reader差别-OutputStream与Writer差别" class="headerlink" title="InputStream与Reader差别 OutputStream与Writer差别"></a>InputStream与Reader差别 OutputStream与Writer差别</h4><p>　　InputStream和OutputStream类处理的是字节流，数据流中的最小单位是字节(8个bit)<br>Reader与Writer处理的是字符流，在处理字符流时涉及了字符编码的转换问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncodeTest</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readBuff</span><span class="params">(<span class="keyword">byte</span> [] buff)</span> <span class="keyword">throws</span> IOException </span>&#123;  </div><div class="line">       ByteArrayInputStream in =<span class="keyword">new</span> ByteArrayInputStream(buff);  </div><div class="line">        <span class="keyword">int</span> data;  </div><div class="line">        <span class="keyword">while</span>((data=in.read())!=-<span class="number">1</span>)   System.out.print(data+<span class="string">"  "</span>);  </div><div class="line">        System.out.println();     in.close();     &#125;  </div><div class="line">  </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;  </div><div class="line">       System.out.println(<span class="string">"内存中采用unicode字符编码："</span> );  </div><div class="line">       <span class="keyword">char</span>   c=<span class="string">'好'</span>;  </div><div class="line">       <span class="keyword">int</span> lowBit=c&amp;<span class="number">0xFF</span>;     <span class="keyword">int</span> highBit=(c&amp;<span class="number">0xFF00</span>)&gt;&gt;<span class="number">8</span>;  </div><div class="line">       System.out.println(<span class="string">""</span>+lowBit+<span class="string">"   "</span>+highBit);  </div><div class="line">       String s=<span class="string">"好"</span>;  </div><div class="line">       System.out.println(<span class="string">"本地操作系统默认字符编码："</span>);  </div><div class="line">       readBuff(s.getBytes());  </div><div class="line">       System.out.println(<span class="string">"采用GBK字符编码："</span>);  </div><div class="line">       readBuff(s.getBytes(<span class="string">"GBK"</span>));  </div><div class="line">       System.out.println(<span class="string">"采用UTF-8字符编码："</span>);        </div><div class="line">       readBuff(s.getBytes(<span class="string">"UTF-8"</span>));      &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Reader类能够将输入流中采用其他编码类型的字符转换为Unicode字符，然后在内存中为其分配内存<br>Writer类能够将内存中的Unicode字符转换为其他编码类型的字符，再写到输出流中。</p>
<h2 id="IOException异常类的子类"><a href="#IOException异常类的子类" class="headerlink" title="IOException异常类的子类"></a>IOException异常类的子类</h2><ul>
<li>public class EOFException：非正常到达文件尾或输入流尾时，抛出这种类型的异常。</li>
<li>public class FileNotFoundException：当文件找不到时，抛出的异常。</li>
<li>public class InterruptedIOException：当I/O操作被中断时，抛出这种类型的异常。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/11/Java基础 之软引用、弱引用、虚引用/" itemprop="url">
                  Java基础 之软引用、弱引用、虚引用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-11T14:56:05+08:00" content="2016-09-11">
              2016-09-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java-基础/" itemprop="url" rel="index">
                    <span itemprop="name">java_基础</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/11/Java基础 之软引用、弱引用、虚引用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/11/Java基础 之软引用、弱引用、虚引用/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.cnblogs.com/blogoflee/archive/2012/03/22/2411124.html" target="_blank" rel="external">TokgoLiang——转载别人的原文链接一定要写在开头</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>　　在JDK1.2以前的版本中，当一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可触及状态，程序才能使用它。这就像在日常生活中，从商店购买了某样物品后，如果有用，就一直保留它，否则就把它扔到垃圾箱，由清洁工人收走。一般说来，如果物品已经被扔到垃圾箱，想再 把它捡回来使用就不可能了。<br>　　但有时候情况并不这么简单，你可能会遇到类似鸡肋一样的物品，食之无味，弃之可惜。这种物品现在已经无用了，保留它会占空间，但是立刻扔掉它也不划算，因 为也许将来还会派用场。对于这样的可有可无的物品，一种折衷的处理办法是：如果家里空间足够，就先把它保留在家里，如果家里空间不够，即使把家里所有的垃 圾清除，还是无法容纳那些必不可少的生活用品，那么再扔掉这些可有可无的物品。<br>　　从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p>
<h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>　　平时我们编程的时候例如：Object object=new Object（）；那object就是一个强引用了。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<h2 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h2><p>　　如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只 要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 软引用可以和一个引用队列（ReferenceQueue）联 合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<h2 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h2><p>　　如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。  弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回 收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 </p>
<h2 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h2><p>　　“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在 任何时候都可能被垃圾回收。 虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队 列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 </p>
<h2 id="相关应用"><a href="#相关应用" class="headerlink" title="相关应用"></a>相关应用</h2><p>　　在java.lang.ref包中提供了三个类：SoftReference类、WeakReference类和PhantomReference类，它 们分别代表软引用、弱引用和虚引用。ReferenceQueue类表示引用队列，它可以和这三种引用类联合使用，以便跟踪Java虚拟机回收所引用的对 象的活动。</p>
<h2 id="使用软引用构建敏感数据的缓存"><a href="#使用软引用构建敏感数据的缓存" class="headerlink" title="使用软引用构建敏感数据的缓存"></a>使用软引用构建敏感数据的缓存</h2><h4 id="为什么需要使用软引用"><a href="#为什么需要使用软引用" class="headerlink" title="为什么需要使用软引用"></a>为什么需要使用软引用</h4><p>　　首先，我们看一个雇员信息查询系统的实例。我们将使用一个Java语言实现的雇员信息查询系统查询存储在磁盘文件或者数据库中的雇员人事档案信息。作为一 个用户，我们完全有可能需要回头去查看几分钟甚至几秒钟前查看过的雇员档案信息(同样，我们在浏览WEB页面的时候也经常会使用“后退”按钮)。这时我们 通常会有两种程序实现方式:一种是把过去查看过的雇员信息保存在内存中，每一个存储了雇员档案信息的Java对象的生命周期贯穿整个应用程序始终;另一种 是当用户开始查看其他雇员的档案信息的时候，把存储了当前所查看的雇员档案信息的Java对象结束引用，使得垃圾收集线程可以回收其所占用的内存空间，当 用户再次需要浏览该雇员的档案信息的时候，重新构建该雇员的信息。很显然，第一种实现方法将造成大量的内存浪费，而第二种实现的缺陷在于即使垃圾收集线程 还没有进行垃圾收集，包含雇员档案信息的对象仍然完好地保存在内存中，应用程序也要重新构建一个对象。我们知道，访问磁盘文件、访问网络资源、查询数据库 等操作都是影响应用程序执行性能的重要因素，如果能重新获取那些尚未被回收的Java对象的引用，必将减少不必要的访问，大大提高程序的运行速度。</p>
<h4 id="如果使用软引用"><a href="#如果使用软引用" class="headerlink" title="如果使用软引用"></a>如果使用软引用</h4><p>　　SoftReference的特点是它的一个实例保存对一个Java对象的软引用，该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。也就是说， 一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对这个Java对象回收前，SoftReference类所提供的 get()方法返回Java对象的强引用。另外，一旦垃圾线程回收该Java对象之后，get()方法将返回null。</p>
<h4 id="使用ReferenceQueue清除失去了软引用对象的SoftReference"><a href="#使用ReferenceQueue清除失去了软引用对象的SoftReference" class="headerlink" title="使用ReferenceQueue清除失去了软引用对象的SoftReference"></a>使用ReferenceQueue清除失去了软引用对象的SoftReference</h4><p>　　作为一个Java对象，SoftReference对象除了具有保存软引用的特殊性之外，也具有Java对象的一般性。所以，当软可及对象被回收之后， 虽然这个SoftReference对象的get()方法返回null,但这个SoftReference对象已经不再具有存在的价值，需要一个适当的清 除机制，避免大量SoftReference对象带来的内存泄漏。在java.lang.ref包里还提供了ReferenceQueue。如果在创建 SoftReference对象的时候，使用了一个ReferenceQueue对象作为参数提供给SoftReference的构造方法，如:</p>
<p>　　那么当这个SoftReference所软引用的aMyOhject被垃圾收集器回收的同时，ref所强引用的SoftReference对象被列入 ReferenceQueue。也就是说，ReferenceQueue中保存的对象是Reference对象，而且是已经失去了它所软引用的对象的 Reference对象。另外从ReferenceQueue这个名字也可以看出，它是一个队列，当我们调用它的poll()方法的时候，如果这个队列中 不是空队列，那么将返回队列前面的那个Reference对象。<br>　　<br>　　在任何时候，我们都可以调用ReferenceQueue的poll()方法来检查是否有它所关心的非强可及对象被回收。如果队列为空，将返回一个 null,否则该方法返回队列中前面的一个Reference对象。利用这个方法，我们可以检查哪个SoftReference所软引用的对象已经被回 收。于是我们可以把这些失去所软引用的对象的SoftReference对象清除掉。常用的方式为:</p>
<p>　　理解了ReferenceQueue的工作机制之后，我们就可以开始构造一个Java对象的高速缓存器了。</p>
<h4 id="通过软可及对象重获方法实现Java对象的高速缓存"><a href="#通过软可及对象重获方法实现Java对象的高速缓存" class="headerlink" title="通过软可及对象重获方法实现Java对象的高速缓存"></a>通过软可及对象重获方法实现Java对象的高速缓存</h4><p>　　利用Java2平台垃圾收集机制的特性以及前述的垃圾对象重获方法，我们通过一个雇员信息查询系统的小例子来说明如何构建一种高速缓存器来避免重复构建同一个对象带来的性能损失。我们将一个雇员的档案信息定义为一个Employee类:<br>　　<br>　　这个Employee类的构造方法中我们可以预见，如果每次需要查询一个雇员的信息。哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这是需要消耗很多时间的。下面是一个对Employee对象进行缓存的缓存器的定义:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;      </div><div class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;      </div><div class="line"><span class="keyword">import</span> java.util.Hashtable;      </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeCache</span> </span>&#123;      </div><div class="line">    <span class="keyword">static</span> <span class="keyword">private</span> EmployeeCache cache;<span class="comment">// 一个Cache实例      </span></div><div class="line">    <span class="keyword">private</span> Hashtable employeeRefs;<span class="comment">// 用于Cache内容的存储      </span></div><div class="line">    <span class="keyword">private</span> ReferenceQueue q;<span class="comment">// 垃圾Reference的队列      </span></div><div class="line">       </div><div class="line">    <span class="comment">// 继承SoftReference，使得每一个实例都具有可识别的标识。      </span></div><div class="line">    <span class="comment">// 并且该标识与其在HashMap内的key相同。      </span></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeRef</span> <span class="keyword">extends</span> <span class="title">SoftReference</span> </span>&#123;      </div><div class="line">       <span class="keyword">private</span> String _key = <span class="string">""</span>;      </div><div class="line">       </div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="title">EmployeeRef</span><span class="params">(Employee em, ReferenceQueue q)</span> </span>&#123;      </div><div class="line">           <span class="keyword">super</span>(em, q);      </div><div class="line">           _key = em.getID();      </div><div class="line">       &#125;      </div><div class="line">    &#125;      </div><div class="line">       </div><div class="line">    <span class="comment">// 构建一个缓存器实例      </span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EmployeeCache</span><span class="params">()</span> </span>&#123;      </div><div class="line">       employeeRefs = <span class="keyword">new</span> Hashtable();      </div><div class="line">       q = <span class="keyword">new</span> ReferenceQueue();      </div><div class="line">    &#125;      </div><div class="line">       </div><div class="line">    <span class="comment">// 取得缓存器实例      </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EmployeeCache <span class="title">getInstance</span><span class="params">()</span> </span>&#123;      </div><div class="line">       <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;      </div><div class="line">           cache = <span class="keyword">new</span> EmployeeCache();      </div><div class="line">       &#125;      </div><div class="line">       <span class="keyword">return</span> cache;      </div><div class="line">    &#125;      </div><div class="line">       </div><div class="line">    <span class="comment">// 以软引用的方式对一个Employee对象的实例进行引用并保存该引用      </span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheEmployee</span><span class="params">(Employee em)</span> </span>&#123;      </div><div class="line">       cleanCache();<span class="comment">// 清除垃圾引用      </span></div><div class="line">       EmployeeRef ref = <span class="keyword">new</span> EmployeeRef(em, q);      </div><div class="line">       employeeRefs.put(em.getID(), ref);      </div><div class="line">    &#125;      </div><div class="line">       </div><div class="line">    <span class="comment">// 依据所指定的ID号，重新获取相应Employee对象的实例      </span></div><div class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">getEmployee</span><span class="params">(String ID)</span> </span>&#123;      </div><div class="line">       Employee em = <span class="keyword">null</span>;      </div><div class="line">       <span class="comment">// 缓存中是否有该Employee实例的软引用，如果有，从软引用中取得。      </span></div><div class="line">       <span class="keyword">if</span> (employeeRefs.containsKey(ID)) &#123;      </div><div class="line">           EmployeeRef ref = (EmployeeRef) employeeRefs.get(ID);      </div><div class="line">           em = (Employee) ref.get();      </div><div class="line">       &#125;      </div><div class="line">       <span class="comment">// 如果没有软引用，或者从软引用中得到的实例是null，重新构建一个实例，      </span></div><div class="line">       <span class="comment">// 并保存对这个新建实例的软引用      </span></div><div class="line">       <span class="keyword">if</span> (em == <span class="keyword">null</span>) &#123;      </div><div class="line">           em = <span class="keyword">new</span> Employee(ID);      </div><div class="line">           System.out.println(<span class="string">"Retrieve From EmployeeInfoCenter. ID="</span> + ID);      </div><div class="line">           <span class="keyword">this</span>.cacheEmployee(em);      </div><div class="line">       &#125;      </div><div class="line">       <span class="keyword">return</span> em;      </div><div class="line">    &#125;      </div><div class="line">       </div><div class="line">    <span class="comment">// 清除那些所软引用的Employee对象已经被回收的EmployeeRef对象      </span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanCache</span><span class="params">()</span> </span>&#123;      </div><div class="line">       EmployeeRef ref = <span class="keyword">null</span>;      </div><div class="line">       <span class="keyword">while</span> ((ref = (EmployeeRef) q.poll()) != <span class="keyword">null</span>) &#123;      </div><div class="line">           employeeRefs.remove(ref._key);      </div><div class="line">       &#125;      </div><div class="line">    &#125;      </div><div class="line">       </div><div class="line">    <span class="comment">// 清除Cache内的全部内容      </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span> </span>&#123;      </div><div class="line">       cleanCache();      </div><div class="line">       employeeRefs.clear();      </div><div class="line">       System.gc();      </div><div class="line">       System.runFinalization();      </div><div class="line">    &#125;      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="使用弱引用构建非敏感数据的缓存"><a href="#使用弱引用构建非敏感数据的缓存" class="headerlink" title="使用弱引用构建非敏感数据的缓存"></a>使用弱引用构建非敏感数据的缓存</h2><h5 id="全局ap造成的内存泄漏"><a href="#全局ap造成的内存泄漏" class="headerlink" title="全局ap造成的内存泄漏"></a>全局ap造成的内存泄漏</h5><p>　　无意识对象保留最常见的原因是使用Map将元数据与临时对象（transient object）相关联。假定一个对象具有中等生命周期，比分配它的那个方法调用的生命周期长，但是比应用程序的生命周期短，如客户机的套接字连接。需要将 一些元数据与这个套接字关联，如生成连接的用户的标识。在创建Socket时是不知道这些信息的，并且不能将数据添加到Socket对象上，因为不能控制 Socket 类或者它的子类。这时，典型的方法就是在一个全局 Map 中存储这些信息，如下面的 SocketManager 类所示：使用一个全局 Map 将元数据关联到一个对象。</p>
<p>　　这种方法的问题是元数据的生命周期需要与套接字的生命周期挂钩，但是除非准确地知道什么时候程序不再需要这个套接字，并记住从 Map 中删除相应的映射，否则，Socket 和 User 对象将会永远留在 Map 中，远远超过响应了请求和关闭套接字的时间。这会阻止 Socket 和 User 对象被垃圾收集，即使应用程序不会再使用它们。这些对象留下来不受控制，很容易造成程序在长时间运行后内存爆满。除了最简单的情况，在几乎所有情况下找出 什么时候 Socket 不再被程序使用是一件很烦人和容易出错的任务，需要人工对内存进行管理。</p>
<h4 id="如何使用WeakHashMap"><a href="#如何使用WeakHashMap" class="headerlink" title="如何使用WeakHashMap"></a>如何使用WeakHashMap</h4><p>　　在Java集合中有一种特殊的Map类型—WeakHashMap，在这种Map中存放了键对象的弱引用，当一个键对象被垃圾回收器回收时，那么相应的值 对象的引用会从Map中删除。WeakHashMap能够节约存储空间，可用来缓存那些非必须存在的数据。关于Map接口的一般用法。</p>
<p>　　下面示例中MapCache类的main()方法创建了一个WeakHashMap对象，它存放了一组Key对象的弱引用，此外main()方法还创建了一个数组对象，它存放了部分Key对象的强引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.WeakHashMap;      </div><div class="line">       </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;      </div><div class="line">    <span class="keyword">private</span> String ident;      </div><div class="line">       </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Element</span><span class="params">(String id)</span> </span>&#123;      </div><div class="line">       ident = id;      </div><div class="line">    &#125;      </div><div class="line">       </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;      </div><div class="line">       <span class="keyword">return</span> ident;      </div><div class="line">    &#125;      </div><div class="line">       </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;      </div><div class="line">       <span class="keyword">return</span> ident.hashCode();      </div><div class="line">    &#125;      </div><div class="line">       </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;      </div><div class="line">       <span class="keyword">return</span> obj <span class="keyword">instanceof</span> Element &amp;&amp; ident.equals(((Element) obj).ident);      </div><div class="line">    &#125;      </div><div class="line">          </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span>&#123;      </div><div class="line">       System.out.println(<span class="string">"Finalizing "</span>+getClass().getSimpleName()+<span class="string">" "</span>+ident);      </div><div class="line">    &#125;      </div><div class="line">&#125;      </div><div class="line">       </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Element</span></span>&#123;      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Key</span><span class="params">(String id)</span></span>&#123;      </div><div class="line">       <span class="keyword">super</span>(id);      </div><div class="line">    &#125;      </div><div class="line">&#125;      </div><div class="line">       </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span> <span class="keyword">extends</span> <span class="title">Element</span></span>&#123;      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Value</span> <span class="params">(String id)</span></span>&#123;      </div><div class="line">       <span class="keyword">super</span>(id);      </div><div class="line">    &#125;      </div><div class="line">&#125;      </div><div class="line">       </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanonicalMapping</span> </span>&#123;      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;      </div><div class="line">       <span class="keyword">int</span> size=<span class="number">1000</span>;      </div><div class="line">       Key[] keys=<span class="keyword">new</span> Key[size];      </div><div class="line">       WeakHashMap map=<span class="keyword">new</span> WeakHashMap();      </div><div class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; SPAN&gt;    </div><div class="line">           Key k=<span class="keyword">new</span> Key(Integer.toString(i));      </div><div class="line">           Value v=<span class="keyword">new</span> Value(Integer.toString(i));      </div><div class="line">           <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>)      </div><div class="line">              keys[i]=k;      </div><div class="line">           map.put(k, v);      </div><div class="line">       &#125;      </div><div class="line">       System.gc();      </div><div class="line">    &#125;      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　从打印结果可以看出，当执行System.gc()方法后，垃圾回收器只会回收那些仅仅持有弱引用的Key对象。id可以被3整除的Key对象持有强引用，因此不会被回收。</p>
<h4 id="用-WeakHashMap-堵住泄漏"><a href="#用-WeakHashMap-堵住泄漏" class="headerlink" title="用 WeakHashMap 堵住泄漏"></a>用 WeakHashMap 堵住泄漏</h4><p>　　在 SocketManager 中防止泄漏很容易，只要用 WeakHashMap 代替 HashMap 就行了。（这里假定SocketManager不需要线程安全）。当映射的生命周期必须与键的生命周期联系在一起时，可以使用这种方法。用 WeakHashMap修复 SocketManager。</p>
<h4 id="配合使用引用队列"><a href="#配合使用引用队列" class="headerlink" title="配合使用引用队列"></a>配合使用引用队列</h4><p>　　WeakHashMap 用弱引用承载映射键，这使得应用程序不再使用键对象时它们可以被垃圾收集，get() 实现可以根据 WeakReference.get() 是否返回 null 来区分死的映射和活的映射。但是这只是防止 Map 的内存消耗在应用程序的生命周期中不断增加所需要做的工作的一半，还需要做一些工作以便在键对象被收集后从 Map 中删除死项。否则，Map 会充满对应于死键的项。虽然这对于应用程序是不可见的，但是它仍然会造成应用程序耗尽内存。 </p>
<p>　　引用队列是垃圾收集器向应用程序返回关于对象生命周期的信息的主要方法。弱引用有个构造函数取引用队列作为参数。如果用关联的引用队列创建弱引用，在弱引用对象成为 GC 候选对象时，这个引用对象就在引用清除后加入到引用队列中（具体参考上文软引用示例）。</p>
<p>　　WeakHashMap 有一个名为 expungeStaleEntries() 的私有方法，大多数 Map 操作中会调用它，它去掉引用队列中所有失效的引用，并删除关联的映射。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/11/详细介绍Java垃圾回收机制/" itemprop="url">
                  详细介绍Java垃圾回收机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-11T14:56:05+08:00" content="2016-09-11">
              2016-09-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java-基础/" itemprop="url" rel="index">
                    <span itemprop="name">java_基础</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/11/详细介绍Java垃圾回收机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/11/详细介绍Java垃圾回收机制/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.cnblogs.com/laoyangHJ/articles/java_gc.html" target="_blank" rel="external">TokgoLiang——转载别人的原文链接一定要写在开头</a></p>
<h2 id="垃圾收集GC（Garbage-Collection）"><a href="#垃圾收集GC（Garbage-Collection）" class="headerlink" title="垃圾收集GC（Garbage Collection）"></a>垃圾收集GC（Garbage Collection）</h2><p>　　是Java语言的核心技术之一，之前我们曾专门探讨过Java 7新增的垃圾回收器G1的新特性，但在JVM的内部运行机制上看，Java的垃圾回收原理与机制并未改变。垃圾收集的目的在于清除不再使用的对象。GC通过确定对象是否被活动对象引用来确定是否收集该对象。GC首先要判断该对象是否是时候可以收集。两种常用的方法是引用计数和对象引用遍历。</p>
<h2 id="引用计数收集器"><a href="#引用计数收集器" class="headerlink" title="引用计数收集器"></a>引用计数收集器</h2><p>　　引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象（不是引用）都有一个引用计数。当一个对象被创建时，且将该对象分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象+1），但当一个对象的某个引用超过了生命周期或者被设置为一个新值时，对象的引用计数减1。任何引用计数为0的对象可以被当作垃圾收集。当一个对象被垃圾收集时，它引用的任何对象计数减1。</p>
<p>优点：引用计数收集器可以很快的执行，交织在程序运行中。对程序不被长时间打断的实时环境比较有利。</p>
<p>缺点： 无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.</p>
<h2 id="跟踪收集器"><a href="#跟踪收集器" class="headerlink" title="跟踪收集器"></a>跟踪收集器</h2><p>早期的JVM使用引用计数，现在大多数JVM采用对象引用遍历。对象引用遍历从一组对象开始，沿着整个对象图上的每条链接，递归确定可到达（reachable）的对象。如果某对象不能从这些根对象的一个（至少一个）到达，则将它作为垃圾收集。在对象遍历阶段，GC必须记住哪些对象可以到达，以便删除不可到达的对象，这称为标记（marking）对象。</p>
<p>下一步，GC要删除不可到达的对象。删除时，有些GC只是简单的扫描堆栈，删除未标记的未标记的对象，并释放它们的内存以生成新的对象，这叫做清除（sweeping）。这种方法的问题在于内存会分成好多小段，而它们不足以用于新的对象，但是组合起来却很大。因此，许多GC可以重新组织内存中的对象，并进行压缩（compact），形成可利用的空间。</p>
<p>为此，GC需要停止其他的活动活动。这种方法意味着所有与应用程序相关的工作停止，只有GC运行。结果，在响应期间增减了许多混杂请求。另外，更复杂的 GC不断增加或同时运行以减少或者清除应用程序的中断。有的GC使用单线程完成这项工作，有的则采用多线程以增加效率。</p>
<h2 id="一些常用的垃圾收集器"><a href="#一些常用的垃圾收集器" class="headerlink" title="一些常用的垃圾收集器"></a>一些常用的垃圾收集器</h2><p>（1）标记－清除收集器</p>
<p>这种收集器首先遍历对象图并标记可到达的对象，然后扫描堆栈以寻找未标记对象并释放它们的内存。这种收集器一般使用单线程工作并停止其他操作。并且，由于它只是清除了那些未标记的对象，而并没有对标记对象进行压缩，导致会产生大量内存碎片，从而浪费内存。</p>
<p>（2）标记－压缩收集器</p>
<p>有时也叫标记－清除－压缩收集器，与标记－清除收集器有相同的标记阶段。在第二阶段，则把标记对象复制到堆栈的新域中以便压缩堆栈。这种收集器也停止其他操作。</p>
<p>（3）复制收集器</p>
<p>这种收集器将堆栈分为两个域，常称为半空间。每次仅使用一半的空间，JVM生成的新对象则放在另一半空间中。GC运行时，它把可到达对象复制到另一半空间，从而压缩了堆栈。这种方法适用于短生存期的对象，持续复制长生存期的对象则导致效率降低。并且对于指定大小堆来说，需要两倍大小的内存，因为任何时候都只使用其中的一半。</p>
<p> (4) 增量收集器</p>
<p>增量收集器把堆栈分为多个域，每次仅从一个域收集垃圾，也可理解为把堆栈分成一小块一小块，每次仅对某一个块进行垃圾收集。这会造成较小的应用程序中断时间，使得用户一般不能觉察到垃圾收集器正在工作。</p>
<p>（5）分代收集器</p>
<p>复制收集器的缺点是：每次收集时，所有的标记对象都要被拷贝，从而导致一些生命周期很长的对象被来回拷贝多次，消耗大量的时间。而分代收集器则可解决这个问题，分代收集器把堆栈分为两个或多个域，用以存放不同寿命的对象。JVM生成的新对象一般放在其中的某个域中。过一段时间，继续存在的对象(非短命对象)将获得使用期并转入更长寿命的域中。分代收集器对不同的域使用不同的算法以优化性能。</p>
<h2 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a>并行收集器</h2><p>并行收集器使用某种传统的算法并使用多线程并行的执行它们的工作。在多CPU机器上使用多线程技术可以显著的提高java应用程序的可扩展性。</p>
<p>最后，贴出一个非常简单的跟踪收集器的例图，以便大家加深对收集器的理解：<br><img src="http://7xu1cb.com1.z0.glb.clouddn.com/%E8%B7%9F%E8%B8%AA%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt=""></p>
<h2 id="使用垃圾收集器要注意的地方"><a href="#使用垃圾收集器要注意的地方" class="headerlink" title="##使用垃圾收集器要注意的地方"></a>##使用垃圾收集器要注意的地方</h2><p>下面将提出一些有关垃圾收集器要注意的地方，垃圾收集器知识很多，下面只列出一部分必要的知识：</p>
<p>（1）每个对象只能调用finalize( )方法一次。如果在finalize( )方法执行时产生异常（exception），则该对象仍可以被垃圾收集器收集。</p>
<p>（2）垃圾收集器跟踪每一个对象，收集那些不可触及的对象（即该对象不再被程序引用 了），回收其占有的内存空间。但在进行垃圾收集的时候，垃圾收集器会调用该对象的finalize( )方法（如果有）。如果在finalize()方法中，又使得该对象被程序引用(俗称复活了)，则该对象就变成了可触及的对象，暂时不会被垃圾收集了。但是由于每个对象只能调用一次finalize( )方法，所以每个对象也只可能 “复活 “一次。</p>
<p>（3）Java语言允许程序员为任何方法添加finalize( )方法，该方法会在垃圾收集器交换回收对象之前被调用。但不要过分依赖该方法对系统资源进行回收和再利用，因为该方法调用后的执行结果是不可预知的。</p>
<p>（4）垃圾收集器不可以被强制执行，但程序员可以通过调研System.gc方法来建议执行垃圾收集。记住，只是建议。一般不建议自己写System.gc，因为会加大垃圾收集工作量。</p>
<h2 id="详解Java-GC的工作原理"><a href="#详解Java-GC的工作原理" class="headerlink" title="##详解Java GC的工作原理"></a>##详解Java GC的工作原理</h2><p>概要: JVM内存结构由堆、栈、本地方法栈、方法区等部分组成，另外JVM分别对新生代和旧生代采用不同的垃圾回收机制。</p>
<p><strong>首先来看一下JVM内存结构</strong>，它是由堆、栈、本地方法栈、方法区等部分组成，结构图如下所示。<br><img src="http://7xu1cb.com1.z0.glb.clouddn.com/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.gif" alt=""></p>
<p>1)堆</p>
<p>所有通过new创建的对象的内存都在堆中分配，其大小可以通过-Xmx和-Xms来控制。堆被划分为新生代和旧生代，新生代又被进一步划分为Eden和Survivor区，最后Survivor由FromSpace和ToSpace组成，结构图如下所示：</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/%E5%A0%86.gif" alt=""></p>
<p>新生代。新建的对象都是用新生代分配内存，Eden空间不足的时候，会把存活的对象转移到Survivor中，新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例旧生代。用于存放新生代中经过多次垃圾回收仍然存活的对象</p>
<p>2)栈</p>
<p>每个线程执行每个方法的时候都会在栈中申请一个栈帧，每个栈帧包括局部变量区和操作数栈，用于存放此次方法调用过程中的临时变量、参数和中间结果</p>
<p>3)本地方法栈</p>
<p>用于支持native方法的执行，存储了每个native方法调用的状态</p>
<p>4)方法区</p>
<p>存放了要加载的类信息、静态变量、final类型的常量、属性和方法信息。JVM用持久代(PermanetGeneration)来存放方法区，可通过-XX:PermSize和-XX:MaxPermSize来指定最小值和最大值。介绍完了JVM内存组成结构，下面我们再来看一下JVM垃圾回收机制</p>
<h2 id="JVM垃圾回收机制"><a href="#JVM垃圾回收机制" class="headerlink" title="JVM垃圾回收机制"></a>JVM垃圾回收机制</h2><p>JVM分别对新生代和旧生代采用不同的垃圾回收机制</p>
<h4 id="新生代的GC："><a href="#新生代的GC：" class="headerlink" title="新生代的GC："></a>新生代的GC：</h4><p>新生代通常存活时间较短，因此基于Copying算法来进行回收，所谓Copying算法就是扫描出存活的对象，并复制到一块新的完全未使用的空间中，对应于新生代，就是在Eden和FromSpace或ToSpace之间copy。新生代采用空闲指针的方式来控制GC触发，指针保持最后一个分配的对象在新生代区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发GC。当连续分配对象时，对象会逐渐从eden到survivor，最后到旧生代，</p>
<p>用javavisualVM来查看，能明显观察到新生代满了后，会把对象转移到旧生代，然后清空继续装载，当旧生代也满了后，就会报outofmemory的异常，如下图所示：</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/%E6%96%B0%E7%94%9F%E4%BB%A3%E7%9A%84GC.gif" alt=""></p>
<p>outofmemory的异常</p>
<p>在执行机制上JVM提供了串行GC(SerialGC)、并行回收GC(ParallelScavenge)和并行GC(ParNew)</p>
<p>1)串行GC</p>
<p>在整个扫描和复制过程采用单线程的方式来进行，适用于单CPU、新生代空间较小及对暂停时间要求不是非常高的应用上，是client级别默认的GC方式，可以通过-XX:+UseSerialGC来强制指定</p>
<p>2)并行回收GC</p>
<p>在整个扫描和复制过程采用多线程的方式来进行，适用于多CPU、对暂停时间要求较短的应用上，是server级别默认采用的GC方式，可用-XX:+UseParallelGC来强制指定，用-XX:ParallelGCThreads=4来指定线程数</p>
<p>3)并行GC</p>
<p>与旧生代的并发GC配合使用</p>
<h4 id="旧生代的GC："><a href="#旧生代的GC：" class="headerlink" title="旧生代的GC："></a>旧生代的GC：</h4><p>旧生代与新生代不同，对象存活的时间比较长，比较稳定，因此采用标记(Mark)算法来进行回收，所谓标记就是扫描出存活的对象，然后再进行回收未被标记的对象，回收后对用空出的空间要么进行合并，要么标记出来便于下次进行分配，总之就是要减少内存碎片带来的效率损耗。在执行机制上JVM提供了串行GC(SerialMSC)、并行GC(parallelMSC)和并发GC(CMS)，具体算法细节还有待进一步深入研究。</p>
<p>以上各种GC机制是需要组合使用的，指定方式由下表所示：</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/%E5%90%84%E7%A7%8DGC%E6%9C%BA%E5%88%B6%E6%98%AF%E9%9C%80%E8%A6%81%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8.png" alt="GC机制组合使用"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/11/聊聊并发-Java中的Copy-On-Write容器/" itemprop="url">
                  聊聊并发-Java中的Copy-On-Write容器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-11T14:56:05+08:00" content="2016-09-11">
              2016-09-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java-基础/" itemprop="url" rel="index">
                    <span itemprop="name">java_基础</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/11/聊聊并发-Java中的Copy-On-Write容器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/11/聊聊并发-Java中的Copy-On-Write容器/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://ifeve.com/java-copy-on-write/" target="_blank" rel="external">TokgoLiang——转载别人的原文链接一定要写在开头</a></p>
<p>　　Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。</p>
<h2 id="什么是CopyOnWrite容器"><a href="#什么是CopyOnWrite容器" class="headerlink" title="什么是CopyOnWrite容器"></a>什么是CopyOnWrite容器</h2><p>　　CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<h2 id="CopyOnWriteArrayList的实现原理"><a href="#CopyOnWriteArrayList的实现原理" class="headerlink" title="CopyOnWriteArrayList的实现原理"></a>CopyOnWriteArrayList的实现原理</h2><p>　　在使用CopyOnWriteArrayList之前，我们先阅读其源码了解下它是如何实现的。以下代码是向ArrayList里添加元素，可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T e)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">        Object[] elements = getArray();</div><div class="line">        <span class="keyword">int</span> len = elements.length;</div><div class="line">        <span class="comment">// 复制出新数组</span></div><div class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</div><div class="line">        <span class="comment">// 把新元素添加到新数组里</span></div><div class="line">        newElements[len] = e;</div><div class="line">        <span class="comment">// 把原数组引用指向新数组</span></div><div class="line">        setArray(newElements);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</div><div class="line">    array = a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> get(getArray(), index);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　JDK中并没有提供CopyOnWriteMap，我们可以参考CopyOnWriteArrayList来实现一个，基本代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Collection;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"><span class="keyword">import</span> java.util.Set;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Cloneable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;K, V&gt; internalMap;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteMap</span><span class="params">()</span> </span>&#123;</div><div class="line">        internalMap = <span class="keyword">new</span> HashMap&lt;K, V&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            Map&lt;K, V&gt; newMap = <span class="keyword">new</span> HashMap&lt;K, V&gt;(internalMap);</div><div class="line">            V val = newMap.put(key, value);</div><div class="line">            internalMap = newMap;</div><div class="line">            <span class="keyword">return</span> val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> internalMap.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; newData)</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            Map&lt;K, V&gt; newMap = <span class="keyword">new</span> HashMap&lt;K, V&gt;(internalMap);</div><div class="line">            newMap.putAll(newData);</div><div class="line">            internalMap = newMap;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　实现很简单，只要了解了CopyOnWrite机制，我们可以实现各种CopyOnWrite容器，并且在不同的应用场景中使用。</p>
<h2 id="CopyOnWrite的应用场景"><a href="#CopyOnWrite的应用场景" class="headerlink" title="CopyOnWrite的应用场景"></a>CopyOnWrite的应用场景</h2><p>　　CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.ifeve.book;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"><span class="keyword">import</span> com.ifeve.book.forkjoin.CopyOnWriteMap;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 黑名单服务</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> fangtengfei</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackListServiceImpl</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteMap&lt;String, Boolean&gt; blackListMap = <span class="keyword">new</span> CopyOnWriteMap&lt;String, Boolean&gt;(</div><div class="line">            <span class="number">1000</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBlackList</span><span class="params">(String id)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> blackListMap.get(id) == <span class="keyword">null</span> ? <span class="keyword">false</span> : <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addBlackList</span><span class="params">(String id)</span> </span>&#123;</div><div class="line">        blackListMap.put(id, Boolean.TRUE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 批量添加黑名单</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> ids</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addBlackList</span><span class="params">(Map&lt;String,Boolean&gt; ids)</span> </span>&#123;</div><div class="line">        blackListMap.putAll(ids);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>代码很简单，但是使用CopyOnWriteMap需要注意两件事情：</strong></p>
<ol>
<li>减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。</li>
<li>使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。如使用上面代码里的addBlackList方法。</li>
</ol>
<h2 id="CopyOnWrite的缺点"><a href="#CopyOnWrite的缺点" class="headerlink" title="CopyOnWrite的缺点"></a>CopyOnWrite的缺点</h2><p>　　CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p>
<p>　　内存占用问题。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</p>
<p>　　针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。</p>
<p>　　数据一致性问题。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p>
<p>　　关于C++的STL中，曾经也有过Copy-On-Write的玩法，参见陈皓的《C++ STL String类中的Copy-On-Write》，后来，因为有很多线程安全上的事，就被去掉了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/11/java中Date, DateFormat的一些方法总结/" itemprop="url">
                  java中Date, DateFormat的一些方法总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-11T10:34:07+08:00" content="2016-09-11">
              2016-09-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java-基础/" itemprop="url" rel="index">
                    <span itemprop="name">java_基础</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/11/java中Date, DateFormat的一些方法总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/11/java中Date, DateFormat的一些方法总结/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://blog.csdn.net/woshisap/article/details/6617118/" target="_blank" rel="external">TokgoLiang——转载别人的原文链接一定要写在开头</a></p>
<p><strong>DateDemo1.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * 取得系统的时间 </div><div class="line"> */  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateDemo1</span> </span>&#123;  </div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;  </div><div class="line">		System.out.println(System.currentTimeMillis());  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1311060393171</span></div></pre></td></tr></table></figure></p>
<p>　　执行结果会显示从1970年1月1日开始到取得系统时间为止所经过的毫秒数，例如1115346430703这个数字，但这样的数字没有人确切了解它的意 义是什么，您可以使用Date类别来让这个数字变的更有意义一些</p>
<p><strong>DateDemo2.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateDemo2</span> </span>&#123;  </div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;  </div><div class="line">        Date date = <span class="keyword">new</span> Date();  </div><div class="line">          </div><div class="line">        System.out.println(<span class="string">"date.toString: "</span> + date.toString());  </div><div class="line">        System.out.println(<span class="string">"date: "</span> + date.getDate());  </div><div class="line">        System.out.println(<span class="string">"day: "</span> + date.getDay());  </div><div class="line">        System.out.println(<span class="string">"hour: "</span> + date.getHours());  </div><div class="line">        System.out.println(<span class="string">"minutes: "</span> + date.getMinutes());  </div><div class="line">        System.out.println(<span class="string">"month: "</span> + (date.getMonth() + <span class="number">1</span>));  </div><div class="line">        System.out.println(<span class="string">"seconds: "</span> + date.getSeconds());  </div><div class="line">        System.out.println(<span class="string">"time: "</span> + date.getTime());  </div><div class="line">        System.out.println(<span class="string">"timezone: "</span> + date.getTimezoneOffset());  </div><div class="line">        System.out.println(<span class="string">"year: "</span> + (date.getYear() + <span class="number">1900</span>));  </div><div class="line">          </div><div class="line">        Calendar calendar = Calendar.getInstance();  </div><div class="line">        <span class="keyword">int</span> year = calendar.get(Calendar.YEAR);  </div><div class="line">        <span class="keyword">int</span> month = calendar.get(Calendar.MONTH) + <span class="number">1</span>;  </div><div class="line">        <span class="keyword">int</span> day = calendar.get(Calendar.DATE);  </div><div class="line">        <span class="keyword">int</span> hour = calendar.get(Calendar.HOUR);  </div><div class="line">        <span class="keyword">int</span> minute = calendar.get(Calendar.MINUTE);  </div><div class="line">        <span class="keyword">int</span> second = calendar.get(Calendar.SECOND);  </div><div class="line">          </div><div class="line">        System.out.println(<span class="string">"----------Calendar-------"</span>);  </div><div class="line">        System.out.println(<span class="string">"year: "</span> + year);  </div><div class="line">        System.out.println(<span class="string">"month: "</span> + month);  </div><div class="line">        System.out.println(<span class="string">"day: "</span> + day);  </div><div class="line">        System.out.println(<span class="string">"hour: "</span> + hour);  </div><div class="line">        System.out.println(<span class="string">"minute: "</span> + minute);  </div><div class="line">        System.out.println(<span class="string">"second: "</span> + second);  </div><div class="line">          </div><div class="line">    	&#125;  </div><div class="line">	&#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　用date获得时间的值，如时、分、秒、月、日、年得方法已经过时，需要改用Calendar的方法来获取时间的值,输出结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">date.toString: Tue Jul <span class="number">19</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">42</span> CST <span class="number">2011</span>  </div><div class="line">date: <span class="number">19</span>  </div><div class="line">day: <span class="number">2</span>  </div><div class="line">hour: <span class="number">15</span>  </div><div class="line">minutes: <span class="number">32</span>  </div><div class="line">month: <span class="number">7</span>  </div><div class="line">seconds: <span class="number">42</span>  </div><div class="line">time: <span class="number">1311060762362</span>  </div><div class="line">timezone: -<span class="number">480</span>  </div><div class="line">year: <span class="number">2011</span>  </div><div class="line">----------Calendar-------  </div><div class="line">year: <span class="number">2011</span>  </div><div class="line">month: <span class="number">7</span>  </div><div class="line">day: <span class="number">19</span>  </div><div class="line">hour: <span class="number">3</span>  </div><div class="line">minute: <span class="number">32</span>  </div><div class="line">second: <span class="number">42</span></div></pre></td></tr></table></figure>
<p><strong>DateDemo3.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateDemo3</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;  </div><div class="line">        Date date = <span class="keyword">new</span> Date();  </div><div class="line">          </div><div class="line">        <span class="comment">/* </span></div><div class="line">         * DateFormat会依电脑上的区域设定显示时间格式，EE表示星期，MM表示月份、dd表示日期，而yyyy是西元，每个字元的设定都各有其意义 </div><div class="line">         * 从Date--&gt;String </div><div class="line">         */  </div><div class="line">        DateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"EE-MM-dd-yyyy"</span>);  </div><div class="line">        System.out.println(dateFormat.format(date));  </div><div class="line">          </div><div class="line">        DateFormat format1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);  </div><div class="line">        System.out.println(format1.format(date));  </div><div class="line">          </div><div class="line">        DateFormat format2 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);  </div><div class="line">        System.out.println(format2.format(date));  </div><div class="line">      </div><div class="line">        <span class="comment">/* </span></div><div class="line">         * 从String--&gt;Date </div><div class="line">         */  </div><div class="line">        String dateStr = <span class="string">"2011-7-19"</span>;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            Date dateTrans = format1.parse(dateStr);  </div><div class="line">            <span class="comment">//System.out.println(dateTrans.toString());   </span></div><div class="line">            System.out.println(dateTrans.toLocaleString());  <span class="comment">//转换为本地的形式  </span></div><div class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">    &#125;  </div><div class="line">&#125;</div><div class="line">```  </div><div class="line"></div><div class="line"> 　　使用DateFormat来格式化日期数据，上面部分为从Date--&gt;String，下面的部分为从String--&gt;Date，输出结果为：</div><div class="line"></div><div class="line">``` java</div><div class="line">星期二-<span class="number">07</span>-<span class="number">19</span>-<span class="number">2011</span>  </div><div class="line"><span class="number">2011</span>-<span class="number">07</span>-<span class="number">19</span>  </div><div class="line"><span class="number">2011</span>-<span class="number">07</span>-<span class="number">19</span> <span class="number">15</span>:<span class="number">33</span>:<span class="number">27</span>  </div><div class="line"><span class="number">2011</span>-<span class="number">7</span>-<span class="number">19</span> <span class="number">0</span>:<span class="number">00</span>:<span class="number">00</span></div></pre></td></tr></table></figure></p>
<p><strong>DateDemo4.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateDemo4</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">          </div><div class="line">        Date date = <span class="keyword">new</span> Date();  </div><div class="line">        DateFormat shortFormat = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT);  </div><div class="line">        DateFormat mediumFormat = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM);  </div><div class="line">        DateFormat longFormat = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG);  </div><div class="line">        DateFormat fullFormat = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL);  </div><div class="line">          </div><div class="line">        System.out.println(shortFormat.format(date));  </div><div class="line">        System.out.println(mediumFormat.format(date));  </div><div class="line">        System.out.println(longFormat.format(date));  </div><div class="line">        System.out.println(fullFormat.format(date));  </div><div class="line">          </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">11</span>-<span class="number">7</span>-<span class="number">19</span> 下午<span class="number">3</span>:<span class="number">33</span>  </div><div class="line"><span class="number">2011</span>-<span class="number">7</span>-<span class="number">19</span> <span class="number">15</span>:<span class="number">33</span>:<span class="number">54</span>  </div><div class="line"><span class="number">2011</span>年<span class="number">7</span>月<span class="number">19</span>日 下午<span class="number">03</span>时<span class="number">33</span>分<span class="number">54</span>秒  </div><div class="line"><span class="number">2011</span>年<span class="number">7</span>月<span class="number">19</span>日 星期二 下午<span class="number">03</span>时<span class="number">33</span>分<span class="number">54</span>秒 CST</div></pre></td></tr></table></figure></p>
<p><strong>DateDemo5.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateDemo5</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;  </div><div class="line">        Date date = <span class="keyword">new</span> Date();  </div><div class="line">          </div><div class="line">        Locale locale = <span class="keyword">new</span> Locale(<span class="string">"en"</span>, <span class="string">"US"</span>);  </div><div class="line">          </div><div class="line">        DateFormat shortDateFormat = DateFormat.getDateInstance(DateFormat.SHORT, locale);  </div><div class="line">        DateFormat mediumDateFormat = DateFormat.getDateInstance(DateFormat.MEDIUM, locale);  </div><div class="line">        DateFormat longDateFormat = DateFormat.getDateInstance(DateFormat.LONG, locale);  </div><div class="line">        DateFormat fullDateFormat = DateFormat.getDateInstance(DateFormat.FULL, locale);  </div><div class="line">          </div><div class="line">        System.out.println(shortDateFormat.format(date));  </div><div class="line">        System.out.println(mediumDateFormat.format(date));  </div><div class="line">        System.out.println(longDateFormat.format(date));  </div><div class="line">        System.out.println(fullDateFormat.format(date));  </div><div class="line">          </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果为：</p>
<pre><code class="java"><span class="number">7</span>/<span class="number">19</span>/<span class="number">11</span>  
Jul <span class="number">19</span>, <span class="number">2011</span>  
July <span class="number">19</span>, <span class="number">2011</span>  
Tuesday, July <span class="number">19</span>, <span class="number">2011</span>
</code></pre>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://7xu1cb.com1.z0.glb.clouddn.com/IMG_0273.JPG"
               alt="TokgoLiang" />
          <p class="site-author-name" itemprop="name">TokgoLiang</p>
          <p class="site-description motion-element" itemprop="description">In me the tiger sniffs the rose.</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">17</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://qiushao.net/" title="qiushao的博客" target="_blank">qiushao的博客</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TokgoLiang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"tokgoliang"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
