<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="In me the tiger sniffs the rose.">
<meta property="og:type" content="website">
<meta property="og:title" content="TokgoLiang的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="TokgoLiang的博客">
<meta property="og:description" content="In me the tiger sniffs the rose.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TokgoLiang的博客">
<meta name="twitter:description" content="In me the tiger sniffs the rose.">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> TokgoLiang的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">TokgoLiang的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/21/第一章：Android体系与系统架构丶第二章：Android开发工具新接触/" itemprop="url">
                  第一章：Android体系与系统架构丶第二章：Android开发工具新接触
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-21T23:55:36+08:00" content="2016-09-21">
              2016-09-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Android_读书笔记</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/Android群英传/" itemprop="url" rel="index">
                    <span itemprop="name">Android群英传</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android体系与系统架构"><a href="#Android体系与系统架构" class="headerlink" title="Android体系与系统架构"></a>Android体系与系统架构</h1><h2 id="Android系统架构"><a href="#Android系统架构" class="headerlink" title="Android系统架构"></a>Android系统架构</h2><p>　　如下图所示，这是一张讲解Android系统架构的经典示意图。它将Android大致分为了四层，即Linux内核层，库和运行时，Framwork层和应用层。Android的系统架构鼓励系统组建重用，共享组件间的数据，并且定义组件间的访问权限控制。可以说，这些层次结构既相互独立又是互相关联的。</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.gif" alt="Android系统架构"></p>
<p>　　有人说，Android是一个用于连接设备的软件集合，下图就代表了一个最抽象的Android系统架构。</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/Android%E6%9E%B6%E6%9E%84%E6%80%BB%E8%A7%88.png" alt="android架构总览"></p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>　　Linux层，Android最底层最核心的部分。当我们打开手机Setting，选择about phone选项，这一选项所显示的内核版本，就是我们所用的Linux内核的版本。Linux层包含了Android系统的核心服务，包括硬件驱动丶进程管理丶安全系统，等等。</p>
<h3 id="Dalvik与ART"><a href="#Dalvik与ART" class="headerlink" title="Dalvik与ART"></a>Dalvik与ART</h3><p>　　Dalvik包含了一整套的Android运行环境虚拟机，每个App都会分配Dalvik虚拟机来保证互相之间不受干扰，并保持独立。它的特点是在运行时编译。打个比方，就好比你买了一辆折叠自行车，平时是折叠的，只有在骑得时候，才需要组装起来用。而在Android5.X版本开始，ART模式已经取代了Dalvik，ART采用的是安装时就进行编译，以后运行时就不用编译了，这就好比你买了辆组装好了的自行车，装好了就可以骑了。当然，对在其虚拟机环境中运行的大部分App来说，它们都运行着同样的代码。</p>
<h3 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h3><p>　　下图为Android App Framework 的详细版。它包含了整个Android Framework的重点，如果以后要研究Framework的具体流程，基本就是在和它们打交道。</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/Framework.png" alt="framework"></p>
<h3 id="Standard-Libraries"><a href="#Standard-Libraries" class="headerlink" title="Standard Libraries"></a>Standard Libraries</h3><p>　　下图为Standard Libraries的详细版，这里包含的是Android中的一些标准库，所谓标准，就是开发者在开源环境中可以使用的开发库。</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/Libraries.png" alt="libraries"></p>
<h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>　　下面两图分别表示了使用NDK开发和Java开发的App的主要构成。可以看出，不管那种App，它们都有Android Manifest 文件，Dalvik Classes，Resource Bundle这几个东西，相信解压过Apk的朋友应该注意到了，这些就是我们解压Apk后的文件。</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/ndkapp.png" alt="ndk"></p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/sdkapp.png" alt="sdk"></p>
<p>　　对于开发者来说，与Android系统最直接的接触就是SDK，应用开发者应当关注每个版本的SDK修改，从而提高应用的兼容性，如果站在Android设计者的角度上来看整个Android的架构，设计者希望Android的架构层能够起到承上启下的功能，让应用的各个组件之间解耦，并通过框架来进行统一的调度，管理。</p>
<h2 id="Android-App-组件架构"><a href="#Android-App-组件架构" class="headerlink" title="Android App 组件架构"></a>Android App 组件架构</h2><p>　　在应用层，Android的App组件架构，痛就是我们所说的四大组件，指的是Activity，BroadCastReciver,ContentProvider和Service，它们是构成一个AndroidApp的最基本元素。</p>
<h3 id="Android四大组件如何协同工作"><a href="#Android四大组件如何协同工作" class="headerlink" title="Android四大组件如何协同工作"></a>Android四大组件如何协同工作</h3><p>　　Activity作为人机交互的第一界面，负责向用户展示信息和处理结果，而这些信息的来源，可以是通过资源获取，也可以是通过Conten Provider 来获取其他应用的信息，或是Service从后台计算，下载，处理的结果，当然也可以是通过BroadCast Reciver获取到的广播信息。同时，Android系统还提供了要给信使——Intent，作为信息传递的载体。组件与组件之间通过Intent来通信，传递信息，交换数据，正式通过这样要给方式，四大组件形成了各自独立而又紧密联系的关系，让整个Android系统“活”了起来。</p>
<h3 id="应用运行上下文对象"><a href="#应用运行上下文对象" class="headerlink" title="应用运行上下文对象"></a>应用运行上下文对象</h3><p>　　Android系统中的上下文对象，即在Context中，为我们封装了这样一个“语境”。Activity，Service，Application都是继承自Context。</p>
<p>　　Android应用程序会在如下所示的几个时间点创建上下文Context。</p>
<ul>
<li>创建 Application</li>
<li>创建Activity</li>
<li>创建Service</li>
</ul>
<p>　　不难发现，创建Context的时机就是创建Context的实现类的时候。当应用程序第一次启动时，Android系统都会创建一个Application对象，同时创建Application Conetext，所有的组件都共同拥有这个Context对象，这个应用上下文对象贯穿了整个应用进程的生命周期，为应用全局提供了功能和环境支持。</p>
<p>　　而创建Activity和Service组件时，系统也会给他们提供运行时的上下文环境，即创建Activity实例，Service实例的Context对象。所以在Activity中获取Context对象时，可以直接使用this，而在匿名内部类中，就必须指定XXXActivity.this 才可以获得该Activity的Context对象。</p>
<p>　　当然也可以通过getApplicationContext()方法来获取整个App的Context，但是通过getApplicationContext()方法获得的是整个应用的上下文引用，这与某个组件的上下文应用，在某些时候还有有区别的。</p>
<h2 id="Android系统源代码目录与系统目录"><a href="#Android系统源代码目录与系统目录" class="headerlink" title="Android系统源代码目录与系统目录"></a>Android系统源代码目录与系统目录</h2><h3 id="Android系统源代码目录"><a href="#Android系统源代码目录" class="headerlink" title="Android系统源代码目录"></a>Android系统源代码目录</h3><blockquote>
<p>想要看懂整个Android的源代码，你要懂C，懂脚本，懂Java，不仅仅要软硬兼通，而且要有一颗耐得住寂寞，忍得了枯燥的心。。。。。。</p>
</blockquote>
<p>作者推荐了一个查看Android源代码的网站：<a href="http://androidxref.com/" title="androidxref" target="_blank" rel="external">androidxref</a></p>
<p>还有一个非常好的不需要翻墙的网站<a href="https://developer.android.com/index.html" title="Android Developers" target="_blank" rel="external">Android Developers</a></p>
<p>Android源码大概目录如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- Makefile</div><div class="line">- bionic				（bionic C 库）</div><div class="line">- bootable			（启动引导相关代码）</div><div class="line">- build				（存放系统编译规则等基础开发包配置）</div><div class="line">- cts				（Google 兼容性测试标准）</div><div class="line">- dalvik            （dalvik虚拟机）</div><div class="line">- development		（应用程序开发相关）</div><div class="line">- external          （android 使用的一些开源的模块）</div><div class="line">- framework         （Framework框架核心）</div><div class="line">- hardware			（厂商硬件适配层HAL代码）</div><div class="line">- out				（编译完成后的代码输出目录）</div><div class="line">- packages			（应用程序包）</div><div class="line">- prebuilt			（x86和arm架构下预编译资源）</div><div class="line">- sdk				 (sdk及模拟器）</div><div class="line">- system				（底层文件系统库，应用及组件）</div><div class="line">- vendor				（厂商定制代码）</div></pre></td></tr></table></figure>
<p>　　不过并不是所有的源代码结构都是这样，只有AOSP的Android项目才是这样一个结构。</p>
<p>　　Eclipse，AndroidStudio都属于开发IDE，Android源码的编译需要通过Makefile机制。</p>
<p>　　一个像Andoid这样的大型工程，它的源文件不计其数，不同的功能，模块，按类型分别放置在不同的目录中，这些模块通常会有一个叫Makefile的文件来进行管理。它定义了一系列的规则来制定模块，哪些文件需要编译，以及这些文件该按照怎样的顺序去编译。甚至它还可以配置更复杂的功能操作，比如定义编译规则，打包规则等，因为Makefile就像一个shell脚本，不仅可以使用自己的语法，也能调用操作系的命令。</p>
<p>关于编译给大家推荐两篇文章：</p>
<p><a href="http://tokgoliang.com/2016/09/13/%E7%90%86%E8%A7%A3Android%E7%BC%96%E8%AF%91%E5%91%BD%E4%BB%A4/" title="理解Android编译命令" target="_blank" rel="external">理解Android编译命令</a><br><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/" title="理解 Android Build 系统" target="_blank" rel="external">理解 Android Build 系统</a></p>
<h3 id="Android系统目录"><a href="#Android系统目录" class="headerlink" title="Android系统目录"></a>Android系统目录</h3><p>未完待续。。。。。</p>
<h1 id="Android开发工具新接触"><a href="#Android开发工具新接触" class="headerlink" title="Android开发工具新接触"></a>Android开发工具新接触</h1>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/19/第七章：ProGuard技术详解/" itemprop="url">
                  第七章：ProGuard技术详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-19T23:13:06+08:00" content="2016-09-19">
              2016-09-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Android_读书笔记</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/App研发录/" itemprop="url" rel="index">
                    <span itemprop="name">App研发录</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ProGuard简介"><a href="#ProGuard简介" class="headerlink" title="ProGuard简介"></a>ProGuard简介</h1><p>ProGuard一共包括以下四个功能：</p>
<ol>
<li>压缩（Shrink）：侦测并移除代码中无用的类，字段，方法和特性（Attribute）。</li>
<li>优化（Optimize）：对字节码优化，移除无用的指令。</li>
<li>混淆（Obfuscate）：使用a、b、c、d这样简短而无意义的名称，对类，字段和方法进行重命名。</li>
<li>预检（Preveirfy）：在Java平台上对处理后的代码进行预检。</li>
</ol>
<p>如果仅仅为了代码混淆可以试试ProGuard的兄弟产品DexGuard，与ProGuard相比，DexGuard还能混淆字符串常量。</p>
<ul>
<li>ProGuard地址：<a href="http://ProGuard.sourceforge.net" target="_blank" rel="external">http://ProGuard.sourceforge.net</a></li>
<li>DexGuard地址：<a href="http://www.saikoa.com/dexguard" target="_blank" rel="external">http://www.saikoa.com/dexguard</a></li>
</ul>
<h1 id="ProGuard工作原理"><a href="#ProGuard工作原理" class="headerlink" title="ProGuard工作原理"></a>ProGuard工作原理</h1><p>ProGuard由shrink，optimize，obfuscate和preverify四个步骤组成，其中每个步骤都是可选的，可以通过配置脚本来决定执行其中的哪几个步骤</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/ProGuard%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="ProGuard 工作原理"></p>
<p>这里引入Entry Point的概念。Entry Point是在ProGuard过程中不会被处理的类或方法。在压缩的步骤中，ProGuard会从上述的EntryPoint开始递归遍历，搜索哪些类和类的成员变量在使用。对于没有被使用的类和类的成员变量，就会在压缩阶段丢弃。接下来在优化步骤中，那些非EntryPoint的类，方法都会被设置为private，static，或者final，不是用的参数会被移除，此外，有些方法会被标记为内联的。在混淆的步骤中ProGuard会对非EntryPoint的类和方法进行重命名。</p>
<h1 id="如何写一个ProGuard文件（三步走）"><a href="#如何写一个ProGuard文件（三步走）" class="headerlink" title="如何写一个ProGuard文件（三步走）"></a>如何写一个ProGuard文件（三步走）</h1><h2 id="基本混淆，任何App都要用，可以作为模板使用"><a href="#基本混淆，任何App都要用，可以作为模板使用" class="headerlink" title="基本混淆，任何App都要用，可以作为模板使用"></a>基本混淆，任何App都要用，可以作为模板使用</h2><h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 代码混淆压缩比，在0和7之间，默认为5，一般不需要改</span></div><div class="line">-optimizationpasses 5</div><div class="line"><span class="comment"># 混淆时不使用大小写混合，混淆后的类名为小写</span></div><div class="line">-dontusemixedcaseclassnames</div><div class="line"><span class="comment"># 指定不去忽略非公共的库的类</span></div><div class="line">-dontskipnonpubliclibraryclasses</div><div class="line"><span class="comment"># 指定不去忽略非公共的库的类的成员</span></div><div class="line">-dontskipnonpubliclibraryclassmembers</div><div class="line"><span class="comment"># 不做预校验，preverify是proguard的4个步骤之一</span></div><div class="line"><span class="comment"># Android不需要preverify，去掉这一步可加快混淆速度</span></div><div class="line">-dontpreverify</div><div class="line"><span class="comment"># 有了verbose这句话，混淆后就会生成映射文件</span></div><div class="line"><span class="comment"># 包含有类名-&gt;混淆后类名的映射关系</span></div><div class="line"><span class="comment"># 然后使用printmapping指定映射文件的名称</span></div><div class="line">-verbose</div><div class="line">-printmapping proguardMapping.txt</div><div class="line"><span class="comment"># 指定混淆时采用的算法，后面的参数是一个过滤器</span></div><div class="line"><span class="comment"># 这个过滤器是谷歌推荐的算法，一般不改变</span></div><div class="line">-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*</div><div class="line"></div><div class="line"><span class="comment"># 保护代码中的Annotation不被混淆，这在JSON实体映射时非常重要，比如fastJson</span></div><div class="line">-keepattributes *Annotation*</div><div class="line"><span class="comment"># 避免混淆泛型，这在JSON实体映射时非常重要，比如fastJson</span></div><div class="line">-keepattributes Signature</div><div class="line">//抛出异常时保留代码行号，在第6章异常分析中我们提到过</div><div class="line">-keepattributes SourceFile,LineNumberTable</div></pre></td></tr></table></figure>
<h3 id="需要保留的东西"><a href="#需要保留的东西" class="headerlink" title="需要保留的东西"></a>需要保留的东西</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 保留所有的本地native方法不被混淆</span></div><div class="line">-keepclasseswithmembernames class * &#123;</div><div class="line">    native &lt;methods&gt;;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment"># 保留了继承自Activity、Application这些类的子类</span></div><div class="line"><span class="comment"># 因为这些子类，都有可能被外部调用</span></div><div class="line"><span class="comment"># 比如说，第一行就保证了所有Activity的子类不要被混淆</span></div><div class="line">-keep public class * extends android.app.Activity</div><div class="line">-keep public class * extends android.app.Application</div><div class="line">-keep public class * extends android.app.Service</div><div class="line">-keep public class * extends android.content.BroadcastReceiver</div><div class="line">-keep public class * extends android.content.ContentProvider</div><div class="line">-keep public class * extends android.app.backup.BackupAgentHelper</div><div class="line">-keep public class * extends android.preference.Preference</div><div class="line">-keep public class * extends android.view.View</div><div class="line">-keep public class com.android.vending.licensing.ILicensingService</div><div class="line"></div><div class="line"><span class="comment"># 如果有引用android-support-v4.jar包，可以添加下面这行</span></div><div class="line">-keep public class com.youngheart.app.ui.fragment.** &#123;*;&#125;</div><div class="line"> </div><div class="line"><span class="comment"># 保留在Activity中的方法参数是view的方法，</span></div><div class="line"><span class="comment"># 从而我们在layout里面编写onClick就不会被影响</span></div><div class="line">-keepclassmembers class * extends android.app.Activity &#123;</div><div class="line">    public void *(android.view.View);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment"># 枚举类不能被混淆</span></div><div class="line">-keepclassmembers enum * &#123;</div><div class="line">public static **[] values();</div><div class="line">public static ** valueOf(java.lang.String);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># 保留自定义控件（继承自View）不被混淆</span></div><div class="line">-keep public class * extends android.view.View &#123;</div><div class="line">    *** get*();</div><div class="line">    void <span class="built_in">set</span>*(***);</div><div class="line">    public &lt;init&gt;(android.content.Context);</div><div class="line">    public &lt;init&gt;(android.content.Context, android.util.AttributeSet);</div><div class="line">    public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment"># 保留Parcelable序列化的类不被混淆</span></div><div class="line">-keep class * implements android.os.Parcelable &#123;</div><div class="line">    public static final android.os.Parcelable<span class="variable">$Creator</span> *;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># 保留Serializable序列化的类不被混淆</span></div><div class="line">-keepclassmembers class * implements java.io.Serializable &#123;</div><div class="line">    static final long serialVersionUID;</div><div class="line">    private static final java.io.ObjectStreamField[] serialPersistentFields;</div><div class="line">    private void writeObject(java.io.ObjectOutputStream);</div><div class="line">    private void <span class="built_in">read</span>Object(java.io.ObjectInputStream);</div><div class="line">    java.lang.Object writeReplace();</div><div class="line">    java.lang.Object <span class="built_in">read</span>Resolve();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># 对于R（资源）下的所有类及其方法，都不能被混淆</span></div><div class="line">-keep class **.R$* &#123;</div><div class="line">    *;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># 对于带有回调函数onXXEvent的，不能被混淆</span></div><div class="line">-keepclassmembers class * &#123;</div><div class="line">    void *(**On*Event);</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line"><span class="comment">## 针对App量身定制 ##</span></div><div class="line"></div><div class="line"><span class="comment">### 保留实体类和成员不被混淆 ###</span></div><div class="line">     </div><div class="line">``` bash</div><div class="line">-keep public class com.youndheart.entity.** &#123;</div><div class="line">    public void <span class="built_in">set</span>*(***);</div><div class="line">    public *** get*();</div><div class="line">    public *** is*();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一种好的做法是把所有实体类都放在一个包下进行管理，这样只写一次混淆就够了。</p>
<h3 id="内嵌类"><a href="#内嵌类" class="headerlink" title="内嵌类"></a>内嵌类</h3><p>内嵌类经常会被混淆，结果在调用的时候为空就崩溃了。最好的解决办法就是把这个内嵌类拿出来，单独成为一个类。如果一定要内置，那么这个类必须在混淆的时候进行保留。-keep class com.example.youngheart.MainActivity$<em> { </em>; }保留com.example.youngheart.MainActivity的所有内嵌类，$这个符号就是用来分割内嵌类与其母体的标志。</p>
<h3 id="对WebView的处理"><a href="#对WebView的处理" class="headerlink" title="对WebView的处理"></a>对WebView的处理</h3><p>如果项目中用到了WebView的复杂操作，请加入一下这两段代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-keepclassmembers class * extends android.webkit.webViewClient &#123;</div><div class="line">    public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap);</div><div class="line">    public boolean *(android.webkit.WebView, java.lang.String)</div><div class="line">&#125;</div><div class="line">-keepclassmembers class * extends android.webkit.webViewClient &#123;</div><div class="line">    public void *(android.webkit.webView, java.lang.String)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="对JavaScript的处理"><a href="#对JavaScript的处理" class="headerlink" title="对JavaScript的处理"></a>对JavaScript的处理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#JSInterface1 是MainActivity的内嵌类</span></div><div class="line">-keepclassmembers class com.example.youngheart.MainActivity<span class="variable">$JSInterface1</span> &#123;</div><div class="line">    &lt;methods&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="处理反射"><a href="#处理反射" class="headerlink" title="处理反射"></a>处理反射</h3><p>对于SomeClass.class.method1和Class.forName(“SomeClass”)，ProGuard在压缩的时候会保留，但是在混淆的过程中，都不能蒙混过关，SomeClass这个类的名称会被混淆，因此，要在ProGuard.cfg文件中保留这个类的名称。</p>
<h3 id="对于自定义View的解决方案"><a href="#对于自定义View的解决方案" class="headerlink" title="对于自定义View的解决方案"></a>对于自定义View的解决方案</h3><p>凡是在layout目录下xml文件布局文件中配置的自定义View，都不能被混淆。为此要遍历layout下所有的xml布局文件，找到那些自定义View，然后确认其是否在proguard文件中保留了。这就需要我们写一个脚本，遍历layout下所有的xml布局文件，列举出layout中常用的那些标签，将其添加到一个字典中，凡是不在字典中的，就算做是自定义View。</p>
<p>另外一种思路是，在使用自定义View时，前面都必须加上我们自己的包名，我们可以遍历layout下所有的xml布局文件，查找所有匹配包名的标签即可。</p>
<h2 id="针对第三方jar包的解决方案"><a href="#针对第三方jar包的解决方案" class="headerlink" title="针对第三方jar包的解决方案"></a>针对第三方jar包的解决方案</h2><p>一般而言第三方提供的SDK都是经过ProGuard混淆了的，我们要做的就是避免这些SDK的类和方法在我们的App中被混淆。</p>
<h3 id="针对android-support-v4-jar的解决方案"><a href="#针对android-support-v4-jar的解决方案" class="headerlink" title="针对android-support-v4.jar的解决方案"></a>针对android-support-v4.jar的解决方案</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-libraryjars libs/android-support-v4.jar</div><div class="line">-dontwarn android.support.v4.**</div><div class="line">-keep class android.support.v4.**  &#123; *; &#125;</div><div class="line">-keep interface android.support.v4.app.** &#123; *; &#125;</div><div class="line">-keep public class * extends android.support.v4.**</div><div class="line">-keep public class * extends android.app.Fragment</div></pre></td></tr></table></figure>
<p>关于android-support-v4.jar的详细介绍：<a href="http://blog.csdn.net/hh2000/article/details/39718623" target="_blank" rel="external">http://blog.csdn.net/hh2000/article/details/39718623</a></p>
<h3 id="其他第三方jar包的解决方案"><a href="#其他第三方jar包的解决方案" class="headerlink" title="其他第三方jar包的解决方案"></a>其他第三方jar包的解决方案</h3><p>取决于但三方jar包的混淆策略，它们会在各自的SDK中有关于混淆的说明文字。比如支付宝，相应的规则是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-libraryjars libs/alipaysdk.jar</div><div class="line">-dontwarn com.alipay.android.app.**</div><div class="line">-keep public class com.alipay.**  &#123; *; &#125;</div></pre></td></tr></table></figure></p>
<p>一个好的做法是，打开libs目录，每个都进行类似的处理，值得注意的地方是不是每个第三方SDK都需要 -dontwarn指令，取决于混淆时第三方SDK是否会出现警告，需要的时候加上。</p>
<h3 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ol>
<li>如何确保混淆不会对项目产生影响</li>
</ol>
<p>如果一个Android项目从一开始就进行了混淆工作，那么：</p>
<ul>
<li>测试工作要基于混淆进行</li>
<li>每天开发团队的冒烟测试，也要基于混淆测试</li>
<li>发版前，要额外测试正式版的推送，分享，打点，二维码扫描等功能。</li>
</ul>
<ol>
<li><p>打包时忽略警告<br>　　当在导出时，发现很多could not reference class 之类的warning信息，如果确认App在运行中和那些引用没有什么关系的话，可以添加 -dontwarn标签，就不会提示这些信息了，如 -dontwarn org.apache.**。不要使用 -ignorewarnings，它会忽略所有警告，这回又很大的潜在风险。</p>
</li>
<li><p>对于自定义类库的混淆处理<br>　　我们需要对Lib也进行混淆，然后再主项目的混淆文件中保留AndroidLib中的类和类的成员。</p>
</li>
<li><p>使用annotation<br>　　另一种避免类或者属性被混淆的方式是，使用annotation，在需要保留的类中加上如下语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@keep</span></div><div class="line"><span class="meta">@KeepPublicGettersSetters</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bean</span></span>&#123;</div><div class="line">    ...</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/19/第六章：Crash异常分析——窗体、资源、系统碎片相关异常/" itemprop="url">
                  第六章：Crash异常分析——窗体、资源、系统碎片相关异常
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-19T22:27:32+08:00" content="2016-09-19">
              2016-09-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Android_读书笔记</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/App研发录/" itemprop="url" rel="index">
                    <span itemprop="name">App研发录</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="窗体相关异常"><a href="#窗体相关异常" class="headerlink" title="窗体相关异常"></a>窗体相关异常</h1><p>这种Crash很有名，原因基本都是在执行dismiss方法销毁对话框的时候，Activity已经不存在了。但是随着场景不同，抛出的异常信息却又大不相同。</p>
<h2 id="窗口句柄泄露"><a href="#窗口句柄泄露" class="headerlink" title="窗口句柄泄露"></a>窗口句柄泄露</h2><blockquote>
<p>异常中的关键字：android.view.WindowLeader:Activity xxx has leaked window com.android.internal.policy.impl.PhoneWindow$DecorView{xxxx} that was originally added here.</p>
</blockquote>
<p>原因，Activity销毁之前没有解除对Dialog等的引用，包括手动finish和切换横竖屏等。。</p>
<p>解决方法，在Activity的onDestroy中调用dialog.dismiss()；</p>
<h2 id="View-not-attached-to-window-manger"><a href="#View-not-attached-to-window-manger" class="headerlink" title="View not attached to window manger"></a>View not attached to window manger</h2><blockquote>
<p>异常中的关键字：java.lang.IllegalArgumentException：View not attached to window manager</p>
</blockquote>
<p>发生这类Exception的场景是，一个费事的线程任务，在任务开始的时候显示一个对话框，然后任务完了再销毁对话框，在此期间如果Activity因为某种原因被杀掉且又重新启动了，那么当dialog调用dismiss方法的时候WindowManager检查发现Dialog所属的Activity已经不存在了，所以会报View not attached to window mange。有关这个Crash的更详细描述，参见<a href="http://blog.csdn.net/yihongyuelan/article/details/9829313" target="_blank" rel="external">http://blog.csdn.net/yihongyuelan/article/details/9829313</a></p>
<p>要想避免此类Exception，就要正确使用对话框，也要正确使用线程，有以下几个点需要注意。</p>
<ol>
<li><p>正确使用对话框，不要再非UI线程使用对话框创建，显示，和取消对话框。对于异步操作显示对话框，Activity都有相应操作的回调，比如，onCreateDialog，showDialog，dismissDialog，removeDialog，这些都是Activity的方法，</p>
</li>
<li><p>一定要让对话框对象在Activity的可控制范围内和生命周期内，比如，对话框一定要死Activity的成员变量，并且让对话框活跃在Activity的onCreate和onDestroy之间。</p>
</li>
</ol>
<p>还有另外一种完美的解决方案，从派生SafeDialog，通过 复写dismiss方法，在dismiss方法执行之前判断Activity是否存在。</p>
<h2 id="窗体在不恰当的时候获取了焦点"><a href="#窗体在不恰当的时候获取了焦点" class="headerlink" title="窗体在不恰当的时候获取了焦点"></a>窗体在不恰当的时候获取了焦点</h2><blockquote>
<p>异常中的关键字：java.lang.NullPointerException:android.widget.PopupWindow$PopupViewContainer.dispatchKeyEvent</p>
</blockquote>
<p>这个问题是因为在PopupWindow显示之前，就把焦点赋予了它，这类问题只在Android2.3版本才会偶然出现，Android系统4.0的源码修改了方法，在底层对这个问题进行了规避。</p>
<p>但是对于2.3的android系统，解决方法是，在创建PopupWindow的时候不立即调用setFocusable(true),而是在showAtLocation后再调用setFocusable(true)，同时，在调用dismiss的时候调用setFocusable(false)。</p>
<p><strong>注意：PopupWindow调用setFocusable(true)是为了让它里面的控件能够实现监听事件。</strong></p>
<h2 id="token-null-is-not-for-an-application"><a href="#token-null-is-not-for-an-application" class="headerlink" title="token null is not for an application"></a>token null is not for an application</h2><blockquote>
<p>异常中的关键字：android.view.WindowManager$BadTokenException：Unable to add window – token null is not for an application </p>
</blockquote>
<p>在实现Android浮窗时，有时会包这个异常，根据以往的经验，出现这问题一般是我们的Context不正确，以下代码会报这个异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> AlertDialog.Builder(getApplicationContext());</div></pre></td></tr></table></figure></p>
<p>问题出在AlertDialog.Builder(mcontext)这句，所接受的参数不能使getApplicationContext()获得的Context，而应该是Activity实例，因为只有一个Activity才能添加一个窗体，</p>
<h2 id="permission-denied-for-this-window-type"><a href="#permission-denied-for-this-window-type" class="headerlink" title="permission denied for this window type"></a>permission denied for this window type</h2><blockquote>
<p>异常中的关键字：Android.view.WindowManger$BadTokenException:Unable to add window android.view.ViewRootImpl$W@411da608 – permission denied for this window type</p>
</blockquote>
<p>使用WindowManger.LayoutParams.TYPE_SYSTEM_ALERT涉及window type权限问题。这种错误多发生在使用WindowManager自定义弹出框时，没有设置权限。</p>
<p>解决方案是，在AndroidManifest.xml配置文件中添加一下两个uses-permission：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">&lt;!-- 显示系统窗口权限 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.SYSTEM_ALERT_WINDOW"</span>/&gt;</span></div><div class="line"><span class="comment">&lt;!-- 在频幕顶部显示addView --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.SYSTEM_OVERLAY_WINDOW"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="is-your-activity-running"><a href="#is-your-activity-running" class="headerlink" title="is your activity running"></a>is your activity running</h2><blockquote>
<p>异常中的关键字：android.view.WindowManager$BadTokenException:Unable to add window –token android.app.LocalActivityManager$LocalActivityRecord@45a58ee0 is not valid;is your activity running?</p>
</blockquote>
<p>这种Crash与弹出框密切相关，是由于ActivityA依附于另一个ActivityB的，当被依附的ActivityB产生错误的时候，ActivityA因为没有了靠山而产生错误（或者调用了一个已经被finish的Activity）。比如，在onCreate方法中，想要弹出PopupWindow，如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">		</div><div class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line">		PopupWindow popupWindow = <span class="keyword">new</span> PopupWindow(</div><div class="line">				getLayoutInflater().inflate(R.layout.grid_item, <span class="keyword">null</span>),</div><div class="line">				ViewGroup.LayoutParams.WRAP_CONTENT,</div><div class="line">				ViewGroup.LayoutParams.WRAP_CONTENT);</div><div class="line">		popupWindow.showAtLocation(findViewById(R.id.action_settings), </div><div class="line">				Gravity.CENTER, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">		popupWindow.update();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们看一下PopupWindow的showAtLocation方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> android.widget.PopupWindow.showAtLocation(View parent, <span class="keyword">int</span> gravity, <span class="keyword">int</span> x, <span class="keyword">int</span> y);</div></pre></td></tr></table></figure></p>
<p>当参数parent为空时，就会报上述的错误，说token为空，无效了由于PopupWindow要依赖于一个Activity，而activity的onCreate()还没执行完，因此就要让showAtLocation的调用再晚一点，，可以使用handler解决</p>
<h2 id="添加窗体失败"><a href="#添加窗体失败" class="headerlink" title="添加窗体失败"></a>添加窗体失败</h2><blockquote>
<p>异常中的关键字：java.lang.RuntimeException:Adding window failed at<br>              android.view.RootImpl.setView(ViewRootImpl.java:511) at<br>              android.view.WindowManagerImpl.addView(WindowManagerImpl.java:301) at …</p>
</blockquote>
<p>作者不能复现，智能在线上看到异常信息，不知道发生原因，也没有解决方案，检查Android系统源码，这个Crash是在ViewRoot的setView方法中捕获到的，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    res = sWindowSession.add(mWindow, MWindowAttribute,</div><div class="line">          getHostVisibility(), mAttachInfo.mContentInsets);</div><div class="line">&#125; <span class="keyword">catch</span>(RemoteException e) &#123;</div><div class="line">    mAdded = <span class="keyword">false</span>;</div><div class="line">    mView = <span class="keyword">null</span>;</div><div class="line">    mAttachInfo.mRootView = <span class="keyword">null</span>;</div><div class="line">    unscheduleTraversals();</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Adding windows failed"</span>, ex);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="AlertDialog-resolveDialogTheme"><a href="#AlertDialog-resolveDialogTheme" class="headerlink" title="AlertDialog.resolveDialogTheme"></a>AlertDialog.resolveDialogTheme</h2><blockquote>
<p>异常中的关键字：java.lang.NullPointerException at<br>              android.app.AlertDialog.resolveDialogTheme(AlertDialog,java:142) at<br>              android.app.AlertDialog$Builder.<init>(AlertDialog,java:359) at</init></p>
</blockquote>
<p>场景1：在B页面写了一个show方法，控制AlertDialog.Builder的弹出和隐藏，在A页面却要调用B页面的show方法</p>
<p>解决方案：</p>
<pre><code>1. 把ActivityB中的show方法，复制到A中
2. 把show方法放到BaseActivity中
3. 创建一个单独的类，把show方法转移过去，只需要传递正确的context参数即可。
</code></pre><p>场景2：在TabActivity中切换Tab时，容易产生这个Crash。这是因为，在new对话框的时候，参数context指定成this了，即指向当前子Activity的context，但子Activity是动态创建的，不能保证一直存在。其父Activity的context则是稳定存在的，所以把this替换为getParent()即可。</p>
<h2 id="The-specified-child-already-has-a-parent"><a href="#The-specified-child-already-has-a-parent" class="headerlink" title="The specified child already has a parent"></a>The specified child already has a parent</h2><blockquote>
<p>异常中的关键字：The specified child already has a parent.You must call removeView() on the childs parent first.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">	</div><div class="line">	LayoutInflater inflater = (LayoutInflater)getSystemService(LAYOUT_INFLATER_SERVICE);</div><div class="line">	RelativeLayout parent = (RelativeLayout)inflater.inflate(R.layout.activity_main, <span class="keyword">null</span>);</div><div class="line">	</div><div class="line">	<span class="comment">//setContentView(parent); 					这样是可以的</span></div><div class="line">	GridView gridView = (GridView)parent.findViewById(R.id.id_gridView);</div><div class="line">	setContentView(gridView);					<span class="comment">//这样会报上述Crash</span></div><div class="line">	</div><div class="line">	<span class="comment">/*加remove就可以了		</span></div><div class="line"> 		parent.removeView(gridView);</div><div class="line">	setContentView(gridView);  */</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>关于这个异常的分析，还有一篇文章<a href="http://blog.csdn.net/lissdy/article/details/8453433，作者不能复现，仅供参考" target="_blank" rel="external">http://blog.csdn.net/lissdy/article/details/8453433，作者不能复现，仅供参考</a></p>
<h2 id="子线程不能修改UI"><a href="#子线程不能修改UI" class="headerlink" title="子线程不能修改UI"></a>子线程不能修改UI</h2><blockquote>
<p>异常中的关键字：android.view.ViewRootImpl$CalledFrom Wrong ThreadException:Only the original thread that created a view hierarchy can touch its views</p>
</blockquote>
<p>首先，“子线程不能修改UI”是不准确的，作者认为在onCreate的时候，是requestLayout方法没有执行——layout布局文件还没有创建完成，导致我们还可以在onCreate方法内在其他子线程操作UI。但是网上有人认为，“线程能否刷新UI的关键在于ViewRoot是否属于该线程”，参见<a href="http://blog.csdn.net/imyfriend/article/details/6877959。" target="_blank" rel="external">http://blog.csdn.net/imyfriend/article/details/6877959。</a></p>
<p>解决方法：Handler，runOnUiThread(Runnable)，AsyncTask。</p>
<h2 id="不能再子线程操作AlertDialog和Toast"><a href="#不能再子线程操作AlertDialog和Toast" class="headerlink" title="不能再子线程操作AlertDialog和Toast"></a>不能再子线程操作AlertDialog和Toast</h2><blockquote>
<p>异常中的关键字：Cant create handler inside thread that has not called Looper.prepare()</p>
</blockquote>
<p>解决方案，使用Looper<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				Looper.prepare();</div><div class="line">				<span class="keyword">new</span> AlertDialog.Builder(TestActivity.<span class="keyword">this</span>).</div><div class="line">						setTitle(<span class="string">"title"</span>).</div><div class="line">						setMessage(<span class="string">"message"</span>).</div><div class="line">						setPositiveButton(<span class="string">"ok"</span>, <span class="keyword">null</span>).show();</div><div class="line">				Looper.loop();</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showAlertByRunnable</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> CharSequence text, <span class="keyword">final</span> <span class="keyword">int</span> duration)</span> </span>&#123;</div><div class="line">		Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</div><div class="line">		handler.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="keyword">new</span> AlertDialog.Builder(TestActivity.<span class="keyword">this</span>).</div><div class="line">				setTitle(<span class="string">"title"</span>).</div><div class="line">				setMessage(<span class="string">"message"</span>).</div><div class="line">				setPositiveButton(<span class="string">"ok"</span>, <span class="keyword">null</span>).show();</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h1 id="资源相关的异常"><a href="#资源相关的异常" class="headerlink" title="资源相关的异常"></a>资源相关的异常</h1><p>资源相关的异常，基本都容易解决。但是有一种情况非常恶心，就是明明apk包中有这个资源文件，但是仍然抛出该资源找不到的异常，对此我们只好认为是内存溢出（OOM）了。</p>
<h2 id="Resources-NotFoundException"><a href="#Resources-NotFoundException" class="headerlink" title="Resources$NotFoundException"></a>Resources$NotFoundException</h2><blockquote>
<p>异常中的关键字：android.content.res.Resources$NotFoundException:String resource ID..</p>
</blockquote>
<p>一般都是我们在setText()时候误将一个非资源ID的int型的值传入，解决方法是将该值转换为String，比如String.valueof(intValue)或者intValue+””；</p>
<blockquote>
<p>stackoverflowerror</p>
<p>异常中的关键字：stackoverflowerror</p>
</blockquote>
<p>发生的主要原因是Layout布局文件结构嵌套层次太深。我们应该尽量控制在5层以下。要经常使用Hierarchy View对其进行优化移除不必要的试图。</p>
<p>这种Crash的第二种原因是，在App退出的时候，如果App中有多个线程，那么在退出App的时候可能不能完全关闭App，即使使用finish方法也做不到，必须使用System.exit(0)这样的语句才可以。</p>
<p>无论是哪种情况导致的stackoverflowerror，都是由无限递归引起的。在JVM中有一个栈，预设了一个深度，当超出这个深度时，就会抛出stackoverflowerror。</p>
<h2 id="UnsatisfiedLinkError"><a href="#UnsatisfiedLinkError" class="headerlink" title="UnsatisfiedLinkError"></a>UnsatisfiedLinkError</h2><blockquote>
<p>异常中的关键字：java.lang. UnsatisfiedLinkError:dalvik.system.PathClassLoader….</p>
</blockquote>
<p>遇到这个Crash，肯定是so格式文件没有加载到，检查libs的armeabi目录下的so文件是否存在。此外不能只看armeabi文件夹，还要看x86目录，如果没有，在x86的设备上仍然不能运行。参见：<a href="http://www.cnblogs.com/devinzhang/archive/2012/02/29/2373729.html" target="_blank" rel="external">http://www.cnblogs.com/devinzhang/archive/2012/02/29/2373729.html</a></p>
<h2 id="InfiateException之FileNotFoundExceptin"><a href="#InfiateException之FileNotFoundExceptin" class="headerlink" title="InfiateException之FileNotFoundExceptin"></a>InfiateException之FileNotFoundExceptin</h2><p>异常中的关键字：Caused by: android.view.InfiateException:Binary XML file line #18:Error infiating class&lt;unkonwnat android.view.LayoutInfiater.createView Caused by:java.io.FileNotFoundException:</p>
<p>比较靠谱的说法是GC导致的，Activity销毁了但是里面涉及的资源文件没有被回收，于是便产生了内存泄露，但表现为FileNotFoundException。对此，解决方案是，在Activity的onStop方法中，手动释放每一张图片资源。详细信息，参见：<a href="http://blog.csdn.net/yiding_he/article/details/38597703" target="_blank" rel="external">http://blog.csdn.net/yiding_he/article/details/38597703</a></p>
<h2 id="InfiateException之缺少构造器"><a href="#InfiateException之缺少构造器" class="headerlink" title="InfiateException之缺少构造器"></a>InfiateException之缺少构造器</h2><blockquote>
<p>异常中的关键字： android.view.InfiateException:Binary XML file line #:Error infiating com.xxx.ccc…</p>
</blockquote>
<p>创建自定义View的时候，构造器不全会导致上述Crash。自定义控件若需要在xml文件中使用，就必须重写如下构造方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">	<span class="keyword">super</span>(context, attrs);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="InfiateException之style与android-textStyle的区别"><a href="#InfiateException之style与android-textStyle的区别" class="headerlink" title="InfiateException之style与android:textStyle的区别"></a>InfiateException之style与android:textStyle的区别</h2><blockquote>
<p>异常中的关键字：android.view.InfiateException:Binary XML file line #14:Error infiating class</p>
</blockquote>
<p>引用自定义style文件时，使用android:style 而不是 android:textStyle</p>
<h2 id="TransactionTooLargeException"><a href="#TransactionTooLargeException" class="headerlink" title="TransactionTooLargeException"></a>TransactionTooLargeException</h2><blockquote>
<p>异常中的关键字：android.view.InfiateException:Binary XML file line #14:Error infiating class</p>
</blockquote>
<p>官方文档里的解释是，Binder最大通常限制为1MB，如果大于1MB的话，就会抛出TransactionTooLargeException。</p>
<p>解决方法是：不要将大量数据传入Binder，比如说图片。</p>
<h1 id="系统碎片化相关异常"><a href="#系统碎片化相关异常" class="headerlink" title="系统碎片化相关异常"></a>系统碎片化相关异常</h1><p>这类Crash由两部分组成，一方面是和Android系统的版本不同有关，比如说在Android4.2的手机执行了Android5.0的语法；另一方面和ROM的不同有关，即使是相同的Android4.2版本，由于各个硬件厂商随意定制自己的ROM，改写其中的系统方法，那么就会表现为App的某个页面，不同手机看到不同的效果，甚至是崩溃。</p>
<h2 id="NoSuchMethodError"><a href="#NoSuchMethodError" class="headerlink" title="NoSuchMethodError"></a>NoSuchMethodError</h2><blockquote>
<p>异常中的关键字：java.lang.NoSuchMethodError </p>
</blockquote>
<p>在旧的版本上使用新的方法，会抛出此异常。</p>
<p>NoSuchMethodError异常，智能防范，不能根治，因为Android碎片化问题很严重。解决方案，在DailyBuild机器上准备不同版本的SDK，自动打包时，把App在这些SDK上都编译一遍；在开发阶段检查Android Lint，里面有被废弃的方法警告，谨慎使用；如果一定要是新方法或者废弃的旧方法，在使用时，要进行Android版本的判断。</p>
<h2 id="RemoteViews"><a href="#RemoteViews" class="headerlink" title="RemoteViews"></a>RemoteViews</h2><blockquote>
<p>异常中的关键字：android.widget.RemoteViews$RefiectionAction.writeToParcel(RemoteViews.java:763)</p>
</blockquote>
<p>RemoteViews一般使用在两个地方，一个是在AppWidget，另外一个是Notification。对于应用类App而言，有机会用到的是后者。比如说，App都有下载更新的功能，一般都是用AsyncTask来做，下载过程显示的进度条就是使用Notification，它有一个contentView属性，就是RemoteViews类型的，我们要为其设置2个很关键的值：</p>
<p>给ImageView绑定图片资源id<br>给TextView绑定字符串资源id</p>
<p>如下面的例子所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">notification.contentView = <span class="keyword">new</span> RemoteViews(context.getPackageName(), R.layout.activity_main);</div><div class="line">notification.contentView.setImageViewResource(R.id.tv, R.drawable.ic_launcher);</div><div class="line">notification.contentView.setProgressBar(R.id.btn, <span class="number">100</span>, <span class="number">0</span>, <span class="keyword">false</span>);</div><div class="line">notification.contentView.setTextViewText(R.id.tv, <span class="string">"正在更新。。。。"</span>);</div></pre></td></tr></table></figure></p>
<p>异常就是在绑定时出现的，而且有特定的情况：</p>
<ul>
<li>当你的Bitmap为null时，</li>
<li>当你的String为“”或者null时，</li>
<li>当Android版本是4.0.3和4.0.4时，</li>
</ul>
<p>如果Android版本时4.1以上的，则不会出现上述的异常</p>
<h2 id="pointerIndex-out-of-range"><a href="#pointerIndex-out-of-range" class="headerlink" title="pointerIndex out of range"></a>pointerIndex out of range</h2><blockquote>
<p>异常中的关键字：java.lang.IllegalArgumentException:pointerIndex out of range at android.view.MotionEvent.nativeGetAxisValue(Native Method)</p>
</blockquote>
<p>在做多点触控放大缩小，操作自己所绘制的图形时发生这个异常，如果是操作图片的放大缩小，多点触控不会出现这个错误。这个bug是android系统原因导致的，所以简单有效的办法是在绘图时捕获这个异常，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">spacing</span> <span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">	<span class="keyword">try</span>&#123;</div><div class="line">		x = event.getX(<span class="number">0</span>) - event.getX(<span class="number">1</span>);</div><div class="line">		y = event.getY(<span class="number">0</span>) - event.getY(<span class="number">1</span>);</div><div class="line">	&#125; <span class="keyword">catch</span>(IllegalArgumentException ex) &#123;</div><div class="line">		ex.printStackTrace();</div><div class="line">	&#125;</div><div class="line">       ......</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>另一种解决方案是：</p>
<ol>
<li>创建一个自定义View继承原View（可能是ScrollView，WebView，MapView等）</li>
<li>重新这个View的onInterceptTouchEvent和onTouchEvent方法。</li>
<li>为上述两个方法增加try…catch…语句，捕获已知异常</li>
</ol>
<h2 id="SecurityException之一：Intent图片太大"><a href="#SecurityException之一：Intent图片太大" class="headerlink" title="SecurityException之一：Intent图片太大"></a>SecurityException之一：Intent图片太大</h2><blockquote>
<p>异常中的关键字：Unable to find app for caller android.app.ApplicationThreadProxy@41868f10(pid=24370) when stopping service Intent {cmp=xxxx}</p>
</blockquote>
<p>在跳转Activity的过程中携带的extras中有Bitmap，应尽量减小传输图片的体积，或者通过保存图片到SD卡中或者通过URL方式传递图片参数；否则图片太大，就会报上述异常信息。一般而言，超过1MB的数据，就不要通过Intent来传递了。</p>
<h2 id="SecurityException之二：动态加载其他apk的Activity"><a href="#SecurityException之二：动态加载其他apk的Activity" class="headerlink" title="SecurityException之二：动态加载其他apk的Activity"></a>SecurityException之二：动态加载其他apk的Activity</h2><blockquote>
<p>异常中的关键字：java.lang. SecurityException:Given caller package com.xxx.xx is not running in process ProcessRecord ….</p>
</blockquote>
<p>如果在apk中使用了动态注册BroadCastReceiver，那么Luncher动态加载该apk时，就有肯能出现java.lang. SecurityException异常</p>
<p>相应的解决方法，修改之前注册BroadcastReceiver的地方，通过ContextHolder()来注册BroadcastReceiver，把APK重新部署验证，问题解决。<a href="http://blog.csdn.net/zhao_3546/article/details/11195881" target="_blank" rel="external">http://blog.csdn.net/zhao_3546/article/details/11195881</a></p>
<h2 id="SecurityException之三：No-permission-to-modify-thread"><a href="#SecurityException之三：No-permission-to-modify-thread" class="headerlink" title="SecurityException之三：No permission to modify thread"></a>SecurityException之三：No permission to modify thread</h2><blockquote>
<p>异常中的关键字：java.lang. SecurityException:No permission to modify given thread at<br>              android.os.Process.setThreadPriority(Native Method) at<br>              android..webkit.WebViewCore$WebCoreThread$1.handleMessage(WebViewCore.java:764)</p>
</blockquote>
<p>App经常会申请一些权限，而有些手机的ROM出于安全考虑，会禁止这些权限，那么当App使用到这些权限时，就会发生崩溃，相应的解决方法是，在执行某些安全相关的操作时，要么加if,要么使用try…catch…捕获这类异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">PackageManager pm = getPackageManager();</div><div class="line"><span class="keyword">boolean</span> hasPermission = pm.checkPermission(Manifest.permission.CALL_PHONE, </div><div class="line">		getPackageName()) == PackageManager.PERMISSION_GRANTED;</div><div class="line"><span class="keyword">if</span>(hasPermission) &#123;</div><div class="line">	Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_CALL,Uri.parse(<span class="string">"tel:13215464"</span>));</div><div class="line">	startActivity(intent);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="view的getDrawingCache-返回null"><a href="#view的getDrawingCache-返回null" class="headerlink" title="view的getDrawingCache()返回null"></a>view的getDrawingCache()返回null</h2><blockquote>
<p>异常中的关键字：java.lang.NullPointerException at<br>              android.view.View.buildDrawingCache(View.java:6578) at<br>              android.view.View.getDrawingCache(VIew.java:6428) at………..</p>
</blockquote>
<p>当背景图太大，超过了屏幕的大小，就会导致getDrawingCache()返回的结果是null，从而抛出NullPointerException 的异常。解决方法就是控制图片的大小，裁剪或者等比缩放。关于这个Crash的详细分析，参见<a href="http://zartzwj.iteye.com/blog/1098839" target="_blank" rel="external">http://zartzwj.iteye.com/blog/1098839</a></p>
<h2 id="DeadObjectException"><a href="#DeadObjectException" class="headerlink" title="DeadObjectException"></a>DeadObjectException</h2><blockquote>
<p>异常中的关键字：DeadObjectException</p>
</blockquote>
<p>在没有Root权限额时候，可以制造一个android.os.DeadObjectException，来重启Android设备。</p>
<h2 id="Android2-1不支持SSL"><a href="#Android2-1不支持SSL" class="headerlink" title="Android2.1不支持SSL"></a>Android2.1不支持SSL</h2><blockquote>
<p>异常中的关键字：java.lang.NullPointerException at<br>              android.webkit.SslErrorHandler.handleMessage</p>
</blockquote>
<p>Android2.1版本不支持SSL，所以发起https请求会导致崩溃，解决方案是调用https的网络请求时，先判断Android系统版本。</p>
<h2 id="ViewFlipper引发的血案"><a href="#ViewFlipper引发的血案" class="headerlink" title="ViewFlipper引发的血案"></a>ViewFlipper引发的血案</h2><blockquote>
<p>异常中的关键字：java.lang.IllegalArgumentException:Receiver not registered:<br>              android.widget.ViewFlipper$1@4083a4d0 at<br>              android.app.LoadedApk.foretReceiverDispatcher</p>
</blockquote>
<p>在Activity中使用ViewFlipper控件，进行横竖屏切换操作时就会发送这种异常。这是由于onDetachedFromWindow在onAttachedToWindow之前被调用所致。</p>
<p>业界公认的解决方法是，重写ViewFlipper的onDetachedFromWindow方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDetachedFromWindow</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="keyword">super</span>.onDetachedFromWindow();</div><div class="line">	&#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</div><div class="line">		stopFlipping();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="ActivityNotFoundException"><a href="#ActivityNotFoundException" class="headerlink" title="ActivityNotFoundException"></a>ActivityNotFoundException</h2><blockquote>
<p>异常中的关键字：android.content.ActivityNotFoundException:Unable to find explicit activity class {com.android.settings/com.android.settings.WirelessSettings};have you declared this activity in your AndroidManifest.xml?</p>
</blockquote>
<p>只有4.0以上才会出现这类错误，原因是，4.0以上把原来的打开网络设置方式舍弃了，如下修改代码可以解决这个问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//3.2以上打开设置页面</span></div><div class="line"><span class="comment">//也可以直接用ACTION_WIRELESS_SETTINGS打开到WiFi页面</span></div><div class="line"><span class="keyword">if</span>(Build.VERSION.SDK_INT &gt; <span class="number">13</span>) &#123;</div><div class="line">	startActivity(<span class="keyword">new</span> Intent(</div><div class="line">			android.provider.Settings.ACTION_SETTINGS));</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	startActivity(<span class="keyword">new</span> Intent(</div><div class="line">			android.provider.Settings.ACTION_WIRELESS_SETTINGS));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Android2-2不支持xlargsScreens"><a href="#Android2-2不支持xlargsScreens" class="headerlink" title="Android2.2不支持xlargsScreens"></a>Android2.2不支持xlargsScreens</h2><blockquote>
<p>异常中的关键字：No resource identifier found for attritute ‘xlargsScreens’ in package ‘android’</p>
</blockquote>
<p>错误出现在AndroidManifest.xml文件的supports-screens标记中，原因是xlargsScreens属性在API9（Android2.3）中才支持</p>
<p>解决方法：将Android2.2移除，添加Android2.3</p>
<h2 id="Packagemanager-has-died"><a href="#Packagemanager-has-died" class="headerlink" title="Packagemanager has died"></a>Packagemanager has died</h2><blockquote>
<p>异常中的关键字：Packagemanager has died at<br>              android.app.ApplicationPackageManager.getApplicationInfo(ApplicationPackageManager.java:123)</p>
</blockquote>
<p>PackageManager如果已经died，说明该进程不存在了，由于某些错误原因PackageManager进程已经退出，此时任何向他的请求都将失败，让设备重启可能是一个办法。还有一种情况是，App本身已经处于崩溃，这个时候如果App已经弹出错误匡，再调用PackageManager也会出错或卡死。</p>
<p>解决方案就是每次获取PackageManager的时候有try…catch…捕获异常。如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">	String channelId = getPackageManager().</div><div class="line">			getApplicationInfo(getPackageName(), PackageManager.GET_META_DATA)</div><div class="line">			.metaData.getString(<span class="string">"UMENG_CHANNEL"</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</div><div class="line">	e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="SpannableString与富文本字符串"><a href="#SpannableString与富文本字符串" class="headerlink" title="SpannableString与富文本字符串"></a>SpannableString与富文本字符串</h2><blockquote>
<p>异常中的关键字：java.lang.IndexOutOfBoundsException:setSpan(-1…-1) starts before 0 at<br>              android.text.SpannableStringBuilder.checkRange(SpannableStringBuilder.java:951) at …</p>
</blockquote>
<p>从上面的异常信息看，是SpannableString的setSpan方法越界，导致崩溃，但是我们没有使用这个方法。TextView钥匙的富文本恰好要被换行符阶段的时候，因为富文本使用SpannableString技术来显示，所以会报这种异常，所幸，这个Crash不是必现的，取决于机型，分辨率，字体大小，文字和样式等很多因素。</p>
<p>相应的解决方案是，在执行TextView的setText方法是，加上try…catch…语句捕获IndexOutOfBoundsException:setSpan。因为这种情况发生的概率极小，所以即使抛出异常，最多是不显示文本，也不会崩溃。</p>
<p>还有一种情况是，长按一段文本时，有些Android系统对于EditText的getSelectionStart方法，会返回-1，就会导致上述异常情抛出，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterTextChanged</span><span class="params">(Editable s)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(StrngUtils.isNullOrEmpty(s.toString())) &#123;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">int</span> editStart = mTxInput.getSelectionStart();</div><div class="line">	<span class="keyword">int</span> editEnd = mTxInput.getSelectionEnd();</div><div class="line">	mTxInput.removeTextChangedListener(<span class="keyword">this</span>);</div><div class="line">	<span class="keyword">while</span>((s.toString().length()) &gt; MAX_INPUT) &#123;</div><div class="line">		s.delete(editStart-<span class="number">1</span>, editEnd);</div><div class="line">		editStart --;</div><div class="line">		editEnd --;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用getSelectionStart方法获得值的时候，要判断这个值是否为-1；</p>
<h2 id="Can-not-perform-this-action-after-onSaveInstanceSate"><a href="#Can-not-perform-this-action-after-onSaveInstanceSate" class="headerlink" title="Can not perform this action after onSaveInstanceSate"></a>Can not perform this action after onSaveInstanceSate</h2><blockquote>
<p>异常中的关键字：java.lang.IllegalStateException:<br>              Can not perform this action after onSaveInstanceState at<br>              android.support.v4.app.FragmentMangerImpl.checkStateLoss(FragmentManager.java:1314)……<br>              android.support.v4.app.BackStackRecord.commit(BackStackRecord.java595)</p>
</blockquote>
<p>commit方法在Activity的onSaveInstanceSate之后调用就会出错，因为onSaveInstanceSate方法是Activity即将被销毁前调用，以保存Activity数据的，如果在保存状态之后给它添加Fragment就会出错。解决办法就是，把commit方法替换成commitAllowStateLoss。此外有时候按后退键触发onBackPressed方法也会引发类似的异常，网上有一篇文章分析了这类问题的发生原因和解决方案。<a href="http://zhiweiofli.iteye.com/blog/1539467" target="_blank" rel="external">http://zhiweiofli.iteye.com/blog/1539467</a></p>
<h2 id="Service-Intent-must-be-explicit"><a href="#Service-Intent-must-be-explicit" class="headerlink" title="Service Intent must be explicit"></a>Service Intent must be explicit</h2><blockquote>
<p>异常中的关键字：Service Intent must be explicit</p>
</blockquote>
<p>android在升级到5.0系统后会产生这样的崩溃，直接通过action启动service，就会导致这个问题，所以我们必须指定component或package才能避免这类问题，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">new</span> Intent();</div><div class="line">intent.setAction(<span class="string">"action name"</span>);</div><div class="line">intent.setPackage(getPackageName());</div><div class="line">context.startService(intent);</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/18/第六章：Crash异常分析——Java语法、Activity、序列化、列表相关的异常/" itemprop="url">
                  第六章：Crash异常分析——Java语法、Activity、序列化、列表相关的异常
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-18T22:56:35+08:00" content="2016-09-18">
              2016-09-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Android_读书笔记</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/App研发录/" itemprop="url" rel="index">
                    <span itemprop="name">App研发录</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Android之所以存在千奇百怪的Crash，主要归结于一下几种情况</p>
<ol>
<li>Android系统的碎片化。</li>
<li>MobileAPI返回了脏数据。</li>
<li>混淆时没有Keep要使用的类或者方法。</li>
</ol>
<h1 id="Java语法相关的异常"><a href="#Java语法相关的异常" class="headerlink" title="Java语法相关的异常"></a>Java语法相关的异常</h1><h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><blockquote>
<p>异常中的关键字：NullPointException</p>
</blockquote>
<ol>
<li>方法需要对传入的参数判空后再使用</li>
<li>对于外部接口调用，需要确保返回值不为空，甚至需要确保执行该接口不会抛出其他异常导致程序退出</li>
<li>尽量不要使用全局变量，具体参见3.5节“消灭全局变量”</li>
</ol>
<h2 id="角标越界"><a href="#角标越界" class="headerlink" title="角标越界"></a>角标越界</h2><blockquote>
<p>异常中的关键字：IndexOutOfBoundsExpection，StringIndexOutOfBoundsExpection，ArrayIndexOutOfBoundsExpection</p>
</blockquote>
<p>这类Crash也是由于程序的不严谨导致，解决方案是：</p>
<ol>
<li>在遍历一个数组/集合时，要预判数组/集合是否为空，长度是否大于0</li>
<li>在使用数组/集合中的元素时，要预判数组/集合长度是否有这么长</li>
<li>字符串也是数组，在使用subString(start ,end)这样的函数时要注意start或者end</li>
</ol>
<h2 id="试图调用一个空对象的方法"><a href="#试图调用一个空对象的方法" class="headerlink" title="试图调用一个空对象的方法"></a>试图调用一个空对象的方法</h2><blockquote>
<p>异常中的关键字：Attempt to invoke virtual method on a null object reference</p>
</blockquote>
<p>常见情况：</p>
<ul>
<li>在if…else..的一个分支中初始化对象，程序未走这个分支</li>
<li>在ActivityA中调用ActivityB的方法，为此在B中建立一个static变量，当这个变量被回收时</li>
<li>点击推送消息，根据事先定好的协议，跳过首页直接进入二级甚至三级页面，这是二级页面要使用首页某个对象</li>
</ul>
<h2 id="类型转换异常"><a href="#类型转换异常" class="headerlink" title="类型转换异常"></a>类型转换异常</h2><blockquote>
<p>异常中的关键字：ClassCastException：Class A cannot be cast to classB</p>
</blockquote>
<p>这类Crash都是由强制类型转换导致的，解决方案是，使用安全类型转换，参加第一章，1.6节</p>
<h2 id="数字转换错误"><a href="#数字转换错误" class="headerlink" title="数字转换错误"></a>数字转换错误</h2><blockquote>
<p>异常中的关键字：NumberFormatException</p>
</blockquote>
<p>在数据类型转换过程中，如果转换不成功，一般抛出ClassCastException：Class 的异常，只有一个例外情况，当字符型转换为数字失败时，会抛出NumberFormatException</p>
<p>这种情况多发生在服务器返回数据，没有按照约定返回整数而死字符串，客户端必须要事先考虑到这种情况，如果转换失败，必须有默认值而不是直接奔溃。</p>
<h2 id="声明数组时长度为-1"><a href="#声明数组时长度为-1" class="headerlink" title="声明数组时长度为-1"></a>声明数组时长度为-1</h2><blockquote>
<p>异常中的关键字：NegativeArraySizeException</p>
</blockquote>
<p>当使用负数创建数组时会抛出该异常，但程序员不会犯int arr = new int[-1]；这样低级的错误，后来，作者发现了下述语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String[] arg1 = <span class="keyword">new</span> String[args.length - <span class="number">1</span>];</div></pre></td></tr></table></figure></p>
<p>当args数组中没有元素时，就会出现该异常，此外，声明int arr = new int[0];并不会报错，只是毫无意义。在声明一个数组时，如果数组长度是由另外一个变量动态得到的，要保证[]中的值必须大于0.</p>
<h2 id="遍历集合同时删除其中元素"><a href="#遍历集合同时删除其中元素" class="headerlink" title="遍历集合同时删除其中元素"></a>遍历集合同时删除其中元素</h2><blockquote>
<p>异常中的关键字：ConcurrentModificationException</p>
</blockquote>
<p>但凡有点编程常识的程序员都知道在遍历一个集合时不能删除该集合中的元素，，，解决方案是，再定义一个delList，用来保存需要删除的对象，</p>
<p>还有另外一种情况产生这种崩溃，那就是在多个线程中修改和遍历同一个集和。解决方法是，使用Copy-On-Write容器</p>
<h2 id="比较器使用不当"><a href="#比较器使用不当" class="headerlink" title="比较器使用不当"></a>比较器使用不当</h2><blockquote>
<p>异常中的关键字：Comarison method violastes its general contract!</p>
</blockquote>
<p>Comparator，是基于插入排序算法与归并排序算法相结合的产物，信息信息<a href="http://blog.2baxb.me/archives/993" target="_blank" rel="external">http://blog.2baxb.me/archives/993</a> </p>
<p><strong>正确的用法：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">List&lt;Double&gt; list = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</div><div class="line">list.add(<span class="number">11.4</span>);</div><div class="line">list.add(<span class="number">12.4</span>);</div><div class="line">list.add(<span class="number">11.4</span>);</div><div class="line">list.add(<span class="number">11.7</span>);</div><div class="line">Collections.sort(list, comparator);</div><div class="line">   Comparator&lt;Double&gt; comparator = <span class="keyword">new</span> Comparator&lt;Double&gt;() &#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Double lhs, Double rhs)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span>(lhs &lt; rhs) &#123;</div><div class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (lhs &gt; rhs) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>错误用法:（忽略了相等的情况）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Double&gt; comparator = <span class="keyword">new</span> Comparator&lt;Double&gt;() &#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Double lhs, Double rhs)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> lhs &gt; rhs ? <span class="number">1</span> : -<span class="number">1</span>;</div><div class="line">	&#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>为了预防这类Crash发生，作者的解决方案是，对每个自定义比较器进行单元测试。</p>
<h2 id="当除数为0"><a href="#当除数为0" class="headerlink" title="当除数为0"></a>当除数为0</h2><blockquote>
<p>异常中的关键字：java.lang.ArithmeticException:divide by zero</p>
</blockquote>
<p>多发生在第三方控件中，比如GifView，注意其中moive的duration，这个值表示动画的持续时间，在接下来得代码中将会作为除数，如果为0就会抛出上述异常，这时候要将其默认值设置为1.</p>
<h2 id="不能随便使用的asList"><a href="#不能随便使用的asList" class="headerlink" title="不能随便使用的asList"></a>不能随便使用的asList</h2><blockquote>
<p>异常中的关键字：<br>    java.lang.UnsupportedOperationException<br>    java.util.AbstraactList.remove(AbstractList.java:144) at<br>    java.util.AbstraactList$Itr.remove(AbstractList.java:306) at<br>    java.util.AbstraactCollection.remove(AbstractCollection.java:252) at</p>
</blockquote>
<p>Arrays.asList()的返回值类型为java.util.Array$ArrayList，而不是ArrayList，他两的父类都是AbstractList，但是只有ArrayList实现了父类的add和remove。</p>
<h2 id="又有类找不到了（一）：ClassNotFoundException"><a href="#又有类找不到了（一）：ClassNotFoundException" class="headerlink" title="又有类找不到了（一）：ClassNotFoundException"></a>又有类找不到了（一）：ClassNotFoundException</h2><blockquote>
<p>异常中的关键字：ClassNotFoundException</p>
</blockquote>
<p>常见原因：</p>
<ul>
<li>Class.forName(“com.company.package.class”);</li>
<li>ClassLoader中的findClass(classname);</li>
<li>ClassLoader中的loadClass(classname);</li>
</ul>
<h2 id="又有类找不到了（二）：NoClassDefFoundException"><a href="#又有类找不到了（二）：NoClassDefFoundException" class="headerlink" title="又有类找不到了（二）：NoClassDefFoundException"></a>又有类找不到了（二）：NoClassDefFoundException</h2><blockquote>
<p>异常中的关键字：NoClassDefFoundException</p>
</blockquote>
<p>在B类中声明一个A类的实例，ClassA obj = new ClassA();</p>
<p>但是打包是A和B分别位于不同的dex中，这时如果A所在的dex吧A删除了，那么在运行时候执行到这句就会抛出NoClassDefFoundException</p>
<p>通常插件化编程的时候会牵扯到这个异常。</p>
<h1 id="Activity相关的异常"><a href="#Activity相关的异常" class="headerlink" title="Activity相关的异常"></a>Activity相关的异常</h1><h2 id="找不到Activity"><a href="#找不到Activity" class="headerlink" title="找不到Activity"></a>找不到Activity</h2><blockquote>
<p>异常中的关键字：android.content.ActivityNotFoundException:No Activity found to handle Intent{…}</p>
</blockquote>
<p>出错原因：</p>
<ol>
<li><p>Uri不是以http开头</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Uri uri = Uri.parse(<span class="string">"www.baidu.com"</span>);</div><div class="line">Intent intent  = <span class="keyword">new</span> Intent(Intent.Action_VIEW, uri);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure>
</li>
<li><p>当我们要打开SD卡上的一个HTML页面时，没有为Intent指定打开该HTML的浏览器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Uri uri = Uri.parse(<span class="string">"file://sdcard/104.html"</span>);</div><div class="line">Intent intent  = <span class="keyword">new</span> Intent(Intent.Action_VIEW, uri);</div><div class="line"><span class="comment">//此处指定系统自带浏览器包名和Activity名称</span></div><div class="line"><span class="comment">//intent.setClassName("com.android.browser","com.android.browser.BrowserActivity");</span></div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure>
</li>
<li><p>如果调用百度地图的openBaiduMapNavi方法导致的Crash，有可能是没有安装百度地图客户端</p>
</li>
</ol>
<h2 id="不能实例化Activity"><a href="#不能实例化Activity" class="headerlink" title="不能实例化Activity"></a>不能实例化Activity</h2><blockquote>
<p>异常中的关键字：java.lang.RuntimeException:Unable to instantiate activity ComponentInfo</p>
</blockquote>
<p>通常是因为没有在AndroidManifest.xml文件中注册该Activity，或者在创建完Activity后，修改了包名或者类名，而配置清单中没有修改，还有可能是系统处于异常状态，关机，内存不足等。。</p>
<h2 id="找不到Service"><a href="#找不到Service" class="headerlink" title="找不到Service"></a>找不到Service</h2><blockquote>
<p>异常中的关键字：java.lang.RuntimeException:Unable to instantiate service</p>
</blockquote>
<p>对于Manifest文件中写错的类似问题就不研究了。</p>
<p>首先检查代码中是否有Class.forName(“class1”)这样的语句，对于此，ProGuard会将class1混淆，从而找不到class1这个类。        </p>
<h2 id="不能启动BroadcastReceiver"><a href="#不能启动BroadcastReceiver" class="headerlink" title="不能启动BroadcastReceiver"></a>不能启动BroadcastReceiver</h2><blockquote>
<p>异常中的关键字：Unable to start receiver</p>
</blockquote>
<p>在使用Activity以外的context来startActivity，会抛出以上异常，<br>解决方法：  intent.addFlags(intent.FLAG_ACTIVITY_NEW_TASK);</p>
<p>作者这里提到了setFlags和addFlags，但是没有没有说两者的区别，这里我把源码贴出来<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">setFlags</span><span class="params">(<span class="keyword">int</span> flags)</span> </span>&#123;</div><div class="line">    mFlags = flags;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">addFlags</span><span class="params">(<span class="keyword">int</span> flags)</span> </span>&#123;</div><div class="line">    mFlags |= flags;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>作者推荐<a href="http://www.it165.net/pro/html/201406/15547.html" target="_blank" rel="external">http://www.it165.net/pro/html/201406/15547.html</a></p>
<h2 id="startActivityForResult不能回传"><a href="#startActivityForResult不能回传" class="headerlink" title="startActivityForResult不能回传"></a>startActivityForResult不能回传</h2><blockquote>
<p>异常中的关键字：Failure delivering result ResultInfo{who=null,request=0,result=-1}</p>
</blockquote>
<p>导致原因：传回来的key是A，但是却按照B这个key来取值</p>
<h2 id="猴急的Fragment"><a href="#猴急的Fragment" class="headerlink" title="猴急的Fragment"></a>猴急的Fragment</h2><blockquote>
<p>异常中的关键字：Fragment not attached to Activity</p>
</blockquote>
<p>导致原因：Fragment还没有Attach到Activity时，调用了诸如getResource这样的方法。</p>
<p>解决方法：加isAdded判断<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(isAdded) &#123;</div><div class="line">    getResources().getString(R.string.app_name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="序列化相关的异常"><a href="#序列化相关的异常" class="headerlink" title="序列化相关的异常"></a>序列化相关的异常</h1><p>Android中的序列化分两种，一种是Java原生的Serializable，另一种是Android为了提升性能而量身打造的Parcelable。</p>
<h2 id="实体对象不支持序列化"><a href="#实体对象不支持序列化" class="headerlink" title="实体对象不支持序列化"></a>实体对象不支持序列化</h2><blockquote>
<p>异常中的关键字：Parcelable encountered IOException writing serializable object </p>
</blockquote>
<p>不仅类自身要实现Serializable/Parcelable，类中的成员变量也要支持序列化<br>提示：JSONObject，JSONArray不支持序列化。</p>
<h2 id="序列化时未指定ClassLoader"><a href="#序列化时未指定ClassLoader" class="headerlink" title="序列化时未指定ClassLoader"></a>序列化时未指定ClassLoader</h2><blockquote>
<p>异常中的关键字：BadParcelableException:</p>
</blockquote>
<p>在使用Parcelable机制的时候，会遇到上述异常，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyParcelable</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String mStr;</div><div class="line">    <span class="keyword">private</span> ClassA a;</div><div class="line">    ......</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyParcelable</span><span class="params">(Parcel in)</span> </span>&#123;</div><div class="line">        mStr = in.readString();</div><div class="line">        a = in.readParcelable(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>崩溃出在最后一句，对a的反序列化上，改为 a= in.readParcelable(ClassA.class.getClassLoader());就不会崩溃了。</p>
<p><strong>ClassLoader的概念：</strong></p>
<p>当ClassLoader为空时，系统会采用默认的ClassLoader。</p>
<p>Android有两种不同的ClassLoader：framework ClassLoader和apk ClassLoader，其中framework ClassLoader只知道怎么加载Android系统内部的类，apk ClassLoader即知道怎么加载我们自己写的类，也知道怎么加载Android系统内部的类。</p>
<p>在App刚启动的时候，默认ClassLoader是apk ClassLoader，但在系统内存不足应用被系统回收再次启动，默认的ClassLoader会变为framework ClassLoader，所以对我们自己的类会报ClassNotFoundException。</p>
<h2 id="反序列化时发现类找不到：被ProGuard混淆导致的崩溃"><a href="#反序列化时发现类找不到：被ProGuard混淆导致的崩溃" class="headerlink" title="反序列化时发现类找不到：被ProGuard混淆导致的崩溃"></a>反序列化时发现类找不到：被ProGuard混淆导致的崩溃</h2><blockquote>
<p>异常中的关键字：Parcelable encountered ClassNotFoundException reading a Serializable object…..</p>
</blockquote>
<p>ProGuard对于Class.forName(className)中的class是无能为力的，它会将这个class混淆的面目全非，于是在反序列化这个类的时候却发现找不到这个类了</p>
<p>解决方案：在ProGuard文件中keep这个类</p>
<h2 id="反序列化出错"><a href="#反序列化出错" class="headerlink" title="反序列化出错"></a>反序列化出错</h2><blockquote>
<p>异常中的关键字：Could not read input Chanel file descriptors from parcel …..</p>
</blockquote>
<p>出现这个异常，一般是因为Intent传递的数据太大了，貌似大于1MB就会崩溃。</p>
<p>此外，网上也有人说是因为FileDescripter太多而且没有关闭，或looper太多没有退出而导致的，仅供参考。</p>
<h1 id="列表相关的异常"><a href="#列表相关的异常" class="headerlink" title="列表相关的异常"></a>列表相关的异常</h1><p>在有Adapter的地方就有ListView，就有因此而产生的异常。这些异常基本是因为下拉刷新数据时处理不当导致的。这主要是Android本身没有提供标准的下拉刷新数据的列表控件，而网上的千奇百怪的下拉刷新控件有都有这样那样的缺陷。分装的再完善的下拉刷新列表空间，也只能确保在大部分急性上工作良好。</p>
<h2 id="Adapter数据源变化但是没有通知ListView"><a href="#Adapter数据源变化但是没有通知ListView" class="headerlink" title="Adapter数据源变化但是没有通知ListView"></a>Adapter数据源变化但是没有通知ListView</h2><blockquote>
<p>异常中的关键字：The content of the adapter has changed but ListView did not receive a notification.Make sure the content of your adapter is not modified from a background thread,but only from the UI thread.</p>
</blockquote>
<p>就是说Adapter内部变化了，但是没哟通知相应的ListView，请保证Adapter的数据在主线程修改。</p>
<p>解决方案：</p>
<p>首先，一种极端的方案是，每次设置Adapter中的集合数据时，都要将其clone一份，而不是直接传递一个集合过来，但是这样会比较消耗性能。</p>
<p>其次，要确保每次在Activity中设置adapter的值，而不是在后台线程，有以下几种办法：</p>
<ol>
<li><p>调用Activity的runOnUIThread()方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">    <span class="keyword">new</span> Thread()&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">            MainActivity.<span class="keyword">this</span>.runOnUiThread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    textView1.setText(<span class="string">"Hello World!"</span>);   </div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>调用Handler，通知主线程修改Adapter，</p>
</li>
<li><p>使用AsyncTask也是一个不错的选择，虽然他也有很多缺陷</p>
</li>
</ol>
<p>最后，只要修改了adapter机集合数据的值，就要马上调用notifyDataSetChanged方法。</p>
<h2 id="ListView滚动时点击刷新按钮后崩溃"><a href="#ListView滚动时点击刷新按钮后崩溃" class="headerlink" title="ListView滚动时点击刷新按钮后崩溃"></a>ListView滚动时点击刷新按钮后崩溃</h2><blockquote>
<p>异常中的关键字：java.lang.IndexOutOfBoundsException:Invalid index….                               java.util.ArrayList.throwIndexOutOfBoundsException<br>java.util.ArrayList.get(ArrayList.java:304) at android.widget.HeaderViewListAdapter.getView(HeaderViewListAdapter.java225)  </p>
</blockquote>
<p>ListView滚动的时候，表示它已经获取了adapter的getCounts()，可能是30或者更大，回调getView(),这时候将数据clear掉了，所以奔溃</p>
<p>解决方案是，ListView滚动的时候，将刷新按钮设置为可以点击，如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> refresh&#123;</div><div class="line">    startLocation()；</div><div class="line">    pageNo = <span class="number">0</span>;</div><div class="line">    hasMore = <span class="keyword">true</span>;</div><div class="line">    dataList.clear();</div><div class="line">    moreBtn.setVisibility(View.GONE);</div><div class="line">    loadFirstPageData();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="AbsListView的obtainView返回空指针"><a href="#AbsListView的obtainView返回空指针" class="headerlink" title="AbsListView的obtainView返回空指针"></a>AbsListView的obtainView返回空指针</h2><blockquote>
<p>异常中的关键字：java.lang.NullPointerException at android.widget.AbsListView.obtainView(AbsListView.java:1521)at android.widget.ListView.makeAndAddView</p>
</blockquote>
<p>导致空指针的罪魁祸首就是AbsListview的obtainView方法获取不到View，究其原因，是getView方法在某些时候返回了null。解决方案很简单，getView的第二个参数是不会为null的，在getView返回值的时候判断一下是否为空，如果为null，怎返货convertView。</p>
<h2 id="Adapter数据源变化但是没有调用notifyDataSetChanged"><a href="#Adapter数据源变化但是没有调用notifyDataSetChanged" class="headerlink" title="Adapter数据源变化但是没有调用notifyDataSetChanged"></a>Adapter数据源变化但是没有调用notifyDataSetChanged</h2><blockquote>
<p>异常中的关键字：The applications PagerAdapter changed the adapters contents without calling PagerAdapter#notifyDataSetChanged</p>
</blockquote>
<p>PagerAdapter对于notifyDataSetChanged()和getCount的执行顺序是非常严格的，系统跟踪count的值，如果这个值和getCount返回的值不一致，就会抛出这个异常。所以为了保证getCount总是返回一个正确的值，那么在初始化ViewPager时，应先给adapter初始化内容后再将该adapter传给ViewPager，如果不这样处理，在更新adapter的内容后，应该调用一下notifyDataSetChanged。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/17/第五章：Crash异常收集与统计/" itemprop="url">
                  第五章：Crash异常收集与统计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-17T22:24:00+08:00" content="2016-09-17">
              2016-09-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Android_读书笔记</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/App研发录/" itemprop="url" rel="index">
                    <span itemprop="name">App研发录</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>Crash分析三部曲：收集，统计，分析</strong></p>
</blockquote>
<h1 id="异常收集"><a href="#异常收集" class="headerlink" title="异常收集"></a>异常收集</h1><p>设计一个CrashHandler，使之继承UncaugthExceptionHandler，来定义我们自己的异常捕获逻辑，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.Thread.UncaughtExceptionHandler;</div><div class="line"><span class="keyword">import</span> android.os.Environment;</div><div class="line"><span class="keyword">import</span> android.os.Looper;</div><div class="line"><span class="keyword">import</span> android.util.Log;</div><div class="line"><span class="keyword">import</span> android.widget.Toast;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrashHandler</span> <span class="keyword">implements</span> <span class="title">UncaughtExceptionHandler</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"CrashHandler"</span>;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String APP_CACHE_PATH = </div><div class="line">			Environment.getExternalStorageDirectory().getPath() + <span class="string">"/crash/"</span>;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread thread, Throwable ex)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span>(handeException(ex) &amp;&amp; mDefaultHander != <span class="keyword">null</span>) &#123;</div><div class="line">			mDefaultHander.uncaughtException(thread, ex);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				Thread.sleep(<span class="number">3000</span>);</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				Log.e(TAG, <span class="string">"error"</span>, e);</div><div class="line">			&#125;</div><div class="line">			android.os.Process.killProcess(android.os.Process.myPid());</div><div class="line">			System.exit(<span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">handeException</span><span class="params">(Throwable ex)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span>(<span class="keyword">null</span> == ex) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//把Crash发送到服务器</span></div><div class="line">		sendCrashToServer();</div><div class="line">		</div><div class="line">		<span class="comment">//使用Toast来显示异常信息</span></div><div class="line">		<span class="keyword">new</span> Thread() &#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				Looper.prepare();</div><div class="line">				Toast.makeText(context, <span class="string">"很抱歉，程序出现异常，即将退出。"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">				Looper.loop();</div><div class="line">			&#125;;</div><div class="line">		&#125;.start();</div><div class="line">		</div><div class="line">		<span class="comment">//保存日志文件</span></div><div class="line">		saveCrashInfoFile(ex);</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sendCrashToServer方法负责将捕获的异常发送到服务器，为此需要MobileAPI提供一个接口，建表存储接受的数据</p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>自增id</td>
</tr>
<tr>
<td>app_name</td>
<td>Crash所在App</td>
</tr>
<tr>
<td>page_name</td>
<td>Crash所在Activity</td>
</tr>
<tr>
<td>exception_name</td>
<td>Crash名称</td>
</tr>
<tr>
<td>exception_stack</td>
<td>Crash详细信息</td>
</tr>
<tr>
<td>crash_type</td>
<td>1表示崩溃，0表示被try-catch捕获到</td>
</tr>
<tr>
<td>app_version</td>
<td>当前App版本</td>
</tr>
<tr>
<td>os_vesion</td>
<td>Android系统版本</td>
</tr>
<tr>
<td>devic_model</td>
<td>Android设备型号</td>
</tr>
<tr>
<td>device_id</td>
<td>Android设备编号</td>
</tr>
<tr>
<td>network_type</td>
<td>网络类型，是否为wifi</td>
</tr>
<tr>
<td>channel_id</td>
<td>渠道号</td>
</tr>
<tr>
<td>clien_type</td>
<td>设备类型，Android/IOS</td>
</tr>
<tr>
<td>memory_info</td>
<td>Crash发生时内存使用情况</td>
</tr>
<tr>
<td>crash_time</td>
<td>Crash发生时间，在插入数据库是由系统自动生成</td>
</tr>
</tbody>
</table>
<p>需要注意的是，如果异常在Activity中被捕获到，就不会再交由Application级别的CrashHandler处理，所以我们要在这个Activity的try…catch…语句中手动吧异常信息发送到服务器。在具体的Activity中，将CrashType设置为0；在Crash中景CrashType设置为1。</p>
<h1 id="异常的收集与统计"><a href="#异常的收集与统计" class="headerlink" title="异常的收集与统计"></a>异常的收集与统计</h1><p>目前对APP线上Crash的收集一般有2中，要么记录到第三方平台，要么记录到自己的数据库。使用第三方平台的好处是，他们能提供一套完整的Crash分类和报表统计工具。比如腾讯的Bugly平台。</p>
<p><strong>人工统计线上Crash数据</strong></p>
<p>作者在分析中发现：</p>
<ol>
<li>有很多重复的Crash，这其中分很多种情况：<ul>
<li>有不同设备在不同时间发出来重复的Crash</li>
<li>有不同设备在同一时间法宠重复的Crash</li>
<li>相同设备在很短时间段内频繁发送了重复的Crash</li>
</ul>
</li>
<li>每笔异常信息都包括了以下2个部分数据信息<ul>
<li>exception_name：Crash对应的异常名称</li>
<li>exception_stack：Crash的详细信息，Cash真正原因所在</li>
</ul>
</li>
<li>exception_stack中含有OutOfMemory内容的，都是内存已溢出导致的，但是逆命题不成立！</li>
<li>对于NullPointerException，我们要留意exception_stack中Cause by后面的内容</li>
<li>窗体泄露类问题，基本都是想要关闭弹出框的时候，却发现它的载体宿主已经不在。</li>
<li>ListView和Adapter相关的Crash基本都发生在分页获取数据的场景，数据源改变，却没有及时通知ListView和Adap</li>
</ol>
<p><strong>第一个线上Crash报表：Crash分类</strong></p>
<ol>
<li>首先，每天上班，把昨天24小时的Crash数据下载，导出为excel文件，然后还原到本地数据库CrashDB这个表。</li>
<li>把Crash分类，为CrashDB加一个字段crash_desc，用来表明Crash是哪个类别的。UpdateCrashStore</li>
<li>统计各类Crash。GroupOnlineCrash</li>
</ol>
<p><a href="http://www.cnblogs.com/Jax/p/4573575.html" title="详细代码" target="_blank" rel="external">详细代码</a></p>
<p><strong>第二个线上Crash报表：Crash去重</strong></p>
<ol>
<li>去除数字不同导致的重复</li>
</ol>
<ul>
<li>发生奔溃时的代码行不同</li>
<li>运行时的数值不同</li>
<li>在CrashDB表再添加一个字段dis_info，把exception_desc字段的数据复制到dis_info，然后修改dis_info,借助正则表达式，进行批量替换</li>
</ul>
<ol>
<li>去除其他情况的重复<br>　　有很多Crash信息，它们仅仅是长度不同，解决方案是，对exception_stack从起始位置去150个字符去重（150来自实践）。</li>
<li>去除同一版本之前的重复<br>　　包今天的线上Crash放到一个数据表CrashStore中，对于第二天的线上Crash，先到CrashStore中去重，剩下的Crash数据就是新的。</li>
<li>按照Activity，把Crash自动分发到人</li>
</ol>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/Crash%E5%88%86%E5%8F%91.png" alt="Crash分发流程"></p>
<p><strong>线上Crash的其他分析工作</strong></p>
<ol>
<li>Crash进行归纳，从而知道每类Crash发生的次数，涉及的机型，涉及的Android系统版本</li>
<li>目前第三方平台的Crash统计工具是即时的，，而不是要等到一天结束后才一起进行分析</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/14/第四章：Android命名规范和编码规范/" itemprop="url">
                  第四章：Android命名规范和编码规范
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-14T22:31:06+08:00" content="2016-09-14">
              2016-09-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Android_读书笔记</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/App研发录/" itemprop="url" rel="index">
                    <span itemprop="name">App研发录</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>制定规范不需要太多的理论知识，只要记住两点就够了：尽量简单，多写注释！</p>
</blockquote>
<p><strong>但是也很多人认为注释是越少也好，我更赞同，当然这是建立在你的代码非常容易理解的基础之上！！</strong></p>
<h1 id="Android命名规范"><a href="#Android命名规范" class="headerlink" title="Android命名规范"></a>Android命名规范</h1><h2 id="Java类文件命名规范"><a href="#Java类文件命名规范" class="headerlink" title="Java类文件命名规范"></a>Java类文件命名规范</h2><ul>
<li>Activity：以Activity作为后缀，比如PersonActivity。</li>
<li>Adapter：以Adapter作为后缀，比如PersonAdapter。</li>
<li>Entity：大多以Entity作为后缀，比如PersonEntity，值得注意的是User是全局变量，不算是实体，不受此约束。</li>
</ul>
<h2 id="资源文件命名规范"><a href="#资源文件命名规范" class="headerlink" title="资源文件命名规范"></a>资源文件命名规范</h2><p><strong>layout目录下的文件</strong></p>
<ul>
<li>页面布局文件，以act_为前缀，Activity所在Package为中缀，Activity名称（去掉Activity）作为后缀，都是小写。例如Person模块下AddCustomerActivity对应的layout文件该是：act_person_addcustomer，不过我自己习惯activity_add_customer；</li>
<li>ListView中的item布局文件，以item_为前缀，列表项的名称为后缀，如item_users;</li>
<li>Dialog布局文件，以dlg_为前缀，Dialog的功能名称为后缀，如dlg_hint，我还是习惯dialog_hint。</li>
</ul>
<p><strong>drawable（或者mipmap）目录下文件命名规范：</strong></p>
<ul>
<li>drawable目录下的资源，大部分是图片，此外，还有一部分xml文件。无论是图片还是xml文件，都应该遵循以下的命名规范：</li>
<li>对于只在一个页面使用的资源，就以该页面的名称做前缀。</li>
<li>对于只在一个模块下多个页面是用的资源，就以该模块的名称作为前缀，</li>
<li>对于在各个模块，各个页面都有可能使用的资源，比如上导航，下导航，，以common最为前缀。</li>
</ul>
<h2 id="Java类中控件对象命名规范"><a href="#Java类中控件对象命名规范" class="headerlink" title="Java类中控件对象命名规范"></a>Java类中控件对象命名规范</h2><p>控件类型缩写+控件逻辑名称，如btnLogin</p>
<h2 id="Layout中控件对象命名规范"><a href="#Layout中控件对象命名规范" class="headerlink" title="Layout中控件对象命名规范"></a>Layout中控件对象命名规范</h2><ul>
<li>形式一：和Activity中对应的控件名保持一致</li>
<li>形式二：功能名_控件类型，如login_button</li>
</ul>
<p>我还是习惯btn_login</p>
<h2 id="strings-xml中常量命名规范"><a href="#strings-xml中常量命名规范" class="headerlink" title="strings.xml中常量命名规范"></a>strings.xml中常量命名规范</h2><p>出现在Activity或者Layout中的，Activity名作为前缀，后面接控件名称，在后面随意例如loginActivity_btnLogin_text(我不习惯这样的。。)，如果涉及和公共模块相关，则以common做前缀</p>
<h2 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h2><p>遵循Java的命名规范，只包含字母和下划线，字母全部大写，单词之间用下划线隔开</p>
<h1 id="Android编码规范"><a href="#Android编码规范" class="headerlink" title="Android编码规范"></a>Android编码规范</h1><ol>
<li>要分门别类的存放各种类，</li>
<li><p>findViewById，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">TextView tvName;</div><div class="line">initView() &#123;</div><div class="line">    tvName = (TextView) findViewById(R.id.tv_name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Layout中的常量，要在strings.xml中定义，</p>
</li>
<li>Layout中所有控件的字体大小，都定义在dinens.xml中</li>
<li>在Activity中定义新的生命周期<ul>
<li>initVariables：初始化变量，包括Intent带的数据和Activity内的变量</li>
<li>initViews：加载Layout布局文件，初始化控件，为控件挂上事件的方法</li>
<li>loadData：获取数据</li>
</ul>
</li>
<li>坚持使用fastJSON自定义实体来作为MobileAPI的数据载体（不知道为什么不提GSON。。）<br>像JSONObject，JSONArray，Map<string, object="">，ArrayList&lt; Object&gt;,这些不能序列化的实体，都禁止使用，除非仅仅是在方法内部。</string,></li>
<li>页面之间传值，坚持使用Intent携带序列化实体数据的方式，禁止为了方便使用全局变量</li>
<li>为控件添加事件，使用匿名内部类</li>
<li>Activity中不要嵌套内部类，</li>
<li>Adapter的编码规范<ul>
<li>所有Adapter，都放在adapter这个包中</li>
<li>Adapter绑定的数据，一律为ArrayList&lt;自定义可序列化实体&gt;</li>
<li>在Adapter中创建适合于列表自身的ViewHolder实体类，统一命名为ViewHolder</li>
</ul>
</li>
<li>实体类不要再不同模块之间共享，但是可以在同一模块的不同页面之间共享</li>
<li>为了节省内存，可以使用ArrayList而不是HashMap</li>
<li>大量的图片，使用ImageLoader或者Fresco来进行异步加载</li>
<li>什么时候使用SharedPreferences？简单配置信息，设置页面的各种开关。但是对于复杂的对象，还是要存储到本地文件中。</li>
<li>尽量使用ApplicationContext代替Context，否则会引起内存泄露，当然也不是任何地方都适用。</li>
<li>数据类型转换一定要进行验证。</li>
<li>使用常量代替枚举，</li>
</ol>
<h1 id="统一代码格式"><a href="#统一代码格式" class="headerlink" title="统一代码格式"></a>统一代码格式</h1><p>在Eclipse中导入Android源码中用于统一代码格式的android-formatting.xml，然后执行快键键Ctrl+shift+f，</p>
<p>导入方法如下：window–preference–Java–code style–Formatter 导入android-formatting.xml</p>
<p>推荐一个自动检查工具，checkstyle，</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/13/理解Android编译命令/" itemprop="url">
                  理解Android编译命令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-13T23:21:50+08:00" content="2016-09-13">
              2016-09-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Other/" itemprop="url" rel="index">
                    <span itemprop="name">Other</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://gityuan.com/2016/03/19/android-build/" target="_blank" rel="external">TokgoLiang——转载别人的原文链接一定要写在开头</a></p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>关于Android Build系统，这个话题很早就打算整理下，迟迟没有下笔，决定跟大家分享下。先看下面几条指令，相信编译过Android源码的人都再熟悉不过的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">source</span> setenv.sh</div><div class="line">lunch</div><div class="line">make -j12</div></pre></td></tr></table></figure>
<p>记得最初刚接触Android时，同事告诉我用上面的指令就可以编译Android源码，指令虽短但过几天就记不全或者忘记顺序，每次编译时还需要看看自己的云笔记，冰冷的指令总是难以让我记忆。后来我决定认真研究下这个指令的含义。知其然还需知其所以然，这样能更深层次的理解并记忆，才能与自身的知识体系建立强连接，或许还有意外收获，果然如此，接下来跟大家分享一下在研究上述几条指令含义的过程中，深入了解到的Android Build(编译)系统。</p>
<h1 id="编译命令"><a href="#编译命令" class="headerlink" title="编译命令"></a>编译命令</h1><p>准备好编译环境后，编译Android源码的第一步是 <em>source build/envsetup.sh</em>，其中source命令就是用于运行shell脚本命令，功能等价于”.”，因此该命令也等价于<em>. build/envsetup.sh</em>。在文件<em>envsetup.sh</em>声明了当前会话终端可用的命令，这里需要注意的是当前会话终端，也就意味着每次新打开一个终端都必须再一次执行这些指令。起初并不理解为什么新开的终端不能直接执行make指令，到这里总算明白了。</p>
<p>接下来，解释一下本文开头的引用的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">source</span> setenv.sh  //初始化编译环境，包括后面的lunch和make指令</div><div class="line">lunch  //指定此次编译的目标设备以及编译类型</div><div class="line">make  -j12 //开始编译，默认为编译整个系统，其中-j12代表的是编译的job数量为12。</div></pre></td></tr></table></figure>
<p>所有的编译命令都在<em>envsetup.sh</em>文件能找到相对应的function，比如上述的命令<em>lunch</em>，<em>make</em>，在文件一定能找到</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">lunch</span></span>()&#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">make</span></span>()&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>source envsetup.sh</em>，需要cd到setenv.sh文件所在路径执行，路径可能在build/envsetup.sh，或者integrate/envsetup.sh，再或者不排除有些厂商会封装自己的.sh脚本，但核心思路是一致的。</p>
<p>具体实现这里就不展开说明，下面精炼地总结了一下各个指令用法和功效。</p>
<h2 id="代码编译"><a href="#代码编译" class="headerlink" title="代码编译"></a>代码编译</h2><table>
<thead>
<tr>
<th>编译指令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>m</td>
<td>在源码树的根目录执行编译</td>
</tr>
<tr>
<td>mm</td>
<td>编译当前路径下所有模块，但不包含依赖</td>
</tr>
<tr>
<td>mmm [module_path]</td>
<td>编译指定路径下所有模块，但不包含依赖</td>
</tr>
<tr>
<td>mma</td>
<td>编译当前路径下所有模块，且包含依赖</td>
</tr>
<tr>
<td>mmma [module_path]</td>
<td>编译指定路径下所有模块，且包含依赖</td>
</tr>
<tr>
<td>make [module_name]</td>
<td>无参数，则表示编译整个Android代码</td>
</tr>
</tbody>
</table>
<p>下面列举部分模块的编译指令：</p>
<table>
<thead>
<tr>
<th>模块</th>
<th>make命令</th>
<th>mmm命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>init</td>
<td>make init</td>
<td>mmm system/core/init</td>
</tr>
<tr>
<td>zygote</td>
<td>make app_process</td>
<td>mmm frameworks/base/cmds/app_process</td>
</tr>
<tr>
<td>system_server</td>
<td>make services</td>
<td>mmm frameworks/base/services</td>
</tr>
<tr>
<td>java framework</td>
<td>make framework</td>
<td>mmm frameworks/base</td>
</tr>
<tr>
<td>framework资源</td>
<td>make framework-res</td>
<td>mmm frameworks/base/core/res</td>
</tr>
<tr>
<td>jni framework</td>
<td>make libandroid_runtime</td>
<td>mmm frameworks/base/core/jni</td>
</tr>
<tr>
<td>binder</td>
<td>make libbinder</td>
<td>mmm frameworks/native/libs/binder</td>
</tr>
</tbody>
</table>
<p>上述mmm命令同样适用于mm/mma/mmma，编译系统采用的是增量编译，只会编译发生变化的目标文件。当需要重新编译所有的相关模块，则需要编译命令后增加参数-B，比如make -B [module_name]，或者 mm -B [module_path]。</p>
<p>Tips:</p>
<ul>
<li>对于m、mm、mmm、mma、mmma这些命令的实现都是通过make方式来完成的。</li>
<li>mmm/mm编译的效率很高，而make/mma/mmma编译较缓慢；</li>
<li>make/mma/mmma编译时会把所有的依赖模块一同编译，但mmm/mm不会;</li>
<li>建议：首次编译时采用make/mma/mmma编译；当依赖模块已经编译过的情况，则使用mmm/mm编译。</li>
</ul>
<h2 id="代码搜索"><a href="#代码搜索" class="headerlink" title="代码搜索"></a>代码搜索</h2><table>
<thead>
<tr>
<th>搜索指令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>cgrep</td>
<td>所有C/C++文件执行搜索操作</td>
</tr>
<tr>
<td>jgrep</td>
<td>所有Java文件执行搜索操作</td>
</tr>
<tr>
<td>ggrep</td>
<td>所有Gradle文件执行搜索操作</td>
</tr>
<tr>
<td>mangrep [keyword]</td>
<td>所有AndroidManifest.xml文件执行搜索操作</td>
</tr>
<tr>
<td>mgrep [keyword]</td>
<td>所有Android.mk文件执行搜索操作</td>
</tr>
<tr>
<td>sepgrep [keyword]</td>
<td>所有sepolicy文件执行搜索操作</td>
</tr>
<tr>
<td>resgrep [keyword]</td>
<td>所有本地res/*.xml文件执行搜索操作</td>
</tr>
<tr>
<td>sgrep [keyword]</td>
<td>所有资源文件执行搜索操作</td>
</tr>
</tbody>
</table>
<p>上述指令用法最终实现方式都是基于<em>grep</em>指令，各个指令用法格式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">xgrep [keyword]  //x代表的是上表的搜索指令</div><div class="line">``` </div><div class="line"></div><div class="line">例如，搜索所有AndroidManifest.xml文件中的*launcher*关键字所在文件的具体位置，指令</div><div class="line">``` bash</div><div class="line">mangrep launcher</div></pre></td></tr></table></figure></p>
<p>再如，搜索所有Java代码中包含<em>zygote</em>所在文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jgrep zygote</div></pre></td></tr></table></figure></p>
<p>又如，搜索所有system_app的selinux权限信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sepgrep system_app</div></pre></td></tr></table></figure></p>
<p>Tips: Android源码非常庞大，直接采用grep来搜索代码，不仅方法笨拙、浪费时间，而且搜索出很多无意义的混淆结果。根据具体需求，来选择合适的代码搜索指令，能节省代码搜索时间，提高搜索结果的精准度，方便定位目标代码。</p>
<h2 id="导航指令"><a href="#导航指令" class="headerlink" title="导航指令"></a>导航指令</h2><table>
<thead>
<tr>
<th>导航指令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>croot</td>
<td>切换至Android根目录</td>
</tr>
<tr>
<td>cproj</td>
<td>切换至工程的根目录</td>
</tr>
<tr>
<td>godir [filename]</td>
<td>跳转到包含某个文件的目录</td>
</tr>
</tbody>
</table>
<p>Tips: 当每次修改完某个文件后需要编译时，执行cproj后会跳转到当前模块的根目录，也就是Android.mk文件所在目录，然后再执行mm指令，即可编译目标模块；当进入源码层级很深后，需要返回到根目录，使用croot一条指令完成；另外cd - 指令可用于快速切换至上次目录。</p>
<h2 id="信息查询"><a href="#信息查询" class="headerlink" title="信息查询"></a>信息查询</h2><table>
<thead>
<tr>
<th>查询指令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>hmm</td>
<td>查询所有的指令help信息</td>
</tr>
<tr>
<td>findmakefile</td>
<td>查询当前目录所在工程的Android.mk文件路径</td>
</tr>
<tr>
<td>print_lunch_menu</td>
<td>查询lunch可选的product</td>
</tr>
<tr>
<td>printconfig</td>
<td>查询各项编译变量值</td>
</tr>
<tr>
<td>gettop</td>
<td>查询Android源码的根目录</td>
</tr>
<tr>
<td>gettargetarch</td>
<td>获取TARGET_ARCH值</td>
</tr>
</tbody>
</table>
<h2 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h2><p>上述只是列举比较常用的指令，还有其他指令，而且不同的build编译系统，支持的指令可能会存在一些差异，当忘记这些编译指令，可以通过执行hmm，查询指令的帮助信息。</p>
<p>最后再列举两个比较常用的指令：</p>
<ul>
<li>make clean：执行清理操作，等价于 rm -rf out/</li>
<li>make update-api：更新API，在framework API改动后需执行该指令，Api记录在目录frameworks/base/api；</li>
</ul>
<h1 id="编译系统"><a href="#编译系统" class="headerlink" title="编译系统"></a>编译系统</h1><p>Android 编译系统是Android源码的一部分，用于编译Android系统，Android SDK以及相关文档。该编译系统是由Make文件、Shell以及Python脚本共同组成，其中最为重要的便是Make文件。关于编译系统可参考 <a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/" title="理解 Android Build 系统" target="_blank" rel="external">理解 Android Build 系统</a>。</p>
<h2 id="Makefile分类"><a href="#Makefile分类" class="headerlink" title="Makefile分类"></a>Makefile分类</h2><p>整个Build系统的Make文件分为三大类：</p>
<ul>
<li>系统核心的Make文件：定义了Build系统的框架，文件全部位于路径/build/core，其他Make文件都是基于该框架编写的；</li>
<li>针对产品的Make文件：定义了具体某个型号手机的Make文件，文件路径位于/device，该目录下往往又以公司名和产品名划分两个子级目录，比如/device/qcom/msm8916；</li>
<li>针对模块的Make文件：整个系统分为各个独立的模块，每个模块都一个专门的Make文件，名称统一为”Android.mk”，该文件定义了当前模块的编译方式。Build系统会扫描整个源码树中名为”Android.mk”的问题，并执行相应模块的编译工作。</li>
</ul>
<h2 id="编译产物"><a href="#编译产物" class="headerlink" title="编译产物"></a>编译产物</h2><p>经过make编译后的产物，都位于/out目录，该目录下主要关注下面几个目录：</p>
<ul>
<li>/out/host：Android开发工具的产物，包含SDK各种工具，比如adb，dex2oat，aapt等。</li>
<li>/out/target/common：通用的一些编译产物，包含Java应用代码和Java库；</li>
<li>/out/target/product/[product_name]：针对特定设备的编译产物以及平台相关C/C++代码和二进制文件；</li>
</ul>
<p>在/out/target/product/[product_name]目录下，有几个重量级的镜像文件：</p>
<ul>
<li>system.img:挂载为根分区，主要包含Android OS的系统文件；</li>
<li>ramdisk.img:主要包含init.rc文件和配置文件等；</li>
<li>userdata.img:被挂载在/data，主要包含用户以及应用程序相关的数据；</li>
</ul>
<p>当然还有boot.img，reocovery.img等镜像文件，这里就不介绍了。</p>
<h2 id="Android-mk解析"><a href="#Android-mk解析" class="headerlink" title="Android.mk解析"></a>Android.mk解析</h2><p>在源码树中每一个模块的所有文件通常都相应有一个自己的文件夹，在该模块的根目录下有一个名称为“Android.mk” 的文件。编译系统正是以模块为单位进行编译，每个模块都有唯一的模块名，一个模块可以有依赖多个其他模块，模块间的依赖关系就是通过模块名来引用的。也就是说当模块需要依赖一个jar包或者apk时，必须先将jar包或apk定义为一个模块，然后再依赖相应的模块。</p>
<p>对于Android.mk文件，通常都是以下面两行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LOCAL_PATH := $(call my-dir)  //设置当编译路径为当前文件夹所在路径</div><div class="line">include $(CLEAR_VARS)  //清空编译环境的变量（由其他模块设置过的变量）</div></pre></td></tr></table></figure>
<p>为方便模块编译，编译系统设置了很多的编译环境变量，如下：</p>
<ul>
<li>LOCAL_SRC_FILES：当前模块包含的所有源码文件；</li>
<li>LOCAL_MODULE：当前模块的名称（具有唯一性）；</li>
<li>LOCAL_PACKAGE_NAME：当前APK应用的名称（具有唯一性）；</li>
<li>LOCAL_C_INCLUDES：C/C++所需的头文件路径;</li>
<li>LOCAL_STATIC_LIBRARIES：当前模块在静态链接时需要的库名;</li>
<li>LOCAL_SHARED_LIBRARIES：当前模块在运行时依赖的动态库名;</li>
<li>LOCAL_STATIC_JAVA_LIBRARIES：当前模块依赖的Java静态库;</li>
<li>LOCAL_JAVA_LIBRARIES：当前模块依赖的Java共享库;</li>
<li>LOCAL_CERTIFICATE：签署当前应用的证书名称，比如platform。</li>
<li>LOCAL_MODULE_TAGS：当前模块所包含的标签，可以包含多标签，可能值为debgu,eng,user,development或optional（默认值）</li>
</ul>
<p>针对这些环境变量，编译系统还定义了一些便捷函数，如下：</p>
<ul>
<li>$(call my-dir)：获取当前文件夹路径；</li>
<li>$(call all-java-files-under, )：获取指定目录下的所有Java文件；</li>
<li>$(call all-c-files-under, )：获取指定目录下的所有C文件；</li>
<li>$(call all-Iaidl-files-under, ) ：获取指定目录下的所有AIDL文件；</li>
<li>$(call all-makefiles-under, )：获取指定目录下的所有Make文件；</li>
</ul>
<p>示例：</p>
<pre><code class="bash">LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)

<span class="comment"># 获取所有子目录中的Java文件</span>
LOCAL_SRC_FILES := $(call all-subdir-java-files)

<span class="comment"># 当前模块依赖的动态Java库名称</span>
LOCAL_JAVA_LIBRARIES := com.gityuan.lib

<span class="comment"># 当前模块的名称</span>
LOCAL_MODULE := demo

<span class="comment"># 将当前模块编译成一个静态的Java库</span>
include $(BUILD_STATIC_JAVA_LIBRARY)
</code></pre>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/13/我所理解的OOP——UML六种关系/" itemprop="url">
                  我所理解的OOP——UML六种关系
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-13T23:21:50+08:00" content="2016-09-13">
              2016-09-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Other/" itemprop="url" rel="index">
                    <span itemprop="name">Other</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.cnblogs.com/dolphinX/p/3296681.html" target="_blank" rel="external">TokgoLiang——转载别人的原文链接一定要写在开头</a></p>
<p>UML定义的关系主要有：泛化、实现、依赖、关联、聚合、组合，这六种关系紧密程度依次加强，分别看一下</p>
<h1 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h1><p>概念：泛化是一种一般与特殊、一般与具体之间关系的描述，具体描述建立在一般描述的基础之上，并对其进行了扩展。在程序中是通过继承类实现的。比如狗是对动物的具体描述，在面向对象设计的时候一般把狗设计为动物的子类。</p>
<p>表示方法：空心三角形箭头的实线，子类指向父类</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/%E6%B3%9B%E5%8C%96.png" alt="泛化"></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>概念：实现是一种类与接口的关系，表示类是接口所有特征和行为的实现，在程序中一般通过类实现接口来描述</p>
<p>表示方法：空心三角形箭头的虚线，实现类指向接口</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/%E5%AE%9E%E7%8E%B0.png" alt="实现"></p>
<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><p>概念：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖，在程序中一般表现为类A中的方法需要类B的实例作为其参数或者变量，而类A本身并不需要引用类B的实例作为其成员变量。</p>
<p>表示方法：虚线箭头，类A指向类B。</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/%E4%BE%9D%E8%B5%96.png" alt="依赖"></p>
<h1 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h1><p>概念：表示类与类之间的联接,它使一个类知道另一个类的属性和方法，这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，在程序中被关联类B以类属性的形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量</p>
<p>表示方法：实线箭头，类A指向类B</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/%E5%85%B3%E8%81%94.png" alt="关联"></p>
<h1 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h1><p>概念：聚合关联关系的一种特例，是强的关联关系。聚合是整体和个体之间的关系，即has-a的关系，整体与个体可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。程序中聚合和关联关系是一致的，只能从语义级别来区分；</p>
<p>表示方法：尾部为空心菱形的实线箭头（也可以没箭头），类A指向类B</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/%E8%81%9A%E5%90%88.png" alt="聚合"></p>
<h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><p>概念：组合也是关联关系的一种特例。组合是一种整体与部分的关系，即contains-a的关系，比聚合更强。部分与整体的生命周期一致，整体的生命周期结束也就意味着部分的生命周期结束，组合关系不能共享。程序中组合和关联关系是一致的，只能从语义级别来区分。</p>
<p>表示方法：尾部为实心菱形的实现箭头（也可以没箭头），类A指向类B</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/%E7%BB%84%E5%90%88.png" alt="组合"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/13/第三章：Android经典场景设计/" itemprop="url">
                  第三章：Android经典场景设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-13T22:31:06+08:00" content="2016-09-13">
              2016-09-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Android_读书笔记</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/App研发录/" itemprop="url" rel="index">
                    <span itemprop="name">App研发录</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="App图片缓存设计"><a href="#App图片缓存设计" class="headerlink" title="App图片缓存设计"></a>App图片缓存设计</h1><p>App缓存分为两部分，数据缓存和图片缓存，第二章介绍了数据缓存</p>
<h2 id="ImageLoader设计原理"><a href="#ImageLoader设计原理" class="headerlink" title="ImageLoader设计原理"></a>ImageLoader设计原理</h2><p>在显示图片的时候，现在内存中查找，如果没有就去本地查找，如果还没有就开一个新线程去下载，下载成功之后吧图片同时缓存到内存和本地。</p>
<p>基于这个原理，我们可以在每次退出一个页面的时候，吧ImageLoader内存中的缓存全部清除，这样就节省了大量内存，下次再用的时候在本地取出来就可以了。</p>
<p>此外，由于ImageLoader对图片是软应用的形式，所以内存中的图片会在内存不足的时候被系统回收（内存足够的时候不会对其进行垃圾回收）。</p>
<p><a href="https://github.com/nostra13/Android-Universal-Image-Loader" title="ImageLoader在GitHub的下载地址" target="_blank" rel="external">ImageLoader在GitHub的下载地址：https://github.com/nostra13/Android-Universal-Image-Loader</a></p>
<h2 id="ImageLoader的使用"><a href="#ImageLoader的使用" class="headerlink" title="ImageLoader的使用"></a>ImageLoader的使用</h2><h3 id="ImageLoader由三大组件组成"><a href="#ImageLoader由三大组件组成" class="headerlink" title="ImageLoader由三大组件组成"></a>ImageLoader由三大组件组成</h3><ul>
<li>ImageLoaderConfiguration：对图片缓存进行总体配置，包括内存缓存大小，本地缓存的大小和位置，日志，下载策略（FIFO，LIFO）等等。       </li>
<li>ImageLoader：我们一般使用displayImage来把URL对应的图片显示在ImageView上。       </li>
<li>DisplayImageOptions：在每个页面需要显示图片的地方，控制如何显示的细节，比如指定下载时的默认图片（包括下载中，下载失败，URL为空等），是否将缓存放到内存或者本地磁盘。</li>
</ul>
<p>博客园陈哈哈博文中对三个关系的比喻：           </p>
<blockquote>
<p>他们有点像厨房规定，厨师，客户个人口味之间的关系。ImageLoaderConfiguration就像是厨房里的规定，每一个厨师要怎么着装，要怎么保持厨房的干净，这是针对每一个厨师都适用的规定，而且不允许个性化改变。ImageLoader就像是具体做菜的厨师，负责具体菜谱的制作。DisplayImageOptions就像是客户的偏好，根据客户是重口味还是清淡，每一个ImageLoader根据DisplayImageOptions的要求具体执行。</p>
</blockquote>
<h3 id="如何使用ImageLoader"><a href="#如何使用ImageLoader" class="headerlink" title="如何使用ImageLoader"></a>如何使用ImageLoader</h3><p>1.在Application中配置ImageLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YoungHeartApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onCreate();</div><div class="line">		CacheManager.getInstance().initCacheDir();</div><div class="line">		ImageLoaderConfiguration config = </div><div class="line">				<span class="keyword">new</span> ImageLoaderConfiguration.Builder(</div><div class="line">				getApplicationContext())</div><div class="line">				.threadPriority(Thread.NORM_PRIORITY - <span class="number">2</span>)</div><div class="line">				.memoryCacheExtraOptions(<span class="number">480</span>, <span class="number">480</span>)</div><div class="line">				.memoryCacheSize(<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>)</div><div class="line">				.denyCacheImageMultipleSizesInMemory()</div><div class="line">				.discCacheFileNameGenerator(<span class="keyword">new</span> Md5FileNameGenerator())</div><div class="line">				.tasksProcessingOrder(QueueProcessingType.LIFO)</div><div class="line">				.memoryCache(<span class="keyword">new</span> WeakMemoryCache()).build();</div><div class="line">		ImageLoader.getInstance().init(config);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.在使用ImageView加载图片的地方，配置当前页面的ImageLoader选项，有可能是Activity也有可能是Adapter </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CinemaAdapter</span><span class="params">(ArrayList&lt;CinemaBean&gt; cinemaList,</span></span></div><div class="line">			AppBaseActivity context) &#123;</div><div class="line">		<span class="keyword">this</span>.cinemaList = cinemaList;</div><div class="line">		<span class="keyword">this</span>.context = context;</div><div class="line">		options = <span class="keyword">new</span> DisplayImageOptions.Builder()</div><div class="line">				.showStubImage(R.drawable.ic_launcher)</div><div class="line">				.showImageForEmptyUri(R.drawable.ic_launcher)</div><div class="line">				.cacheInMemory()</div><div class="line">				.cacheOnDisc()</div><div class="line">				.build();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>3.在使用ImageView加载图片的地方，使用ImageLoader。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CinemaBean cinema = cinemaList.get(position);</div><div class="line">		holder.tvCinemaName.setText(cinema.getCinemaName());</div><div class="line">		holder.tvCinemaId.setText(cinema.getCinemaId());</div><div class="line">		context.imageLoader.displayImage(cinemaList.get(position)</div><div class="line">				.getCinemaPhotoUrl(), holder.imgPhoto);</div></pre></td></tr></table></figure>
<p><strong>ImageLoader优化</strong></p>
<p>ImageLoader把图片缓存到内存，会导致内存占用过高，虽然对图片的引用是软引用，会在内存不足的时候被GC，但是我们希望减少GC的次数，所以要手动清理ImageLoader中的缓存。</p>
<p>在APPBaseActivity中的onDestroy方法中，执行ImageLoader的clearMemoryCache方法，下次复用的时候即使内存中没有了，还可以在本地磁盘找到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">void</span> onDestroy &#123;</div><div class="line">    imageLoader.clearMemoryCache();</div><div class="line">    <span class="keyword">super</span>.onDestroy ();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="推荐文章："><a href="#推荐文章：" class="headerlink" title="推荐文章："></a>推荐文章：</h2><p>1.简介ImageLoader（一），（二）</p>
<ul>
<li><a href="http://blog.csdn.net/yueqinglkong/article/details/27660107" target="_blank" rel="external">http://blog.csdn.net/yueqinglkong/article/details/27660107</a></li>
<li><a href="http://blog.csdn.net/yueqinglkong/article/details/28094963" target="_blank" rel="external">http://blog.csdn.net/yueqinglkong/article/details/28094963</a></li>
</ul>
<p>2.Android-Universal-Image-Loader图片异步加载类库的使用（超详细配置）</p>
<ul>
<li><a href="http://blog.csdn.net/vipzjyno1/article/details/23206387" target="_blank" rel="external">http://blog.csdn.net/vipzjyno1/article/details/23206387</a></li>
</ul>
<p>3.Android开源框架Android-Universal-Image-Loade完全解析</p>
<ul>
<li><a href="http://blog.csdn.net/xiaanming/article/details/26810303" target="_blank" rel="external">http://blog.csdn.net/xiaanming/article/details/26810303</a></li>
<li><a href="http://blog.csdn.net/xiaanming/article/details/27525741" target="_blank" rel="external">http://blog.csdn.net/xiaanming/article/details/27525741</a></li>
<li><a href="http://blog.csdn.net/xiaanming/article/details/39057201" target="_blank" rel="external">http://blog.csdn.net/xiaanming/article/details/39057201</a></li>
</ul>
<h2 id="图片加载利器Fresco"><a href="#图片加载利器Fresco" class="headerlink" title="图片加载利器Fresco"></a>图片加载利器Fresco</h2><p>Facebook的Android图片加载组件,使用Fresco：</p>
<p>1.在Application级别，对Fresco进行初始化，<br>Fresco.initialize(getApplicationContext());</p>
<p>2.与ImageLoader等传统第三方图片处理SDK不同，Fresco是基于控件级别的，所以需要把程序中显示网络图片的ImageView都替换为SimpleDraweeView即可，并在布局文件添加fresco命名空间，如下：<br>xmlns：fresco=”<a href="http://schemas.android.com/apk/res-auto" target="_blank" rel="external">http://schemas.android.com/apk/res-auto</a>“</p>
<com.facebook.drawee.view.simpledraweeview...>

<p>3.在Activity中为这个图片控件指定要显示的网络图片：<br>Uri uri = Uri.parse(“<a href="http://www.bb.com/a.png" target="_blank" rel="external">http://www.bb.com/a.png</a>“)<br>draweeView.setImageURI(uri);</p>
<p>Fresco原理是，设计了一个ImagePipeline的概念，它负责先后检查内存，磁盘文件，如果都没有再从网络下载图片，可以使用ImagePipelineConfig来配置ImagePipeline，像配置ImageLoader一样。</p>
<p>Fresco有三个线程池，其中3个线程用于网络下载图片，2个线程用于磁盘文件的读写，还有2个线程用于CPU相关操作，这是Fresco的核心，它比其他图片SDK吃内存小，就在于这个全新的缓存设计。</p>
<p><strong>第一层：Bitmap缓存</strong><br>在Android5.0系统中，考虑到内存管理有了很大改进，所以Bitmap缓存位于Java的堆（heap）中，而在Android4.x和更低的系统，Bitmap位于ashmem中，这意味着图片的创建和回收不会引发过多的GC，从而让App运行得更快。当App切到后台时，Bitmap缓存会被清空。</p>
<p><strong>第二层：内存缓存</strong><br>内存缓存中存储了图片的原始压缩格式，从内存缓存中取出的图片，在显示之前必须先解码，当App切换到后台时，内存缓存也会被清空。</p>
<p><strong>第三层：磁盘缓存</strong><br>磁盘缓存又名本地缓存，磁盘缓存中存储的也是图片的原始压缩格式，在使用前也要解码。当App切到后台，甚至关机，磁盘缓存也不会丢失。</p>
<p>Fresco在GitHub上的源码：<a href="https://github.com/mkottman/AndroLua" target="_blank" rel="external">https://github.com/mkottman/AndroLua</a><br>Fresco官方文档：<a href="http://www.fresco-cn.org/docs/index.html#_" target="_blank" rel="external">http://www.fresco-cn.org/docs/index.html#_</a></p>
<h1 id="对网络流量进行优化"><a href="#对网络流量进行优化" class="headerlink" title="对网络流量进行优化"></a>对网络流量进行优化</h1><h2 id="通信层面的优化"><a href="#通信层面的优化" class="headerlink" title="通信层面的优化"></a>通信层面的优化</h2><p>1.MobileAPI接口返回的数据，要使用gzip进行压缩，注意：大于1KB才进行压缩，否则得不偿失。</p>
<p>2.App与MobileAPI直接传递数据，通常是遵守JSON协议的。JSON因为是xml格式的，并且是以字符存在的，在数据量上还有可以压缩的空间。作者推荐一种新的数据传输协议，那就是ProtoBuffer。这种协议是二进制格式的，所以在表示大数据时，空间不JSON小的多。</p>
<p>3.解决频繁调用MobileAPI的问题。发起一次网络请求，服务器处理速度是很快的，主要花费的时间在数据传输上。走路时间的长度，网络运维人员负责解决，移动开发人员需要注意的是，减少网络访问次数。</p>
<p>4.传统的MobileAPI使用的是HTTP无状态短连接，使用HTTP协议的速度远不如使用TCP协议，因为后者是长连接，所以可以使用TCP长连接。TCP的缺点是一台服务器能支持的长连接个数不多。</p>
<p>5.要建立取消网络请求的机制。一个页面如果没有请求完数据，在跳转到另一个界面之前，吧之前的网络请求全部取消，不在等待，也不再接受数据。</p>
<p>6.增加重试机制。如果MobileAPI是严格的RESTful风格，那么我们一般将获取数据的请求接口都定义为get，而把操作数据的请求接口都定义为post。这样的话可以为所有的get请求配置重试机制，比如请求失败后重试3次，如果post请求具有防重复机制，那么到是可以增加重试机制。</p>
<h2 id="图片策略优化"><a href="#图片策略优化" class="headerlink" title="图片策略优化"></a>图片策略优化</h2><p><strong>1.要确保下载的每张图片，都符合Imageview控件的大小</strong></p>
<p>事先准备多套不同分辨率的图片，每次根据RUL请求图片时，都要额外在URL上加两个参数，width和height。</p>
<p>如果认为每次准备多套图片浪费人力，事先准备一台服务器，成为ImageSever，具体流程如下：</p>
<p>(1).首先，App每次加载图片，都会把URL地址以及width和height参数所组成的字符串进行encode，然后发送给ImageSever，新的URL如：<a href="http://www.ImageServer.com/getImage?param=(encode" target="_blank" rel="external">http://www.ImageServer.com/getImage?param=(encode</a> value )</p>
<p>(2).然后，ImageSever收到这个请求，会把param的值decode，得到原始图片的URL，以及App想要现实这张图片的width和height，ImageServer会根据URL获取到这张图片的原始图片，然后根据width和height，重新进行绘制，保存到ImageServer上，并返回给App。</p>
<p>(3).最后，App请求道一张符合其大小的图片。<br>再加一个参数imagetype，用于在比例不一致进行等比缩放后裁剪或者填充以及不缩放，这种方案的全电视频繁写硬盘。所以要事先规定几套width和height，App尽量遵守，同时在出口加以控制，也就是在像ImageServer发起请求的时候，去轮询事先规定好的各个尺寸，看哪个更接近。</p>
<p><strong>2.低流量模式</strong></p>
<p>在2G和3G网络环境下，适当降低图片的质量，可以在URL中再增加一个参数，quality根据网络环境设置对应的值，把这个参数传递给ImageServer，从而ImageServer在绘制图片时，就会将图片质量降低为quality对应比例。</p>
<p><strong>3.极速模式</strong></p>
<p>设计一些额外界面，区别于正常模式下图文并茂的页面，这些只有文字的页面称为极速模式。</p>
<h1 id="城市列表的设计"><a href="#城市列表的设计" class="headerlink" title="城市列表的设计"></a>城市列表的设计</h1><h2 id="城市列表数据"><a href="#城市列表数据" class="headerlink" title="城市列表数据"></a>城市列表数据</h2><p>一份城市列表数据包括以下几个字典：</p>
<ul>
<li>cityId，</li>
<li>cityName，</li>
<li>pinyin，</li>
<li>jianpin</li>
</ul>
<p>把城市列表数据写在本地，时间久了会产生两个问题</p>
<p>1.Android和iOS维护的数据，差距越来越大</p>
<p>写一个文本分析工具，找出Android和iOS各自维护文件的不同数据。</p>
<p>2.城市太多，每次从本地加载都要很长时间</p>
<p>每次都要解析xml城市数据文件，既然每次读取数据都很慢，那么干脆把序列化过的城市列表信息直接保存到本地文件，随App一起发布。每次读取这个文件是，直接进行发序列化即可。</p>
<p>对于解决数据更新时的同步问题，把城市列表数据做成一个MobileAPI接口，有MobileAPI去后台采集数据，增加一个版本号version字段，对比本地版本号和线上最新版本号，MobileAPI返回响应结果，如果一致，则从本地问价加载数据，否则解析MobileAPI返回的数据，同时更新本地版本号。如果MobileAPI接口调用没有成功，也直接从本地读取，从MobileAPI获取大量数据时候开启gzip压缩。</p>
<h2 id="城市列表数据增量更新机制"><a href="#城市列表数据增量更新机制" class="headerlink" title="城市列表数据增量更新机制"></a>城市列表数据增量更新机制</h2><p>cityId作为唯一标识，增量更新的数据，由增、删、改三部分组成。</p>
<p>重新定义城市列表的JSON格式，在每笔增量数据中增加一个字段type，取来区别增删改，客户端收到JSON数据后，会根据type处理本地的数据。</p>
<h1 id="App与HTML5的交互"><a href="#App与HTML5的交互" class="headerlink" title="App与HTML5的交互"></a>App与HTML5的交互</h1><p>有的团队直接使用PhoneGap来实现交互功能，作者认为PhoneGay太重了，完全可以吧这些交互操作在底层封装好，然后给开发人员使用。</p>
<p><strong>App操作HTML5页面的方法</strong></p>
<p>首先要定好通讯协议，也就是App要调用的HTML5中的JavaScript的方法名称。例如App要调用HTML5页面的changeColor(color)方法，</p>
<p>HTML5代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> &gt;</span><span class="xml"></span></div><div class="line">    function chanageColor(color) &#123;</div><div class="line">        document.body.backgroundColor = color;</div><div class="line">    &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span> &gt;</span></div><div class="line">``` </div><div class="line"></div><div class="line">Android代码如下：</div><div class="line"></div><div class="line">``` java</div><div class="line">wvAds.getSettings().setJavaScriptEnabled(true);</div><div class="line">wvAds.loadUrl("file://.../xxx.html");</div><div class="line">btnShowAlert.setOnCliceListener(new View.OnClickListener() &#123;</div><div class="line">    @Override</div><div class="line">    public void onClick(View v) &#123;</div><div class="line">    String color = "#00ee00";</div><div class="line">    wvAds.loadUrl("javascript:changeColor('"+color+"');");</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>HTML5页面操作App页面的方法</p>
<p>首先仍然是定义通讯协议，这次是定义JavaScript要调用Android种方法的名称。例如调用callAndroidMethod方法，</p>
<p>HTML5代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onClick</span>=<span class="string">"baobao.callAndroidMethod(100,100,'ccc',true)"</span>&gt;</span></div><div class="line">CallAndroidMethod<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Android代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSInterfacel</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callAndroidMethod</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">float</span> b, String c, <span class="keyword">boolean</span> d)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(d) &#123;</div><div class="line">            String strMessage = <span class="string">"fafafsadf"</span>;</div><div class="line">            <span class="keyword">new</span> AlertDialog.Builder(MainActivity.<span class="keyword">this</span>)</div><div class="line">                .setTitle(title)</div><div class="line">                .setMessage(strMessage).show(); </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同时需要注册baobao和JSInterfacel的对应关系  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wvAds.addJavascriptInterface(<span class="keyword">new</span> JSInterfacel(), <span class="string">"baobao"</span>);</div></pre></td></tr></table></figure>
<p>App和Android之间定义跳转协议,如上面的例子，事先约定格式。。</p>
<p><strong>在App中内置HTML5页面</strong></p>
<p>当有些UI不太容易在App中使用原始语言实现时，而HTML5擅长，只要调整好屏幕适配，就可以在App中应用HTML5。</p>
<p>1.首先定义两个HTML5文件，放在assets目录下<br>其中，102.html是静态页：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span>        </div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">table</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">datalDefinedByBaobao</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div><div class="line">``` </div><div class="line">datal_template.html是一个数据模板，他负责提供表格中一行的样式</div><div class="line"></div><div class="line">``` html</div><div class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">``` </div><div class="line">像name，price，datalDefinedByBaobao都是占位符</div><div class="line"></div><div class="line">2.在MovieDetailActivity中，通过遍历movieList这个集合，把数据填充到SBContent中，最终，把拼接好的字符串替换<span class="tag">&lt;<span class="name">datalDefinedByBaobao</span>&gt;</span>标签。</div><div class="line"></div><div class="line">``` java</div><div class="line">wvAds = (WebView) findViewById(R.id.wvAds);</div><div class="line">		String template = getFromAssets("data1_template.html");</div><div class="line">		StringBuilder sbContent = new StringBuilder(); </div><div class="line">		ArrayList<span class="tag">&lt;<span class="name">MovieInfo</span>&gt;</span> movieList = organizeMovieList();</div><div class="line">		for (MovieInfo movie : movieList) &#123;</div><div class="line">			String rowData;</div><div class="line">			rowData = template.replace("<span class="tag">&lt;<span class="name">name</span>&gt;</span>", movie.getName());</div><div class="line">			rowData = rowData.replace("<span class="tag">&lt;<span class="name">price</span>&gt;</span>", movie.getPrice());</div><div class="line">			sbContent.append(rowData);</div><div class="line">		&#125;</div><div class="line">		String realData = getFromAssets("102.html");</div><div class="line">		realData = realData.replace("<span class="tag">&lt;<span class="name">data1DefinedByBaobao</span>&gt;</span>", </div><div class="line">				sbContent.toString());</div><div class="line">		wvAds.loadData(realData, "text/html", "utf-8");</div></pre></td></tr></table></figure>
<p>灵活切换Native和HTML5页面的策略</p>
<p>对于经常改动的页面，我们会把它做成HTML5页面，在App中以WebView的形式加载。虽然HTML开发周期相对App而言短，但是HTML5会比较慢。</p>
<p>HTML5页面生成的步骤；</p>
<ol>
<li>从服务器动态获取数据并拼接成一个HTML，</li>
<li>返回给客户端WebView，</li>
<li>在WebView中解析并生成HTML。</li>
</ol>
<p>结合两者的优点，同时做两套页面，Native一套，HTML一套，然后在App中设置一个变量，来判断页面将显示Native还是HTML5的，这个变量可以从MobileAPI获取。App中所有的页面都可以这样做，为此，我们需要改变之前做App的思路。</p>
<ol>
<li>需要做一个后台，根据版本进行配置每个页面是使用Native页面还是HTML5页面，</li>
<li>当App启动的时候，从MobileAPI获取到每个页面是Native还是HTML5，</li>
<li>在App代码层面，页面之间要实现松耦合。</li>
</ol>
<p>页面分发器</p>
<p>对于那些来自HTML5页面，传递简单数据的页面跳转请求，我们将为其抽象一个分发器，放在BaseActivity中。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">"baobao.gotoAnyWhere(</span></span></div><div class="line">    'com.example.youngheart.MovieDetailActivity,</div><div class="line">    iOS.MovieDetailViewController:movieId=(int)123')"&gt;</div><div class="line">    gotoAnyWhere</div><div class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">``` </div><div class="line"></div><div class="line">协议的内容分成三段，第一段是Android要条转到的Activity的名称，第二段是iOS要跳转到的ViewController的名称，第三段是需要传递的参数，以key-value的形式组装。</div><div class="line"></div><div class="line">我们接下来要做的就是从协议URL中取出第1段，将其反射成一个Activity对象，取出第3段，将其解析为key-value的形式，然后从当前页面跳转到目标页面并配以正确的参数。其中，写一个辅助函数getAndroidPageName，用来获取Activity名称，</div><div class="line"></div><div class="line">``` java</div><div class="line">public class BaseActivity extends Activity &#123;</div><div class="line">	public void gotoAnyWhere(String url) &#123;</div><div class="line">		if (url != null) &#123;</div><div class="line">			if (url.startsWith("gotoMovieDetail:")) &#123;</div><div class="line">				String strMovieId = url.substring(24);</div><div class="line">				int movieId = Integer.valueOf(strMovieId);</div><div class="line">				Intent intent = new Intent(this, MovieDetailActivity.class);</div><div class="line">				intent.putExtra("movieId", movieId);</div><div class="line">				startActivity(intent);</div><div class="line">			&#125; else if (url.startsWith("gotoNewsList:")) &#123;</div><div class="line">				// as above</div><div class="line">			&#125; else if (url.startsWith("gotoPersonCenter")) &#123;</div><div class="line">				Intent intent = new Intent(this, PersonCenterActivity.class);</div><div class="line">				startActivity(intent);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	private String getAndroidPageName(String key) &#123;</div><div class="line">		String pageName = null;</div><div class="line">		int pos = key.indexOf(",");</div><div class="line">		if (pos == -1) &#123;</div><div class="line">			pageName = key;</div><div class="line">		&#125; else &#123;</div><div class="line">			pageName = key.substring(0, pos);</div><div class="line">		&#125;</div><div class="line">		return pageName;</div><div class="line">	&#125;</div><div class="line">	public void gotoAnyWhere2(String url) &#123;</div><div class="line">		if (url == null)</div><div class="line">			return;</div><div class="line">		</div><div class="line">		String pageName = getAndroidPageName(url);</div><div class="line">		if (pageName == null || pageName.trim() == "")</div><div class="line">			return;</div><div class="line">		Intent intent = new Intent();</div><div class="line">		int pos = url.indexOf(":");</div><div class="line">		if (pos &gt; 0) &#123;</div><div class="line">			String strParams = url.substring(pos);</div><div class="line">			String[] pairs = strParams.split("&amp;");</div><div class="line">			for (String strKeyAndValue : pairs) &#123;</div><div class="line">				String[] arr = strKeyAndValue.split("=");</div><div class="line">				String key = arr[0];</div><div class="line">				String value = arr[1];</div><div class="line">				if (value.startsWith("(int)")) &#123;</div><div class="line">					intent.putExtra(key, Integer.valueOf(value.substring(5)));</div><div class="line">				&#125; else if (value.startsWith("(Double)")) &#123;</div><div class="line">					intent.putExtra(key, Double.valueOf(value.substring(8)));</div><div class="line">				&#125; else &#123;</div><div class="line">					intent.putExtra(key, value);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		try &#123;</div><div class="line">			intent.setClass(this, Class.forName(pageName));</div><div class="line">		&#125; catch (ClassNotFoundException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		startActivity(intent);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="消灭全局变量"><a href="#消灭全局变量" class="headerlink" title="消灭全局变量"></a>消灭全局变量</h1><p><strong>问题的发现</strong></p>
<p>在内存不足的时候，系统会回收一部分闲置的资源，由于App被切换到后台，所以存放的全局变量很容易被回收，这时候在切回到前台继续使用，就会因为全局变量的值为空而崩溃。</p>
<p><strong>把数据作为Intent的参数传递</strong></p>
<p>即使目标Activity被系统销毁了，Intent上的数据仍然存在，所以Intent是保存数据的一个很好的地方。但是Intent能传递的数据也必须支持序列化，想JSONObject这样的数据类型，是传递不过去的。</p>
<p><strong>把全局变量序列化到本地</strong></p>
<p>另一个比较稳妥的解决方案是，我们仍然使用全局变量，在每次修改全局变量的值得时候，都要把值序列化到本地文件中，这样的话，即使内存中的全局变量被回收，本地还保存有最新的值，当我们再次使用全局变量时，就从本地文件中再反序列化到内存。但不是长远之计，以后还是要讲全局变量转换为Intent上可序列化的数据。</p>
<p><strong>序列化的缺点</strong></p>
<p>再次强调，把全局变量序列化到本地的方案只是一种过渡性的解决方案，他有以下几个硬伤：</p>
<ul>
<li>每次设置全局变量的值都要强制执行一次序列化的操作，容易造成ANR，</li>
<li>序列化生成的文件，会因为内存不够而丢失。</li>
<li>Android提供的数据类型并不全部都支持序列化。JSONObject，JSONArray，包含JSONObject或者JSONArray的List和Map，，都不支持序列化。解决方案，将JSONObject或者JSONArray转换成字符串然后再序列化，，，</li>
</ul>
<p><strong>如果Activity也被销毁了</strong></p>
<p>常见原因旋转屏幕，但是即使Activity被销毁了，Intent并不会丢失。如果需要保存页面状态则要是下面两个方法：</p>
<ul>
<li>onSaveInstanceState();</li>
<li>onRestoreInstanceState();</li>
</ul>
<p><strong>如何看待SharedPreferences</strong></p>
<p>作者认为，</p>
<blockquote>
<p>SharedPreferences是全局变量序列化到本地的另一种形式，存取数据也要支持序列化。注意不要把跳转时要传递的数据放在SharedPreferences，而是使用Intent。</p>
</blockquote>
<p><strong>User是唯一例外的全局变量</strong></p>
<p>作者看来，</p>
<blockquote>
<p>App中只有一个全局变量的存在是合理的，那就是User类。</p>
</blockquote>
</com.facebook.drawee.view.simpledraweeview...>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/12/第二章：Android网络底层框架设计/" itemprop="url">
                  第二章：Android网络底层框架设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-12T23:29:38+08:00" content="2016-09-12">
              2016-09-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Android_读书笔记</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/App研发录/" itemprop="url" rel="index">
                    <span itemprop="name">App研发录</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="网络底层封装"><a href="#网络底层封装" class="headerlink" title="网络底层封装"></a>网络底层封装</h1><p>网络请求的格式：    </p>
<p>对于网络请求，我们一般定义为GET和POST即可，GET为请求数据，POST为修改数据（增删改）</p>
<h2 id="Request格式："><a href="#Request格式：" class="headerlink" title="Request格式："></a>Request格式：</h2><p>所有的MobileAPI都也可以写作<a href="http://www.xxx.com/aaa.api的形式" target="_blank" rel="external">http://www.xxx.com/aaa.api的形式</a></p>
<p>对于GET，我们可以写作<a href="http://www.xxx.com/aaa.api?k1=v1&amp;ke=v2的形式，也就是说，把key-value这样的键值对存放在URL上，之所以这样设计，是为了更方便地定义数据缓存，我们尽量使GET的参数都是String，int这样的简单类型" target="_blank" rel="external">http://www.xxx.com/aaa.api?k1=v1&amp;ke=v2的形式，也就是说，把key-value这样的键值对存放在URL上，之所以这样设计，是为了更方便地定义数据缓存，我们尽量使GET的参数都是String，int这样的简单类型</a></p>
<p>对于POST，我们将key-value这样的键值对存放在From表单中，进行提交。POST经常会提交大量数据，所以有些键值对要定义成集合或者复杂的自定义实体，这时候我们就需要将这样的值转换为JSON字符串进行提交，由App传递到MobileAPI后，再将JSON字符串转换为对应的实体。</p>
<p>上述介绍只是一家之言，不同公司有不同的实现方式，这取决于服务器端的设计。</p>
<h2 id="Response格式："><a href="#Response格式：" class="headerlink" title="Response格式："></a>Response格式：</h2><p>一般使用JSON作为MobileAPI返回结果。规范的JSON数据返回格式如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">          "isError" : false,</div><div class="line">          "errorType" : 0,</div><div class="line">          "errorMessage" : " ",</div><div class="line">          "result" : &#123;</div><div class="line">                  "cinemaId" : 1,</div><div class="line">                  "cinemaName" : "name"</div><div class="line">          &#125;</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<h2 id="AsyncTask的使用和缺点"><a href="#AsyncTask的使用和缺点" class="headerlink" title="AsyncTask的使用和缺点"></a>AsyncTask的使用和缺点</h2><ol>
<li>对于耗时的操作，我们的一般方法是开启“子线程”。如果需要更新UI，则需要使用handler</li>
<li>如果耗时的操作太多，那么我们需要开启太多的子线程，这就会给系统带来巨大的负担，随之也会带来性能方面的问题。在这种情况下我们就可以考虑使用类AsyncTask来异步执行任务，不需要子线程和handler，就可以完成异步操作和刷新UI。</li>
<li>AsyncTask：对线程间的通讯做了包装，是后台线程和UI线程可以简易通讯：后台线程执行异步任务，将result告知UI线程。</li>
<li>使用方法：共分为两步，自定义AsyncTask，在耗时的地方调用自定义的AsyncTask。可以参照以下代码示例。</li>
</ol>
<p><strong>step1：继承AsyncTask<params,progress,result></params,progress,result></strong></p>
<ul>
<li>Params:输入参数。对应的是调用自定义的AsyncTask的类中调用excute()方法中传递的参数。如果不需要传递参数，则直接设为Void即可。</li>
<li>Progress：子线程执行的百分比</li>
<li>Result：返回值类型。和doInBackground（）方法的返回值类型保持一致。</li>
</ul>
<p><strong>step2：实现以下几个方法：执行时机和作用看示例代码，以下对返回值类型和参数进行说明</strong></p>
<ul>
<li>onPreExecute()：无返回值类型。不传参数</li>
<li>doInBackground(Params… params)：返回值类型和Result保持一致。参数：若无就传递Void；若有，就可用Params</li>
<li>publishProgress(Params… params)：在执行此方法的时候会直接调用onProgressUpdate(Params… values)</li>
<li>onProgressUpdate(Params… values)：无返回值类型。参数：若无就传递Void；若有，就可用Progress</li>
<li>onPostExecute(Result  result) ：无返回值类型。参数：和Result保持一致。</li>
</ul>
<p><strong>step3：在调用自定义的AsyncTask类中生成对象；</strong></p>
<p>执行  ：对象.excute(Params… params);</p>
<p>小注：</p>
<ul>
<li>Task的实例必须在UI thread中创建</li>
<li>execute方法必须在UI thread中调用</li>
<li>不要手动的调用onPreExecute(), onPostExecute(Result)，doInBackground=\’#\’” onProgressUpdate(Progress…)这几个方法</li>
<li>该task只能被执行一次，否则多次调用时将会出现异常</li>
</ul>
<p>参照连接</p>
<blockquote>
<p><a href="http://blog.csdn.net/cjjky/article/details/6684959" target="_blank" rel="external">http://blog.csdn.net/cjjky/article/details/6684959</a><br><a href="http://blog.csdn.net/zhenyongyuan123/article/details/5850389" target="_blank" rel="external">http://blog.csdn.net/zhenyongyuan123/article/details/5850389</a><br><a href="http://www.eoeandroid.com/thread-102664-1-1.html" target="_blank" rel="external">http://www.eoeandroid.com/thread-102664-1-1.html</a><br><a href="http://www.cnblogs.com/suinuaner/archive/2013/04/11/android_fifty.html" target="_blank" rel="external">http://www.cnblogs.com/suinuaner/archive/2013/04/11/android_fifty.html</a></p>
</blockquote>
<p>致命缺点，不能灵活控制其内部的线程池</p>
<ul>
<li>AsyncTast没有暴露出取消请求的方法，也就是我们熟知的CancelRequest方法，所以，一旦从A页面跳转到B页面，那么在A页面发起的请求，如果还没有返回，并不会被取消。</li>
<li>使用原生的ThreadPoolExecutor+Runnable+Handler</li>
<li>源码下载地址：<a href="http://files.cnblogs.com/files/Jax/2.1.4.zip" target="_blank" rel="external">http://files.cnblogs.com/files/Jax/2.1.4.zip</a></li>
</ul>
<h1 id="App数据缓存设计"><a href="#App数据缓存设计" class="headerlink" title="App数据缓存设计"></a>App数据缓存设计</h1><p>访问MobileAPI速度慢，主要慢在一来一回的传输速度上，</p>
<p><strong>对应措施，例如减少MobileAPI的调用次数，</strong></p>
<p>对于一个App页面，它一次性可能需要3部分数据，分别从3个MobileAPI接口获取，那么可以做一个新的MobileAPI接口，将这3部分数据都获取到一次性返回。</p>
<p>更极端的做法，APP在调用一次MobileAPI接口后，在一段时间内不再调用，仍然使用上次返回的数据，这些数据保存在APP上，我们称之为APP缓存，这个时间段我们称之为APP缓存时间。</p>
<p>App缓存智能针对GET类型接口，不适用于POST，对于GET类型接口也要看情况来设定缓存时间，或者不缓存。</p>
<p><strong>强制更新</strong></p>
<p>缓存是一把双刃剑，设置时间长了，数据长期不更新，用户体验就会不好，因此需要提供一个强制刷新的接口。</p>
<h1 id="MockService"><a href="#MockService" class="headerlink" title="MockService"></a>MockService</h1><p>（看起来像测试里面的桩模块。。。。）</p>
<p>因为App与MobileAPI之间的依赖，在MobileAPI接口还没好二APP又急等着用，或者随着App开发，App开发人员发现原来约定好的字段不够用等问题，要求MobileAPI开发人员频繁修改Mock接口并部署到测试环境。</p>
<p>为了提高效率，我们需要解除这种依赖，为此我们在App端设计自己的MockService，在App端Mock自己的数据。</p>
<h1 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h1><p><strong>登录成功后的各种场景</strong></p>
<p>情形1：点击登录按钮，进入登录页面，登陆成功后直接进入个人中心页面，一路执行startActivity即可</p>
<p>情形2：在页面A，想要跳转到页面B，并携带一些参数，却发现没有登录，于是先跳转到登录页面，登陆成功后跳转到B页面，同时仍携带那些参数</p>
<p>情形3：在页面A，执行某个操作，发现没有登录，于是跳转到登录界面，登录成功后，饭后页面A继续执行操作</p>
<p><strong>处理方法：</strong></p>
<p>1.对于情形2，在页面A，使用startActivityForResult，<br>2.在LoginActivity整合逻辑，通过判断，处理登录之后的操作，if(needCallback) setResult()，finish();<br>3.在LoginMainActivity重写onActivityResult毁掉函数switch(requestCode) </p>
<p><strong>自动登录</strong></p>
<p>最直接的做法是，登录之后，本地保存用户名和密码，重启App之后检测本地是否有保存用户名和密码，如果有，则将用户名和密码传入到登录接口，模拟用户登录行为。但是会有安全风险以及验证码的问题。</p>
<p>抛弃每次启动就进行一次登录的机制，使用在Web中很成熟的Cookie机制，也有人管Cookie叫Token，是用户身份的唯一性标志</p>
<p><strong>App端</strong></p>
<ol>
<li>每次发起MobileAPI请求时，都要把本地保存的Cookie取出来，放到HttpRequest的header中。</li>
<li>每次接受MobileAPI的响应结果是，都把HttpResponse的header中的Cookie取出来，覆盖本地保存的Cookie，不管Cookie是否有值。</li>
</ol>
<p><strong>服务器端相应操作</strong></p>
<ol>
<li>如果是用户信息相关操作，则判断HttpRequest中Cookie是否有效，如果有效，就去执行后去操作并返回结构，否则，返回Cookie过期失效的错误信息。</li>
<li>如果是用户无关的，则不需要检查HttpRequest中的Cookie，继续执行就可以了。</li>
</ol>
<p><strong>还有几个需要注意的地方</strong></p>
<ul>
<li>用户注销，清空本地保存的Cookie。</li>
<li>用户注册，因为验证码问题，不能直接调用登录接口，解决方案是，注册之后直接跳转到登录页面，让用户手动输入一次。或者把注册和登录接口绑定在一起，注册成功之后进入个人中心页面，不需要再登录一次。</li>
<li><p><strong>Cookie过期的统一处理</strong></p>
</li>
<li><p>服务器返回Cookie过期的错误消息</p>
</li>
<li>在RequestCallback中增加一种onCookieExpired回调方法，</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RequestCallback</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String conntent)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFail</span><span class="params">(String errorMessage)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCookieExpired</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在网络底层对JSON返回结果进行解析，如果发现是属于Cookie过期的错误类型，就直接回调onCookieExpired方法、</li>
</ul>
<p><strong>防止黑客刷库</strong></p>
<ul>
<li>使用验证码</li>
<li>MobileAPI发现有同一个IP短时间内频繁访问某一个MobileAPI接口是，就直接返回一段HTML5，要求用户输入验证码。App接收到这段代码时，就在页面上显示一个浮层，里面一个WebView，显示这个要求用户输入验证码的HTML5.</li>
</ul>
<h1 id="HTTP头中的奥妙"><a href="#HTTP头中的奥妙" class="headerlink" title="HTTP头中的奥妙"></a>HTTP头中的奥妙</h1><p>HTTP请求，分为HTTPRequest和HTTPResponse两种，但是无论哪种请求都由header和body两部分组成。</p>
<h2 id="HTTP-body"><a href="#HTTP-body" class="headerlink" title="HTTP body"></a>HTTP body</h2><p>对于get形式的HTTPRequest，要发送的数据都是以键值对的形式存放在URL上，比如aaa.api?k1=v1&amp;ke=v2。它的body是空的</p>
<p>对于post形式的HTTPRequest，要发送的数据都存在body里面，也是以键值对的形式。</p>
<h2 id="HTTP-header"><a href="#HTTP-header" class="headerlink" title="HTTP header"></a>HTTP header</h2><p>与body相比，header要丰富的多，它由很多键值对组成，其中有些key是标准的，兼容于各大浏览器，比如</p>
<ul>
<li>accept</li>
<li>accept-language</li>
<li>referrer</li>
<li>user-agent</li>
<li>accept-encoding</li>
</ul>
<p>此外我们还可以在MobileAPI端自定义一些键值对，然后要求App在调用MobileAPI时吧这些信息传递过来。</p>
<p><strong>时间校准</strong></p>
<p>MobileAPI端，永远使用UTC时间，包括入参合返回值，都不要使用Data格式，而是减去UTC时间1970年1月1日的差值，这是一个long型。</p>
<p>App端，每次调用MobileAPI，就取出HTTPRequest头的Data值，转换为GMT时间后，再减去本地取出的时间，得到一个差值delta。我们将这个delta保存下来，那么每次取本地时间的时候，再额外加上这个delta值，就得到服务GTM时间。</p>
<p><strong>开启gzip压缩</strong></p>
<p>使用gzip的流程如下：</p>
<ol>
<li>在App发起请求时，在HTTPRequest头中，添加要求支持gzip的key-value，这里的key是Accept-Encoding，value是gzip.</li>
<li>MobileAPI的逻辑是，检查HTTP请求头中的Accept-Encoding是否有gzip值，如果有，就会执行gzip压缩，如果执行了gzip压缩，那么返回值也就是HTTPResponse的头中，有一个content-encoding字段，会带有gzip的值；，否则，就没有这个值</li>
<li>App检查HTTPResponse头中的content-encoding字段是否包含gzip，这个值的有无，导致了App解析HTTPResponse的姿势不同。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://7xu1cb.com1.z0.glb.clouddn.com/IMG_0273.JPG"
               alt="TokgoLiang" />
          <p class="site-author-name" itemprop="name">TokgoLiang</p>
          <p class="site-description motion-element" itemprop="description">In me the tiger sniffs the rose.</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">16</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://qiushao.net/" title="qiushao的博客" target="_blank">qiushao的博客</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TokgoLiang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
