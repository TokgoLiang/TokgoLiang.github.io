<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="In me the tiger sniffs the rose.">
<meta property="og:type" content="website">
<meta property="og:title" content="TokgoLiang的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="TokgoLiang的博客">
<meta property="og:description" content="In me the tiger sniffs the rose.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TokgoLiang的博客">
<meta name="twitter:description" content="In me the tiger sniffs the rose.">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> TokgoLiang的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">TokgoLiang的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/18/第六章：Crash异常分析——Java语法、Activity、序列化、列表相关的异常/" itemprop="url">
                  第六章：Crash异常分析——Java语法、Activity、序列化、列表相关的异常
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-18T22:56:35+08:00" content="2016-09-18">
              2016-09-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Android_读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Android之所以存在千奇百怪的Crash，主要归结于一下几种情况</p>
<ol>
<li>Android系统的碎片化。</li>
<li>MobileAPI返回了脏数据。</li>
<li>混淆时没有Keep要使用的类或者方法。</li>
</ol>
<h1 id="Java语法相关的异常"><a href="#Java语法相关的异常" class="headerlink" title="Java语法相关的异常"></a>Java语法相关的异常</h1><h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><blockquote>
<p>异常中的关键字：NullPointException</p>
</blockquote>
<ol>
<li>方法需要对传入的参数判空后再使用</li>
<li>对于外部接口调用，需要确保返回值不为空，甚至需要确保执行该接口不会抛出其他异常导致程序退出</li>
<li>尽量不要使用全局变量，具体参见3.5节“消灭全局变量”</li>
</ol>
<h2 id="角标越界"><a href="#角标越界" class="headerlink" title="角标越界"></a>角标越界</h2><blockquote>
<p>异常中的关键字：IndexOutOfBoundsExpection，StringIndexOutOfBoundsExpection，ArrayIndexOutOfBoundsExpection</p>
</blockquote>
<p>这类Crash也是由于程序的不严谨导致，解决方案是：</p>
<ol>
<li>在遍历一个数组/集合时，要预判数组/集合是否为空，长度是否大于0</li>
<li>在使用数组/集合中的元素时，要预判数组/集合长度是否有这么长</li>
<li>字符串也是数组，在使用subString(start ,end)这样的函数时要注意start或者end</li>
</ol>
<h2 id="试图调用一个空对象的方法"><a href="#试图调用一个空对象的方法" class="headerlink" title="试图调用一个空对象的方法"></a>试图调用一个空对象的方法</h2><blockquote>
<p>异常中的关键字：Attempt to invoke virtual method on a null object reference</p>
</blockquote>
<p>常见情况：</p>
<ul>
<li>在if…else..的一个分支中初始化对象，程序未走这个分支</li>
<li>在ActivityA中调用ActivityB的方法，为此在B中建立一个static变量，当这个变量被回收时</li>
<li>点击推送消息，根据事先定好的协议，跳过首页直接进入二级甚至三级页面，这是二级页面要使用首页某个对象</li>
</ul>
<h2 id="类型转换异常"><a href="#类型转换异常" class="headerlink" title="类型转换异常"></a>类型转换异常</h2><blockquote>
<p>异常中的关键字：ClassCastException：Class A cannot be cast to classB</p>
</blockquote>
<p>这类Crash都是由强制类型转换导致的，解决方案是，使用安全类型转换，参加第一章，1.6节</p>
<h2 id="数字转换错误"><a href="#数字转换错误" class="headerlink" title="数字转换错误"></a>数字转换错误</h2><blockquote>
<p>异常中的关键字：NumberFormatException</p>
</blockquote>
<p>在数据类型转换过程中，如果转换不成功，一般抛出ClassCastException：Class 的异常，只有一个例外情况，当字符型转换为数字失败时，会抛出NumberFormatException</p>
<p>这种情况多发生在服务器返回数据，没有按照约定返回整数而死字符串，客户端必须要事先考虑到这种情况，如果转换失败，必须有默认值而不是直接奔溃。</p>
<h2 id="声明数组时长度为-1"><a href="#声明数组时长度为-1" class="headerlink" title="声明数组时长度为-1"></a>声明数组时长度为-1</h2><blockquote>
<p>异常中的关键字：NegativeArraySizeException</p>
</blockquote>
<p>当使用负数创建数组时会抛出该异常，但程序员不会犯int arr = new int[-1]；这样低级的错误，后来，作者发现了下述语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String[] arg1 = <span class="keyword">new</span> String[args.length - <span class="number">1</span>];</div></pre></td></tr></table></figure></p>
<p>当args数组中没有元素时，就会出现该异常，此外，声明int arr = new int[0];并不会报错，只是毫无意义。在声明一个数组时，如果数组长度是由另外一个变量动态得到的，要保证[]中的值必须大于0.</p>
<h2 id="遍历集合同时删除其中元素"><a href="#遍历集合同时删除其中元素" class="headerlink" title="遍历集合同时删除其中元素"></a>遍历集合同时删除其中元素</h2><blockquote>
<p>异常中的关键字：ConcurrentModificationException</p>
</blockquote>
<p>但凡有点编程常识的程序员都知道在遍历一个集合时不能删除该集合中的元素，，，解决方案是，再定义一个delList，用来保存需要删除的对象，</p>
<p>还有另外一种情况产生这种崩溃，那就是在多个线程中修改和遍历同一个集和。解决方法是，使用Copy-On-Write容器</p>
<h2 id="比较器使用不当"><a href="#比较器使用不当" class="headerlink" title="比较器使用不当"></a>比较器使用不当</h2><blockquote>
<p>异常中的关键字：Comarison method violastes its general contract!</p>
</blockquote>
<p>Comparator，是基于插入排序算法与归并排序算法相结合的产物，信息信息<a href="http://blog.2baxb.me/archives/993" target="_blank" rel="external">http://blog.2baxb.me/archives/993</a> </p>
<p><strong>正确的用法：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">List&lt;Double&gt; list = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</div><div class="line">list.add(<span class="number">11.4</span>);</div><div class="line">list.add(<span class="number">12.4</span>);</div><div class="line">list.add(<span class="number">11.4</span>);</div><div class="line">list.add(<span class="number">11.7</span>);</div><div class="line">Collections.sort(list, comparator);</div><div class="line">   Comparator&lt;Double&gt; comparator = <span class="keyword">new</span> Comparator&lt;Double&gt;() &#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Double lhs, Double rhs)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span>(lhs &lt; rhs) &#123;</div><div class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (lhs &gt; rhs) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>错误用法:（忽略了相等的情况）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Double&gt; comparator = <span class="keyword">new</span> Comparator&lt;Double&gt;() &#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Double lhs, Double rhs)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> lhs &gt; rhs ? <span class="number">1</span> : -<span class="number">1</span>;</div><div class="line">	&#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>为了预防这类Crash发生，作者的解决方案是，对每个自定义比较器进行单元测试。</p>
<h2 id="当除数为0"><a href="#当除数为0" class="headerlink" title="当除数为0"></a>当除数为0</h2><blockquote>
<p>异常中的关键字：java.lang.ArithmeticException:divide by zero</p>
</blockquote>
<p>多发生在第三方控件中，比如GifView，注意其中moive的duration，这个值表示动画的持续时间，在接下来得代码中将会作为除数，如果为0就会抛出上述异常，这时候要将其默认值设置为1.</p>
<h2 id="不能随便使用的asList"><a href="#不能随便使用的asList" class="headerlink" title="不能随便使用的asList"></a>不能随便使用的asList</h2><blockquote>
<p>异常中的关键字：<br>    java.lang.UnsupportedOperationException<br>    java.util.AbstraactList.remove(AbstractList.java:144) at<br>    java.util.AbstraactList$Itr.remove(AbstractList.java:306) at<br>    java.util.AbstraactCollection.remove(AbstractCollection.java:252) at</p>
</blockquote>
<p>Arrays.asList()的返回值类型为java.util.Array$ArrayList，而不是ArrayList，他两的父类都是AbstractList，但是只有ArrayList实现了父类的add和remove。</p>
<h2 id="又有类找不到了（一）：ClassNotFoundException"><a href="#又有类找不到了（一）：ClassNotFoundException" class="headerlink" title="又有类找不到了（一）：ClassNotFoundException"></a>又有类找不到了（一）：ClassNotFoundException</h2><blockquote>
<p>异常中的关键字：ClassNotFoundException</p>
</blockquote>
<p>常见原因：</p>
<ul>
<li>Class.forName(“com.company.package.class”);</li>
<li>ClassLoader中的findClass(classname);</li>
<li>ClassLoader中的loadClass(classname);</li>
</ul>
<h2 id="又有类找不到了（二）：NoClassDefFoundException"><a href="#又有类找不到了（二）：NoClassDefFoundException" class="headerlink" title="又有类找不到了（二）：NoClassDefFoundException"></a>又有类找不到了（二）：NoClassDefFoundException</h2><blockquote>
<p>异常中的关键字：NoClassDefFoundException</p>
</blockquote>
<p>在B类中声明一个A类的实例，ClassA obj = new ClassA();</p>
<p>但是打包是A和B分别位于不同的dex中，这时如果A所在的dex吧A删除了，那么在运行时候执行到这句就会抛出NoClassDefFoundException</p>
<p>通常插件化编程的时候会牵扯到这个异常。</p>
<h1 id="Activity相关的异常"><a href="#Activity相关的异常" class="headerlink" title="Activity相关的异常"></a>Activity相关的异常</h1><h2 id="找不到Activity"><a href="#找不到Activity" class="headerlink" title="找不到Activity"></a>找不到Activity</h2><blockquote>
<p>异常中的关键字：android.content.ActivityNotFoundException:No Activity found to handle Intent{…}</p>
</blockquote>
<p>出错原因：</p>
<ol>
<li><p>Uri不是以http开头</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Uri uri = Uri.parse(<span class="string">"www.baidu.com"</span>);</div><div class="line">Intent intent  = <span class="keyword">new</span> Intent(Intent.Action_VIEW, uri);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure>
</li>
<li><p>当我们要打开SD卡上的一个HTML页面时，没有为Intent指定打开该HTML的浏览器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Uri uri = Uri.parse(<span class="string">"file://sdcard/104.html"</span>);</div><div class="line">Intent intent  = <span class="keyword">new</span> Intent(Intent.Action_VIEW, uri);</div><div class="line"><span class="comment">//此处指定系统自带浏览器包名和Activity名称</span></div><div class="line"><span class="comment">//intent.setClassName("com.android.browser","com.android.browser.BrowserActivity");</span></div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure>
</li>
<li><p>如果调用百度地图的openBaiduMapNavi方法导致的Crash，有可能是没有安装百度地图客户端</p>
</li>
</ol>
<h2 id="不能实例化Activity"><a href="#不能实例化Activity" class="headerlink" title="不能实例化Activity"></a>不能实例化Activity</h2><blockquote>
<p>异常中的关键字：java.lang.RuntimeException:Unable to instantiate activity ComponentInfo</p>
</blockquote>
<p>通常是因为没有在AndroidManifest.xml文件中注册该Activity，或者在创建完Activity后，修改了包名或者类名，而配置清单中没有修改，还有可能是系统处于异常状态，关机，内存不足等。。</p>
<h2 id="找不到Service"><a href="#找不到Service" class="headerlink" title="找不到Service"></a>找不到Service</h2><blockquote>
<p>异常中的关键字：java.lang.RuntimeException:Unable to instantiate service</p>
</blockquote>
<p>对于Manifest文件中写错的类似问题就不研究了。</p>
<p>首先检查代码中是否有Class.forName(“class1”)这样的语句，对于此，ProGuard会将class1混淆，从而找不到class1这个类。        </p>
<h2 id="不能启动BroadcastReceiver"><a href="#不能启动BroadcastReceiver" class="headerlink" title="不能启动BroadcastReceiver"></a>不能启动BroadcastReceiver</h2><blockquote>
<p>异常中的关键字：Unable to start receiver</p>
</blockquote>
<p>在使用Activity以外的context来startActivity，会抛出以上异常，<br>解决方法：  intent.addFlags(intent.FLAG_ACTIVITY_NEW_TASK);</p>
<p>作者这里提到了setFlags和addFlags，但是没有没有说两者的区别，这里我把源码贴出来<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">setFlags</span><span class="params">(<span class="keyword">int</span> flags)</span> </span>&#123;</div><div class="line">    mFlags = flags;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">addFlags</span><span class="params">(<span class="keyword">int</span> flags)</span> </span>&#123;</div><div class="line">    mFlags |= flags;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>作者推荐<a href="http://www.it165.net/pro/html/201406/15547.html" target="_blank" rel="external">http://www.it165.net/pro/html/201406/15547.html</a></p>
<h2 id="startActivityForResult不能回传"><a href="#startActivityForResult不能回传" class="headerlink" title="startActivityForResult不能回传"></a>startActivityForResult不能回传</h2><blockquote>
<p>异常中的关键字：Failure delivering result ResultInfo{who=null,request=0,result=-1}</p>
</blockquote>
<p>导致原因：传回来的key是A，但是却按照B这个key来取值</p>
<h2 id="猴急的Fragment"><a href="#猴急的Fragment" class="headerlink" title="猴急的Fragment"></a>猴急的Fragment</h2><blockquote>
<p>异常中的关键字：Fragment not attached to Activity</p>
</blockquote>
<p>导致原因：Fragment还没有Attach到Activity时，调用了诸如getResource这样的方法。</p>
<p>解决方法：加isAdded判断<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(isAdded) &#123;</div><div class="line">    getResources().getString(R.string.app_name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="序列化相关的异常"><a href="#序列化相关的异常" class="headerlink" title="序列化相关的异常"></a>序列化相关的异常</h1><p>Android中的序列化分两种，一种是Java原生的Serializable，另一种是Android为了提升性能而量身打造的Parcelable。</p>
<h2 id="实体对象不支持序列化"><a href="#实体对象不支持序列化" class="headerlink" title="实体对象不支持序列化"></a>实体对象不支持序列化</h2><blockquote>
<p>异常中的关键字：Parcelable encountered IOException writing serializable object </p>
</blockquote>
<p>不仅类自身要实现Serializable/Parcelable，类中的成员变量也要支持序列化<br>提示：JSONObject，JSONArray不支持序列化。</p>
<h2 id="序列化时未指定ClassLoader"><a href="#序列化时未指定ClassLoader" class="headerlink" title="序列化时未指定ClassLoader"></a>序列化时未指定ClassLoader</h2><blockquote>
<p>异常中的关键字：BadParcelableException:</p>
</blockquote>
<p>在使用Parcelable机制的时候，会遇到上述异常，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyParcelable</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String mStr;</div><div class="line">    <span class="keyword">private</span> ClassA a;</div><div class="line">    ......</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyParcelable</span><span class="params">(Parcel in)</span> </span>&#123;</div><div class="line">        mStr = in.readString();</div><div class="line">        a = in.readParcelable(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>崩溃出在最后一句，对a的反序列化上，改为 a= in.readParcelable(ClassA.class.getClassLoader());就不会崩溃了。</p>
<p><strong>ClassLoader的概念：</strong></p>
<p>当ClassLoader为空时，系统会采用默认的ClassLoader。</p>
<p>Android有两种不同的ClassLoader：framework ClassLoader和apk ClassLoader，其中framework ClassLoader只知道怎么加载Android系统内部的类，apk ClassLoader即知道怎么加载我们自己写的类，也知道怎么加载Android系统内部的类。</p>
<p>在App刚启动的时候，默认ClassLoader是apk ClassLoader，但在系统内存不足应用被系统回收再次启动，默认的ClassLoader会变为framework ClassLoader，所以对我们自己的类会报ClassNotFoundException。</p>
<h2 id="反序列化时发现类找不到：被ProGuard混淆导致的崩溃"><a href="#反序列化时发现类找不到：被ProGuard混淆导致的崩溃" class="headerlink" title="反序列化时发现类找不到：被ProGuard混淆导致的崩溃"></a>反序列化时发现类找不到：被ProGuard混淆导致的崩溃</h2><blockquote>
<p>异常中的关键字：Parcelable encountered ClassNotFoundException reading a Serializable object…..</p>
</blockquote>
<p>ProGuard对于Class.forName(className)中的class是无能为力的，它会将这个class混淆的面目全非，于是在反序列化这个类的时候却发现找不到这个类了</p>
<p>解决方案：在ProGuard文件中keep这个类</p>
<h2 id="反序列化出错"><a href="#反序列化出错" class="headerlink" title="反序列化出错"></a>反序列化出错</h2><blockquote>
<p>异常中的关键字：Could not read input Chanel file descriptors from parcel …..</p>
</blockquote>
<p>出现这个异常，一般是因为Intent传递的数据太大了，貌似大于1MB就会崩溃。</p>
<p>此外，网上也有人说是因为FileDescripter太多而且没有关闭，或looper太多没有退出而导致的，仅供参考。</p>
<h1 id="列表相关的异常"><a href="#列表相关的异常" class="headerlink" title="列表相关的异常"></a>列表相关的异常</h1><p>在有Adapter的地方就有ListView，就有因此而产生的异常。这些异常基本是因为下拉刷新数据时处理不当导致的。这主要是Android本身没有提供标准的下拉刷新数据的列表控件，而网上的千奇百怪的下拉刷新控件有都有这样那样的缺陷。分装的再完善的下拉刷新列表空间，也只能确保在大部分急性上工作良好。</p>
<h2 id="Adapter数据源变化但是没有通知ListView"><a href="#Adapter数据源变化但是没有通知ListView" class="headerlink" title="Adapter数据源变化但是没有通知ListView"></a>Adapter数据源变化但是没有通知ListView</h2><blockquote>
<p>异常中的关键字：The content of the adapter has changed but ListView did not receive a notification.Make sure the content of your adapter is not modified from a background thread,but only from the UI thread.</p>
</blockquote>
<p>就是说Adapter内部变化了，但是没哟通知相应的ListView，请保证Adapter的数据在主线程修改。</p>
<p>解决方案：</p>
<p>首先，一种极端的方案是，每次设置Adapter中的集合数据时，都要将其clone一份，而不是直接传递一个集合过来，但是这样会比较消耗性能。</p>
<p>其次，要确保每次在Activity中设置adapter的值，而不是在后台线程，有以下几种办法：</p>
<ol>
<li><p>调用Activity的runOnUIThread()方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">    <span class="keyword">new</span> Thread()&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">            MainActivity.<span class="keyword">this</span>.runOnUiThread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    textView1.setText(<span class="string">"Hello World!"</span>);   </div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>调用Handler，通知主线程修改Adapter，</p>
</li>
<li><p>使用AsyncTask也是一个不错的选择，虽然他也有很多缺陷</p>
</li>
</ol>
<p>最后，只要修改了adapter机集合数据的值，就要马上调用notifyDataSetChanged方法。</p>
<h2 id="ListView滚动时点击刷新按钮后崩溃"><a href="#ListView滚动时点击刷新按钮后崩溃" class="headerlink" title="ListView滚动时点击刷新按钮后崩溃"></a>ListView滚动时点击刷新按钮后崩溃</h2><blockquote>
<p>异常中的关键字：java.lang.IndexOutOfBoundsException:Invalid index….                               java.util.ArrayList.throwIndexOutOfBoundsException<br>java.util.ArrayList.get(ArrayList.java:304) at android.widget.HeaderViewListAdapter.getView(HeaderViewListAdapter.java225)  </p>
</blockquote>
<p>ListView滚动的时候，表示它已经获取了adapter的getCounts()，可能是30或者更大，回调getView(),这时候将数据clear掉了，所以奔溃</p>
<p>解决方案是，ListView滚动的时候，将刷新按钮设置为可以点击，如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> refresh&#123;</div><div class="line">    startLocation()；</div><div class="line">    pageNo = <span class="number">0</span>;</div><div class="line">    hasMore = <span class="keyword">true</span>;</div><div class="line">    dataList.clear();</div><div class="line">    moreBtn.setVisibility(View.GONE);</div><div class="line">    loadFirstPageData();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="AbsListView的obtainView返回空指针"><a href="#AbsListView的obtainView返回空指针" class="headerlink" title="AbsListView的obtainView返回空指针"></a>AbsListView的obtainView返回空指针</h2><blockquote>
<p>异常中的关键字：java.lang.NullPointerException at android.widget.AbsListView.obtainView(AbsListView.java:1521)at android.widget.ListView.makeAndAddView</p>
</blockquote>
<p>导致空指针的罪魁祸首就是AbsListview的obtainView方法获取不到View，究其原因，是getView方法在某些时候返回了null。解决方案很简单，getView的第二个参数是不会为null的，在getView返回值的时候判断一下是否为空，如果为null，怎返货convertView。</p>
<h2 id="Adapter数据源变化但是没有调用notifyDataSetChanged"><a href="#Adapter数据源变化但是没有调用notifyDataSetChanged" class="headerlink" title="Adapter数据源变化但是没有调用notifyDataSetChanged"></a>Adapter数据源变化但是没有调用notifyDataSetChanged</h2><blockquote>
<p>异常中的关键字：The applications PagerAdapter changed the adapters contents without calling PagerAdapter#notifyDataSetChanged</p>
</blockquote>
<p>PagerAdapter对于notifyDataSetChanged()和getCount的执行顺序是非常严格的，系统跟踪count的值，如果这个值和getCount返回的值不一致，就会抛出这个异常。所以为了保证getCount总是返回一个正确的值，那么在初始化ViewPager时，应先给adapter初始化内容后再将该adapter传给ViewPager，如果不这样处理，在更新adapter的内容后，应该调用一下notifyDataSetChanged。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/17/第五章：Crash异常收集与统计/" itemprop="url">
                  第五章：Crash异常收集与统计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-17T22:24:00+08:00" content="2016-09-17">
              2016-09-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Android_读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>Crash分析三部曲：收集，统计，分析</strong></p>
</blockquote>
<h1 id="异常收集"><a href="#异常收集" class="headerlink" title="异常收集"></a>异常收集</h1><p>设计一个CrashHandler，使之继承UncaugthExceptionHandler，来定义我们自己的异常捕获逻辑，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.Thread.UncaughtExceptionHandler;</div><div class="line"><span class="keyword">import</span> android.os.Environment;</div><div class="line"><span class="keyword">import</span> android.os.Looper;</div><div class="line"><span class="keyword">import</span> android.util.Log;</div><div class="line"><span class="keyword">import</span> android.widget.Toast;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrashHandler</span> <span class="keyword">implements</span> <span class="title">UncaughtExceptionHandler</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"CrashHandler"</span>;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String APP_CACHE_PATH = </div><div class="line">			Environment.getExternalStorageDirectory().getPath() + <span class="string">"/crash/"</span>;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread thread, Throwable ex)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span>(handeException(ex) &amp;&amp; mDefaultHander != <span class="keyword">null</span>) &#123;</div><div class="line">			mDefaultHander.uncaughtException(thread, ex);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				Thread.sleep(<span class="number">3000</span>);</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				Log.e(TAG, <span class="string">"error"</span>, e);</div><div class="line">			&#125;</div><div class="line">			android.os.Process.killProcess(android.os.Process.myPid());</div><div class="line">			System.exit(<span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">handeException</span><span class="params">(Throwable ex)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span>(<span class="keyword">null</span> == ex) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//把Crash发送到服务器</span></div><div class="line">		sendCrashToServer();</div><div class="line">		</div><div class="line">		<span class="comment">//使用Toast来显示异常信息</span></div><div class="line">		<span class="keyword">new</span> Thread() &#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				Looper.prepare();</div><div class="line">				Toast.makeText(context, <span class="string">"很抱歉，程序出现异常，即将退出。"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">				Looper.loop();</div><div class="line">			&#125;;</div><div class="line">		&#125;.start();</div><div class="line">		</div><div class="line">		<span class="comment">//保存日志文件</span></div><div class="line">		saveCrashInfoFile(ex);</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sendCrashToServer方法负责将捕获的异常发送到服务器，为此需要MobileAPI提供一个接口，建表存储接受的数据</p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>自增id</td>
</tr>
<tr>
<td>app_name</td>
<td>Crash所在App</td>
</tr>
<tr>
<td>page_name</td>
<td>Crash所在Activity</td>
</tr>
<tr>
<td>exception_name</td>
<td>Crash名称</td>
</tr>
<tr>
<td>exception_stack</td>
<td>Crash详细信息</td>
</tr>
<tr>
<td>crash_type</td>
<td>1表示崩溃，0表示被try-catch捕获到</td>
</tr>
<tr>
<td>app_version</td>
<td>当前App版本</td>
</tr>
<tr>
<td>os_vesion</td>
<td>Android系统版本</td>
</tr>
<tr>
<td>devic_model</td>
<td>Android设备型号</td>
</tr>
<tr>
<td>device_id</td>
<td>Android设备编号</td>
</tr>
<tr>
<td>network_type</td>
<td>网络类型，是否为wifi</td>
</tr>
<tr>
<td>channel_id</td>
<td>渠道号</td>
</tr>
<tr>
<td>clien_type</td>
<td>设备类型，Android/IOS</td>
</tr>
<tr>
<td>memory_info</td>
<td>Crash发生时内存使用情况</td>
</tr>
<tr>
<td>crash_time</td>
<td>Crash发生时间，在插入数据库是由系统自动生成</td>
</tr>
</tbody>
</table>
<p>需要注意的是，如果异常在Activity中被捕获到，就不会再交由Application级别的CrashHandler处理，所以我们要在这个Activity的try…catch…语句中手动吧异常信息发送到服务器。在具体的Activity中，将CrashType设置为0；在Crash中景CrashType设置为1。</p>
<h1 id="异常的收集与统计"><a href="#异常的收集与统计" class="headerlink" title="异常的收集与统计"></a>异常的收集与统计</h1><p>目前对APP线上Crash的收集一般有2中，要么记录到第三方平台，要么记录到自己的数据库。使用第三方平台的好处是，他们能提供一套完整的Crash分类和报表统计工具。比如腾讯的Bugly平台。</p>
<p><strong>人工统计线上Crash数据</strong></p>
<p>作者在分析中发现：</p>
<ol>
<li>有很多重复的Crash，这其中分很多种情况：<ul>
<li>有不同设备在不同时间发出来重复的Crash</li>
<li>有不同设备在同一时间法宠重复的Crash</li>
<li>相同设备在很短时间段内频繁发送了重复的Crash</li>
</ul>
</li>
<li>每笔异常信息都包括了以下2个部分数据信息<ul>
<li>exception_name：Crash对应的异常名称</li>
<li>exception_stack：Crash的详细信息，Cash真正原因所在</li>
</ul>
</li>
<li>exception_stack中含有OutOfMemory内容的，都是内存已溢出导致的，但是逆命题不成立！</li>
<li>对于NullPointerException，我们要留意exception_stack中Cause by后面的内容</li>
<li>窗体泄露类问题，基本都是想要关闭弹出框的时候，却发现它的载体宿主已经不在。</li>
<li>ListView和Adapter相关的Crash基本都发生在分页获取数据的场景，数据源改变，却没有及时通知ListView和Adap</li>
</ol>
<p><strong>第一个线上Crash报表：Crash分类</strong></p>
<ol>
<li>首先，每天上班，把昨天24小时的Crash数据下载，导出为excel文件，然后还原到本地数据库CrashDB这个表。</li>
<li>把Crash分类，为CrashDB加一个字段crash_desc，用来表明Crash是哪个类别的。UpdateCrashStore</li>
<li>统计各类Crash。GroupOnlineCrash</li>
</ol>
<p><a href="http://www.cnblogs.com/Jax/p/4573575.html" title="详细代码" target="_blank" rel="external">详细代码</a></p>
<p><strong>第二个线上Crash报表：Crash去重</strong></p>
<ol>
<li>去除数字不同导致的重复</li>
</ol>
<ul>
<li>发生奔溃时的代码行不同</li>
<li>运行时的数值不同</li>
<li>在CrashDB表再添加一个字段dis_info，把exception_desc字段的数据复制到dis_info，然后修改dis_info,借助正则表达式，进行批量替换</li>
</ul>
<ol>
<li>去除其他情况的重复<br>　　有很多Crash信息，它们仅仅是长度不同，解决方案是，对exception_stack从起始位置去150个字符去重（150来自实践）。</li>
<li>去除同一版本之前的重复<br>　　包今天的线上Crash放到一个数据表CrashStore中，对于第二天的线上Crash，先到CrashStore中去重，剩下的Crash数据就是新的。</li>
<li>按照Activity，把Crash自动分发到人</li>
</ol>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/Crash%E5%88%86%E5%8F%91.png" alt="Crash分发流程"></p>
<p><strong>线上Crash的其他分析工作</strong></p>
<ol>
<li>Crash进行归纳，从而知道每类Crash发生的次数，涉及的机型，涉及的Android系统版本</li>
<li>目前第三方平台的Crash统计工具是即时的，，而不是要等到一天结束后才一起进行分析</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/14/第四章：Android命名规范和编码规范/" itemprop="url">
                  第四章：Android命名规范和编码规范
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-14T22:31:06+08:00" content="2016-09-14">
              2016-09-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Android_读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>制定规范不需要太多的理论知识，只要记住两点就够了：尽量简单，多写注释！</p>
</blockquote>
<p><strong>但是也很多人认为注释是越少也好，我更赞同，当然这是建立在你的代码非常容易理解的基础之上！！</strong></p>
<h1 id="Android命名规范"><a href="#Android命名规范" class="headerlink" title="Android命名规范"></a>Android命名规范</h1><h2 id="Java类文件命名规范"><a href="#Java类文件命名规范" class="headerlink" title="Java类文件命名规范"></a>Java类文件命名规范</h2><ul>
<li>Activity：以Activity作为后缀，比如PersonActivity。</li>
<li>Adapter：以Adapter作为后缀，比如PersonAdapter。</li>
<li>Entity：大多以Entity作为后缀，比如PersonEntity，值得注意的是User是全局变量，不算是实体，不受此约束。</li>
</ul>
<h2 id="资源文件命名规范"><a href="#资源文件命名规范" class="headerlink" title="资源文件命名规范"></a>资源文件命名规范</h2><p><strong>layout目录下的文件</strong></p>
<ul>
<li>页面布局文件，以act_为前缀，Activity所在Package为中缀，Activity名称（去掉Activity）作为后缀，都是小写。例如Person模块下AddCustomerActivity对应的layout文件该是：act_person_addcustomer，不过我自己习惯activity_add_customer；</li>
<li>ListView中的item布局文件，以item_为前缀，列表项的名称为后缀，如item_users;</li>
<li>Dialog布局文件，以dlg_为前缀，Dialog的功能名称为后缀，如dlg_hint，我还是习惯dialog_hint。</li>
</ul>
<p><strong>drawable（或者mipmap）目录下文件命名规范：</strong></p>
<ul>
<li>drawable目录下的资源，大部分是图片，此外，还有一部分xml文件。无论是图片还是xml文件，都应该遵循以下的命名规范：</li>
<li>对于只在一个页面使用的资源，就以该页面的名称做前缀。</li>
<li>对于只在一个模块下多个页面是用的资源，就以该模块的名称作为前缀，</li>
<li>对于在各个模块，各个页面都有可能使用的资源，比如上导航，下导航，，以common最为前缀。</li>
</ul>
<h2 id="Java类中控件对象命名规范"><a href="#Java类中控件对象命名规范" class="headerlink" title="Java类中控件对象命名规范"></a>Java类中控件对象命名规范</h2><p>控件类型缩写+控件逻辑名称，如btnLogin</p>
<h2 id="Layout中控件对象命名规范"><a href="#Layout中控件对象命名规范" class="headerlink" title="Layout中控件对象命名规范"></a>Layout中控件对象命名规范</h2><ul>
<li>形式一：和Activity中对应的控件名保持一致</li>
<li>形式二：功能名_控件类型，如login_button</li>
</ul>
<p>我还是习惯btn_login</p>
<h2 id="strings-xml中常量命名规范"><a href="#strings-xml中常量命名规范" class="headerlink" title="strings.xml中常量命名规范"></a>strings.xml中常量命名规范</h2><p>出现在Activity或者Layout中的，Activity名作为前缀，后面接控件名称，在后面随意例如loginActivity_btnLogin_text(我不习惯这样的。。)，如果涉及和公共模块相关，则以common做前缀</p>
<h2 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h2><p>遵循Java的命名规范，只包含字母和下划线，字母全部大写，单词之间用下划线隔开</p>
<h1 id="Android编码规范"><a href="#Android编码规范" class="headerlink" title="Android编码规范"></a>Android编码规范</h1><ol>
<li>要分门别类的存放各种类，</li>
<li><p>findViewById，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">TextView tvName;</div><div class="line">initView() &#123;</div><div class="line">    tvName = (TextView) findViewById(R.id.tv_name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Layout中的常量，要在strings.xml中定义，</p>
</li>
<li>Layout中所有控件的字体大小，都定义在dinens.xml中</li>
<li>在Activity中定义新的生命周期<ul>
<li>initVariables：初始化变量，包括Intent带的数据和Activity内的变量</li>
<li>initViews：加载Layout布局文件，初始化控件，为控件挂上事件的方法</li>
<li>loadData：获取数据</li>
</ul>
</li>
<li>坚持使用fastJSON自定义实体来作为MobileAPI的数据载体（不知道为什么不提GSON。。）<br>像JSONObject，JSONArray，Map<string, object="">，ArrayList&lt; Object&gt;,这些不能序列化的实体，都禁止使用，除非仅仅是在方法内部。</string,></li>
<li>页面之间传值，坚持使用Intent携带序列化实体数据的方式，禁止为了方便使用全局变量</li>
<li>为控件添加事件，使用匿名内部类</li>
<li>Activity中不要嵌套内部类，</li>
<li>Adapter的编码规范<ul>
<li>所有Adapter，都放在adapter这个包中</li>
<li>Adapter绑定的数据，一律为ArrayList&lt;自定义可序列化实体&gt;</li>
<li>在Adapter中创建适合于列表自身的ViewHolder实体类，统一命名为ViewHolder</li>
</ul>
</li>
<li>实体类不要再不同模块之间共享，但是可以在同一模块的不同页面之间共享</li>
<li>为了节省内存，可以使用ArrayList而不是HashMap</li>
<li>大量的图片，使用ImageLoader或者Fresco来进行异步加载</li>
<li>什么时候使用SharedPreferences？简单配置信息，设置页面的各种开关。但是对于复杂的对象，还是要存储到本地文件中。</li>
<li>尽量使用ApplicationContext代替Context，否则会引起内存泄露，当然也不是任何地方都适用。</li>
<li>数据类型转换一定要进行验证。</li>
<li>使用常量代替枚举，</li>
</ol>
<h1 id="统一代码格式"><a href="#统一代码格式" class="headerlink" title="统一代码格式"></a>统一代码格式</h1><p>在Eclipse中导入Android源码中用于统一代码格式的android-formatting.xml，然后执行快键键Ctrl+shift+f，</p>
<p>导入方法如下：window–preference–Java–code style–Formatter 导入android-formatting.xml</p>
<p>推荐一个自动检查工具，checkstyle，</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/13/理解Android编译命令/" itemprop="url">
                  理解Android编译命令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-13T23:21:50+08:00" content="2016-09-13">
              2016-09-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Other/" itemprop="url" rel="index">
                    <span itemprop="name">Other</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://gityuan.com/2016/03/19/android-build/" target="_blank" rel="external">TokgoLiang——转载别人的原文链接一定要写在开头</a></p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>关于Android Build系统，这个话题很早就打算整理下，迟迟没有下笔，决定跟大家分享下。先看下面几条指令，相信编译过Android源码的人都再熟悉不过的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">source</span> setenv.sh</div><div class="line">lunch</div><div class="line">make -j12</div></pre></td></tr></table></figure>
<p>记得最初刚接触Android时，同事告诉我用上面的指令就可以编译Android源码，指令虽短但过几天就记不全或者忘记顺序，每次编译时还需要看看自己的云笔记，冰冷的指令总是难以让我记忆。后来我决定认真研究下这个指令的含义。知其然还需知其所以然，这样能更深层次的理解并记忆，才能与自身的知识体系建立强连接，或许还有意外收获，果然如此，接下来跟大家分享一下在研究上述几条指令含义的过程中，深入了解到的Android Build(编译)系统。</p>
<h1 id="编译命令"><a href="#编译命令" class="headerlink" title="编译命令"></a>编译命令</h1><p>准备好编译环境后，编译Android源码的第一步是 <em>source build/envsetup.sh</em>，其中source命令就是用于运行shell脚本命令，功能等价于”.”，因此该命令也等价于<em>. build/envsetup.sh</em>。在文件<em>envsetup.sh</em>声明了当前会话终端可用的命令，这里需要注意的是当前会话终端，也就意味着每次新打开一个终端都必须再一次执行这些指令。起初并不理解为什么新开的终端不能直接执行make指令，到这里总算明白了。</p>
<p>接下来，解释一下本文开头的引用的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">source</span> setenv.sh  //初始化编译环境，包括后面的lunch和make指令</div><div class="line">lunch  //指定此次编译的目标设备以及编译类型</div><div class="line">make  -j12 //开始编译，默认为编译整个系统，其中-j12代表的是编译的job数量为12。</div></pre></td></tr></table></figure>
<p>所有的编译命令都在<em>envsetup.sh</em>文件能找到相对应的function，比如上述的命令<em>lunch</em>，<em>make</em>，在文件一定能找到</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">lunch</span></span>()&#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">make</span></span>()&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>source envsetup.sh</em>，需要cd到setenv.sh文件所在路径执行，路径可能在build/envsetup.sh，或者integrate/envsetup.sh，再或者不排除有些厂商会封装自己的.sh脚本，但核心思路是一致的。</p>
<p>具体实现这里就不展开说明，下面精炼地总结了一下各个指令用法和功效。</p>
<h2 id="代码编译"><a href="#代码编译" class="headerlink" title="代码编译"></a>代码编译</h2><table>
<thead>
<tr>
<th>编译指令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>m</td>
<td>在源码树的根目录执行编译</td>
</tr>
<tr>
<td>mm</td>
<td>编译当前路径下所有模块，但不包含依赖</td>
</tr>
<tr>
<td>mmm [module_path]</td>
<td>编译指定路径下所有模块，但不包含依赖</td>
</tr>
<tr>
<td>mma</td>
<td>编译当前路径下所有模块，且包含依赖</td>
</tr>
<tr>
<td>mmma [module_path]</td>
<td>编译指定路径下所有模块，且包含依赖</td>
</tr>
<tr>
<td>make [module_name]</td>
<td>无参数，则表示编译整个Android代码</td>
</tr>
</tbody>
</table>
<p>下面列举部分模块的编译指令：</p>
<table>
<thead>
<tr>
<th>模块</th>
<th>make命令</th>
<th>mmm命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>init</td>
<td>make init</td>
<td>mmm system/core/init</td>
</tr>
<tr>
<td>zygote</td>
<td>make app_process</td>
<td>mmm frameworks/base/cmds/app_process</td>
</tr>
<tr>
<td>system_server</td>
<td>make services</td>
<td>mmm frameworks/base/services</td>
</tr>
<tr>
<td>java framework</td>
<td>make framework</td>
<td>mmm frameworks/base</td>
</tr>
<tr>
<td>framework资源</td>
<td>make framework-res</td>
<td>mmm frameworks/base/core/res</td>
</tr>
<tr>
<td>jni framework</td>
<td>make libandroid_runtime</td>
<td>mmm frameworks/base/core/jni</td>
</tr>
<tr>
<td>binder</td>
<td>make libbinder</td>
<td>mmm frameworks/native/libs/binder</td>
</tr>
</tbody>
</table>
<p>上述mmm命令同样适用于mm/mma/mmma，编译系统采用的是增量编译，只会编译发生变化的目标文件。当需要重新编译所有的相关模块，则需要编译命令后增加参数-B，比如make -B [module_name]，或者 mm -B [module_path]。</p>
<p>Tips:</p>
<ul>
<li>对于m、mm、mmm、mma、mmma这些命令的实现都是通过make方式来完成的。</li>
<li>mmm/mm编译的效率很高，而make/mma/mmma编译较缓慢；</li>
<li>make/mma/mmma编译时会把所有的依赖模块一同编译，但mmm/mm不会;</li>
<li>建议：首次编译时采用make/mma/mmma编译；当依赖模块已经编译过的情况，则使用mmm/mm编译。</li>
</ul>
<h2 id="代码搜索"><a href="#代码搜索" class="headerlink" title="代码搜索"></a>代码搜索</h2><table>
<thead>
<tr>
<th>搜索指令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>cgrep</td>
<td>所有C/C++文件执行搜索操作</td>
</tr>
<tr>
<td>jgrep</td>
<td>所有Java文件执行搜索操作</td>
</tr>
<tr>
<td>ggrep</td>
<td>所有Gradle文件执行搜索操作</td>
</tr>
<tr>
<td>mangrep [keyword]</td>
<td>所有AndroidManifest.xml文件执行搜索操作</td>
</tr>
<tr>
<td>mgrep [keyword]</td>
<td>所有Android.mk文件执行搜索操作</td>
</tr>
<tr>
<td>sepgrep [keyword]</td>
<td>所有sepolicy文件执行搜索操作</td>
</tr>
<tr>
<td>resgrep [keyword]</td>
<td>所有本地res/*.xml文件执行搜索操作</td>
</tr>
<tr>
<td>sgrep [keyword]</td>
<td>所有资源文件执行搜索操作</td>
</tr>
</tbody>
</table>
<p>上述指令用法最终实现方式都是基于<em>grep</em>指令，各个指令用法格式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">xgrep [keyword]  //x代表的是上表的搜索指令</div><div class="line">``` </div><div class="line"></div><div class="line">例如，搜索所有AndroidManifest.xml文件中的*launcher*关键字所在文件的具体位置，指令</div><div class="line">``` bash</div><div class="line">mangrep launcher</div></pre></td></tr></table></figure></p>
<p>再如，搜索所有Java代码中包含<em>zygote</em>所在文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jgrep zygote</div></pre></td></tr></table></figure></p>
<p>又如，搜索所有system_app的selinux权限信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sepgrep system_app</div></pre></td></tr></table></figure></p>
<p>Tips: Android源码非常庞大，直接采用grep来搜索代码，不仅方法笨拙、浪费时间，而且搜索出很多无意义的混淆结果。根据具体需求，来选择合适的代码搜索指令，能节省代码搜索时间，提高搜索结果的精准度，方便定位目标代码。</p>
<h2 id="导航指令"><a href="#导航指令" class="headerlink" title="导航指令"></a>导航指令</h2><table>
<thead>
<tr>
<th>导航指令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>croot</td>
<td>切换至Android根目录</td>
</tr>
<tr>
<td>cproj</td>
<td>切换至工程的根目录</td>
</tr>
<tr>
<td>godir [filename]</td>
<td>跳转到包含某个文件的目录</td>
</tr>
</tbody>
</table>
<p>Tips: 当每次修改完某个文件后需要编译时，执行cproj后会跳转到当前模块的根目录，也就是Android.mk文件所在目录，然后再执行mm指令，即可编译目标模块；当进入源码层级很深后，需要返回到根目录，使用croot一条指令完成；另外cd - 指令可用于快速切换至上次目录。</p>
<h2 id="信息查询"><a href="#信息查询" class="headerlink" title="信息查询"></a>信息查询</h2><table>
<thead>
<tr>
<th>查询指令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>hmm</td>
<td>查询所有的指令help信息</td>
</tr>
<tr>
<td>findmakefile</td>
<td>查询当前目录所在工程的Android.mk文件路径</td>
</tr>
<tr>
<td>print_lunch_menu</td>
<td>查询lunch可选的product</td>
</tr>
<tr>
<td>printconfig</td>
<td>查询各项编译变量值</td>
</tr>
<tr>
<td>gettop</td>
<td>查询Android源码的根目录</td>
</tr>
<tr>
<td>gettargetarch</td>
<td>获取TARGET_ARCH值</td>
</tr>
</tbody>
</table>
<h2 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h2><p>上述只是列举比较常用的指令，还有其他指令，而且不同的build编译系统，支持的指令可能会存在一些差异，当忘记这些编译指令，可以通过执行hmm，查询指令的帮助信息。</p>
<p>最后再列举两个比较常用的指令：</p>
<ul>
<li>make clean：执行清理操作，等价于 rm -rf out/</li>
<li>make update-api：更新API，在framework API改动后需执行该指令，Api记录在目录frameworks/base/api；</li>
</ul>
<h1 id="编译系统"><a href="#编译系统" class="headerlink" title="编译系统"></a>编译系统</h1><p>Android 编译系统是Android源码的一部分，用于编译Android系统，Android SDK以及相关文档。该编译系统是由Make文件、Shell以及Python脚本共同组成，其中最为重要的便是Make文件。关于编译系统可参考 <a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/" title="理解 Android Build 系统" target="_blank" rel="external">理解 Android Build 系统</a>。</p>
<h2 id="Makefile分类"><a href="#Makefile分类" class="headerlink" title="Makefile分类"></a>Makefile分类</h2><p>整个Build系统的Make文件分为三大类：</p>
<ul>
<li>系统核心的Make文件：定义了Build系统的框架，文件全部位于路径/build/core，其他Make文件都是基于该框架编写的；</li>
<li>针对产品的Make文件：定义了具体某个型号手机的Make文件，文件路径位于/device，该目录下往往又以公司名和产品名划分两个子级目录，比如/device/qcom/msm8916；</li>
<li>针对模块的Make文件：整个系统分为各个独立的模块，每个模块都一个专门的Make文件，名称统一为”Android.mk”，该文件定义了当前模块的编译方式。Build系统会扫描整个源码树中名为”Android.mk”的问题，并执行相应模块的编译工作。</li>
</ul>
<h2 id="编译产物"><a href="#编译产物" class="headerlink" title="编译产物"></a>编译产物</h2><p>经过make编译后的产物，都位于/out目录，该目录下主要关注下面几个目录：</p>
<ul>
<li>/out/host：Android开发工具的产物，包含SDK各种工具，比如adb，dex2oat，aapt等。</li>
<li>/out/target/common：通用的一些编译产物，包含Java应用代码和Java库；</li>
<li>/out/target/product/[product_name]：针对特定设备的编译产物以及平台相关C/C++代码和二进制文件；</li>
</ul>
<p>在/out/target/product/[product_name]目录下，有几个重量级的镜像文件：</p>
<ul>
<li>system.img:挂载为根分区，主要包含Android OS的系统文件；</li>
<li>ramdisk.img:主要包含init.rc文件和配置文件等；</li>
<li>userdata.img:被挂载在/data，主要包含用户以及应用程序相关的数据；</li>
</ul>
<p>当然还有boot.img，reocovery.img等镜像文件，这里就不介绍了。</p>
<h2 id="Android-mk解析"><a href="#Android-mk解析" class="headerlink" title="Android.mk解析"></a>Android.mk解析</h2><p>在源码树中每一个模块的所有文件通常都相应有一个自己的文件夹，在该模块的根目录下有一个名称为“Android.mk” 的文件。编译系统正是以模块为单位进行编译，每个模块都有唯一的模块名，一个模块可以有依赖多个其他模块，模块间的依赖关系就是通过模块名来引用的。也就是说当模块需要依赖一个jar包或者apk时，必须先将jar包或apk定义为一个模块，然后再依赖相应的模块。</p>
<p>对于Android.mk文件，通常都是以下面两行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LOCAL_PATH := $(call my-dir)  //设置当编译路径为当前文件夹所在路径</div><div class="line">include $(CLEAR_VARS)  //清空编译环境的变量（由其他模块设置过的变量）</div></pre></td></tr></table></figure>
<p>为方便模块编译，编译系统设置了很多的编译环境变量，如下：</p>
<ul>
<li>LOCAL_SRC_FILES：当前模块包含的所有源码文件；</li>
<li>LOCAL_MODULE：当前模块的名称（具有唯一性）；</li>
<li>LOCAL_PACKAGE_NAME：当前APK应用的名称（具有唯一性）；</li>
<li>LOCAL_C_INCLUDES：C/C++所需的头文件路径;</li>
<li>LOCAL_STATIC_LIBRARIES：当前模块在静态链接时需要的库名;</li>
<li>LOCAL_SHARED_LIBRARIES：当前模块在运行时依赖的动态库名;</li>
<li>LOCAL_STATIC_JAVA_LIBRARIES：当前模块依赖的Java静态库;</li>
<li>LOCAL_JAVA_LIBRARIES：当前模块依赖的Java共享库;</li>
<li>LOCAL_CERTIFICATE：签署当前应用的证书名称，比如platform。</li>
<li>LOCAL_MODULE_TAGS：当前模块所包含的标签，可以包含多标签，可能值为debgu,eng,user,development或optional（默认值）</li>
</ul>
<p>针对这些环境变量，编译系统还定义了一些便捷函数，如下：</p>
<ul>
<li>$(call my-dir)：获取当前文件夹路径；</li>
<li>$(call all-java-files-under, )：获取指定目录下的所有Java文件；</li>
<li>$(call all-c-files-under, )：获取指定目录下的所有C文件；</li>
<li>$(call all-Iaidl-files-under, ) ：获取指定目录下的所有AIDL文件；</li>
<li>$(call all-makefiles-under, )：获取指定目录下的所有Make文件；</li>
</ul>
<p>示例：</p>
<pre><code class="bash">LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)

<span class="comment"># 获取所有子目录中的Java文件</span>
LOCAL_SRC_FILES := $(call all-subdir-java-files)

<span class="comment"># 当前模块依赖的动态Java库名称</span>
LOCAL_JAVA_LIBRARIES := com.gityuan.lib

<span class="comment"># 当前模块的名称</span>
LOCAL_MODULE := demo

<span class="comment"># 将当前模块编译成一个静态的Java库</span>
include $(BUILD_STATIC_JAVA_LIBRARY)
</code></pre>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/13/我所理解的OOP——UML六种关系/" itemprop="url">
                  我所理解的OOP——UML六种关系
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-13T23:21:50+08:00" content="2016-09-13">
              2016-09-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Other/" itemprop="url" rel="index">
                    <span itemprop="name">Other</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.cnblogs.com/dolphinX/p/3296681.html" target="_blank" rel="external">TokgoLiang——转载别人的原文链接一定要写在开头</a></p>
<p>UML定义的关系主要有：泛化、实现、依赖、关联、聚合、组合，这六种关系紧密程度依次加强，分别看一下</p>
<h1 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h1><p>概念：泛化是一种一般与特殊、一般与具体之间关系的描述，具体描述建立在一般描述的基础之上，并对其进行了扩展。在程序中是通过继承类实现的。比如狗是对动物的具体描述，在面向对象设计的时候一般把狗设计为动物的子类。</p>
<p>表示方法：空心三角形箭头的实线，子类指向父类</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/%E6%B3%9B%E5%8C%96.png" alt="泛化"></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>概念：实现是一种类与接口的关系，表示类是接口所有特征和行为的实现，在程序中一般通过类实现接口来描述</p>
<p>表示方法：空心三角形箭头的虚线，实现类指向接口</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/%E5%AE%9E%E7%8E%B0.png" alt="实现"></p>
<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><p>概念：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖，在程序中一般表现为类A中的方法需要类B的实例作为其参数或者变量，而类A本身并不需要引用类B的实例作为其成员变量。</p>
<p>表示方法：虚线箭头，类A指向类B。</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/%E4%BE%9D%E8%B5%96.png" alt="依赖"></p>
<h1 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h1><p>概念：表示类与类之间的联接,它使一个类知道另一个类的属性和方法，这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，在程序中被关联类B以类属性的形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量</p>
<p>表示方法：实线箭头，类A指向类B</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/%E5%85%B3%E8%81%94.png" alt="关联"></p>
<h1 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h1><p>概念：聚合关联关系的一种特例，是强的关联关系。聚合是整体和个体之间的关系，即has-a的关系，整体与个体可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。程序中聚合和关联关系是一致的，只能从语义级别来区分；</p>
<p>表示方法：尾部为空心菱形的实线箭头（也可以没箭头），类A指向类B</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/%E8%81%9A%E5%90%88.png" alt="聚合"></p>
<h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><p>概念：组合也是关联关系的一种特例。组合是一种整体与部分的关系，即contains-a的关系，比聚合更强。部分与整体的生命周期一致，整体的生命周期结束也就意味着部分的生命周期结束，组合关系不能共享。程序中组合和关联关系是一致的，只能从语义级别来区分。</p>
<p>表示方法：尾部为实心菱形的实现箭头（也可以没箭头），类A指向类B</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/%E7%BB%84%E5%90%88.png" alt="组合"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/13/第三章：Android经典场景设计/" itemprop="url">
                  第三章：Android经典场景设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-13T22:31:06+08:00" content="2016-09-13">
              2016-09-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Android_读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="App图片缓存设计"><a href="#App图片缓存设计" class="headerlink" title="App图片缓存设计"></a>App图片缓存设计</h1><p>App缓存分为两部分，数据缓存和图片缓存，第二章介绍了数据缓存</p>
<h2 id="ImageLoader设计原理"><a href="#ImageLoader设计原理" class="headerlink" title="ImageLoader设计原理"></a>ImageLoader设计原理</h2><p>在显示图片的时候，现在内存中查找，如果没有就去本地查找，如果还没有就开一个新线程去下载，下载成功之后吧图片同时缓存到内存和本地。</p>
<p>基于这个原理，我们可以在每次退出一个页面的时候，吧ImageLoader内存中的缓存全部清除，这样就节省了大量内存，下次再用的时候在本地取出来就可以了。</p>
<p>此外，由于ImageLoader对图片是软应用的形式，所以内存中的图片会在内存不足的时候被系统回收（内存足够的时候不会对其进行垃圾回收）。</p>
<p><a href="https://github.com/nostra13/Android-Universal-Image-Loader" title="ImageLoader在GitHub的下载地址" target="_blank" rel="external">ImageLoader在GitHub的下载地址：https://github.com/nostra13/Android-Universal-Image-Loader</a></p>
<h2 id="ImageLoader的使用"><a href="#ImageLoader的使用" class="headerlink" title="ImageLoader的使用"></a>ImageLoader的使用</h2><h3 id="ImageLoader由三大组件组成"><a href="#ImageLoader由三大组件组成" class="headerlink" title="ImageLoader由三大组件组成"></a>ImageLoader由三大组件组成</h3><ul>
<li>ImageLoaderConfiguration：对图片缓存进行总体配置，包括内存缓存大小，本地缓存的大小和位置，日志，下载策略（FIFO，LIFO）等等。       </li>
<li>ImageLoader：我们一般使用displayImage来把URL对应的图片显示在ImageView上。       </li>
<li>DisplayImageOptions：在每个页面需要显示图片的地方，控制如何显示的细节，比如指定下载时的默认图片（包括下载中，下载失败，URL为空等），是否将缓存放到内存或者本地磁盘。</li>
</ul>
<p>博客园陈哈哈博文中对三个关系的比喻：           </p>
<blockquote>
<p>他们有点像厨房规定，厨师，客户个人口味之间的关系。ImageLoaderConfiguration就像是厨房里的规定，每一个厨师要怎么着装，要怎么保持厨房的干净，这是针对每一个厨师都适用的规定，而且不允许个性化改变。ImageLoader就像是具体做菜的厨师，负责具体菜谱的制作。DisplayImageOptions就像是客户的偏好，根据客户是重口味还是清淡，每一个ImageLoader根据DisplayImageOptions的要求具体执行。</p>
</blockquote>
<h3 id="如何使用ImageLoader"><a href="#如何使用ImageLoader" class="headerlink" title="如何使用ImageLoader"></a>如何使用ImageLoader</h3><p>1.在Application中配置ImageLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YoungHeartApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onCreate();</div><div class="line">		CacheManager.getInstance().initCacheDir();</div><div class="line">		ImageLoaderConfiguration config = </div><div class="line">				<span class="keyword">new</span> ImageLoaderConfiguration.Builder(</div><div class="line">				getApplicationContext())</div><div class="line">				.threadPriority(Thread.NORM_PRIORITY - <span class="number">2</span>)</div><div class="line">				.memoryCacheExtraOptions(<span class="number">480</span>, <span class="number">480</span>)</div><div class="line">				.memoryCacheSize(<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>)</div><div class="line">				.denyCacheImageMultipleSizesInMemory()</div><div class="line">				.discCacheFileNameGenerator(<span class="keyword">new</span> Md5FileNameGenerator())</div><div class="line">				.tasksProcessingOrder(QueueProcessingType.LIFO)</div><div class="line">				.memoryCache(<span class="keyword">new</span> WeakMemoryCache()).build();</div><div class="line">		ImageLoader.getInstance().init(config);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.在使用ImageView加载图片的地方，配置当前页面的ImageLoader选项，有可能是Activity也有可能是Adapter </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CinemaAdapter</span><span class="params">(ArrayList&lt;CinemaBean&gt; cinemaList,</span></span></div><div class="line">			AppBaseActivity context) &#123;</div><div class="line">		<span class="keyword">this</span>.cinemaList = cinemaList;</div><div class="line">		<span class="keyword">this</span>.context = context;</div><div class="line">		options = <span class="keyword">new</span> DisplayImageOptions.Builder()</div><div class="line">				.showStubImage(R.drawable.ic_launcher)</div><div class="line">				.showImageForEmptyUri(R.drawable.ic_launcher)</div><div class="line">				.cacheInMemory()</div><div class="line">				.cacheOnDisc()</div><div class="line">				.build();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>3.在使用ImageView加载图片的地方，使用ImageLoader。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CinemaBean cinema = cinemaList.get(position);</div><div class="line">		holder.tvCinemaName.setText(cinema.getCinemaName());</div><div class="line">		holder.tvCinemaId.setText(cinema.getCinemaId());</div><div class="line">		context.imageLoader.displayImage(cinemaList.get(position)</div><div class="line">				.getCinemaPhotoUrl(), holder.imgPhoto);</div></pre></td></tr></table></figure>
<p><strong>ImageLoader优化</strong></p>
<p>ImageLoader把图片缓存到内存，会导致内存占用过高，虽然对图片的引用是软引用，会在内存不足的时候被GC，但是我们希望减少GC的次数，所以要手动清理ImageLoader中的缓存。</p>
<p>在APPBaseActivity中的onDestroy方法中，执行ImageLoader的clearMemoryCache方法，下次复用的时候即使内存中没有了，还可以在本地磁盘找到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">void</span> onDestroy &#123;</div><div class="line">    imageLoader.clearMemoryCache();</div><div class="line">    <span class="keyword">super</span>.onDestroy ();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="推荐文章："><a href="#推荐文章：" class="headerlink" title="推荐文章："></a>推荐文章：</h2><p>1.简介ImageLoader（一），（二）</p>
<ul>
<li><a href="http://blog.csdn.net/yueqinglkong/article/details/27660107" target="_blank" rel="external">http://blog.csdn.net/yueqinglkong/article/details/27660107</a></li>
<li><a href="http://blog.csdn.net/yueqinglkong/article/details/28094963" target="_blank" rel="external">http://blog.csdn.net/yueqinglkong/article/details/28094963</a></li>
</ul>
<p>2.Android-Universal-Image-Loader图片异步加载类库的使用（超详细配置）</p>
<ul>
<li><a href="http://blog.csdn.net/vipzjyno1/article/details/23206387" target="_blank" rel="external">http://blog.csdn.net/vipzjyno1/article/details/23206387</a></li>
</ul>
<p>3.Android开源框架Android-Universal-Image-Loade完全解析</p>
<ul>
<li><a href="http://blog.csdn.net/xiaanming/article/details/26810303" target="_blank" rel="external">http://blog.csdn.net/xiaanming/article/details/26810303</a></li>
<li><a href="http://blog.csdn.net/xiaanming/article/details/27525741" target="_blank" rel="external">http://blog.csdn.net/xiaanming/article/details/27525741</a></li>
<li><a href="http://blog.csdn.net/xiaanming/article/details/39057201" target="_blank" rel="external">http://blog.csdn.net/xiaanming/article/details/39057201</a></li>
</ul>
<h2 id="图片加载利器Fresco"><a href="#图片加载利器Fresco" class="headerlink" title="图片加载利器Fresco"></a>图片加载利器Fresco</h2><p>Facebook的Android图片加载组件,使用Fresco：</p>
<p>1.在Application级别，对Fresco进行初始化，<br>Fresco.initialize(getApplicationContext());</p>
<p>2.与ImageLoader等传统第三方图片处理SDK不同，Fresco是基于控件级别的，所以需要把程序中显示网络图片的ImageView都替换为SimpleDraweeView即可，并在布局文件添加fresco命名空间，如下：<br>xmlns：fresco=”<a href="http://schemas.android.com/apk/res-auto" target="_blank" rel="external">http://schemas.android.com/apk/res-auto</a>“</p>
<com.facebook.drawee.view.simpledraweeview...>

<p>3.在Activity中为这个图片控件指定要显示的网络图片：<br>Uri uri = Uri.parse(“<a href="http://www.bb.com/a.png" target="_blank" rel="external">http://www.bb.com/a.png</a>“)<br>draweeView.setImageURI(uri);</p>
<p>Fresco原理是，设计了一个ImagePipeline的概念，它负责先后检查内存，磁盘文件，如果都没有再从网络下载图片，可以使用ImagePipelineConfig来配置ImagePipeline，像配置ImageLoader一样。</p>
<p>Fresco有三个线程池，其中3个线程用于网络下载图片，2个线程用于磁盘文件的读写，还有2个线程用于CPU相关操作，这是Fresco的核心，它比其他图片SDK吃内存小，就在于这个全新的缓存设计。</p>
<p><strong>第一层：Bitmap缓存</strong><br>在Android5.0系统中，考虑到内存管理有了很大改进，所以Bitmap缓存位于Java的堆（heap）中，而在Android4.x和更低的系统，Bitmap位于ashmem中，这意味着图片的创建和回收不会引发过多的GC，从而让App运行得更快。当App切到后台时，Bitmap缓存会被清空。</p>
<p><strong>第二层：内存缓存</strong><br>内存缓存中存储了图片的原始压缩格式，从内存缓存中取出的图片，在显示之前必须先解码，当App切换到后台时，内存缓存也会被清空。</p>
<p><strong>第三层：磁盘缓存</strong><br>磁盘缓存又名本地缓存，磁盘缓存中存储的也是图片的原始压缩格式，在使用前也要解码。当App切到后台，甚至关机，磁盘缓存也不会丢失。</p>
<p>Fresco在GitHub上的源码：<a href="https://github.com/mkottman/AndroLua" target="_blank" rel="external">https://github.com/mkottman/AndroLua</a><br>Fresco官方文档：<a href="http://www.fresco-cn.org/docs/index.html#_" target="_blank" rel="external">http://www.fresco-cn.org/docs/index.html#_</a></p>
<h1 id="对网络流量进行优化"><a href="#对网络流量进行优化" class="headerlink" title="对网络流量进行优化"></a>对网络流量进行优化</h1><h2 id="通信层面的优化"><a href="#通信层面的优化" class="headerlink" title="通信层面的优化"></a>通信层面的优化</h2><p>1.MobileAPI接口返回的数据，要使用gzip进行压缩，注意：大于1KB才进行压缩，否则得不偿失。</p>
<p>2.App与MobileAPI直接传递数据，通常是遵守JSON协议的。JSON因为是xml格式的，并且是以字符存在的，在数据量上还有可以压缩的空间。作者推荐一种新的数据传输协议，那就是ProtoBuffer。这种协议是二进制格式的，所以在表示大数据时，空间不JSON小的多。</p>
<p>3.解决频繁调用MobileAPI的问题。发起一次网络请求，服务器处理速度是很快的，主要花费的时间在数据传输上。走路时间的长度，网络运维人员负责解决，移动开发人员需要注意的是，减少网络访问次数。</p>
<p>4.传统的MobileAPI使用的是HTTP无状态短连接，使用HTTP协议的速度远不如使用TCP协议，因为后者是长连接，所以可以使用TCP长连接。TCP的缺点是一台服务器能支持的长连接个数不多。</p>
<p>5.要建立取消网络请求的机制。一个页面如果没有请求完数据，在跳转到另一个界面之前，吧之前的网络请求全部取消，不在等待，也不再接受数据。</p>
<p>6.增加重试机制。如果MobileAPI是严格的RESTful风格，那么我们一般将获取数据的请求接口都定义为get，而把操作数据的请求接口都定义为post。这样的话可以为所有的get请求配置重试机制，比如请求失败后重试3次，如果post请求具有防重复机制，那么到是可以增加重试机制。</p>
<h2 id="图片策略优化"><a href="#图片策略优化" class="headerlink" title="图片策略优化"></a>图片策略优化</h2><p><strong>1.要确保下载的每张图片，都符合Imageview控件的大小</strong></p>
<p>事先准备多套不同分辨率的图片，每次根据RUL请求图片时，都要额外在URL上加两个参数，width和height。</p>
<p>如果认为每次准备多套图片浪费人力，事先准备一台服务器，成为ImageSever，具体流程如下：</p>
<p>(1).首先，App每次加载图片，都会把URL地址以及width和height参数所组成的字符串进行encode，然后发送给ImageSever，新的URL如：<a href="http://www.ImageServer.com/getImage?param=(encode" target="_blank" rel="external">http://www.ImageServer.com/getImage?param=(encode</a> value )</p>
<p>(2).然后，ImageSever收到这个请求，会把param的值decode，得到原始图片的URL，以及App想要现实这张图片的width和height，ImageServer会根据URL获取到这张图片的原始图片，然后根据width和height，重新进行绘制，保存到ImageServer上，并返回给App。</p>
<p>(3).最后，App请求道一张符合其大小的图片。<br>再加一个参数imagetype，用于在比例不一致进行等比缩放后裁剪或者填充以及不缩放，这种方案的全电视频繁写硬盘。所以要事先规定几套width和height，App尽量遵守，同时在出口加以控制，也就是在像ImageServer发起请求的时候，去轮询事先规定好的各个尺寸，看哪个更接近。</p>
<p><strong>2.低流量模式</strong></p>
<p>在2G和3G网络环境下，适当降低图片的质量，可以在URL中再增加一个参数，quality根据网络环境设置对应的值，把这个参数传递给ImageServer，从而ImageServer在绘制图片时，就会将图片质量降低为quality对应比例。</p>
<p><strong>3.极速模式</strong></p>
<p>设计一些额外界面，区别于正常模式下图文并茂的页面，这些只有文字的页面称为极速模式。</p>
<h1 id="城市列表的设计"><a href="#城市列表的设计" class="headerlink" title="城市列表的设计"></a>城市列表的设计</h1><h2 id="城市列表数据"><a href="#城市列表数据" class="headerlink" title="城市列表数据"></a>城市列表数据</h2><p>一份城市列表数据包括以下几个字典：</p>
<ul>
<li>cityId，</li>
<li>cityName，</li>
<li>pinyin，</li>
<li>jianpin</li>
</ul>
<p>把城市列表数据写在本地，时间久了会产生两个问题</p>
<p>1.Android和iOS维护的数据，差距越来越大</p>
<p>写一个文本分析工具，找出Android和iOS各自维护文件的不同数据。</p>
<p>2.城市太多，每次从本地加载都要很长时间</p>
<p>每次都要解析xml城市数据文件，既然每次读取数据都很慢，那么干脆把序列化过的城市列表信息直接保存到本地文件，随App一起发布。每次读取这个文件是，直接进行发序列化即可。</p>
<p>对于解决数据更新时的同步问题，把城市列表数据做成一个MobileAPI接口，有MobileAPI去后台采集数据，增加一个版本号version字段，对比本地版本号和线上最新版本号，MobileAPI返回响应结果，如果一致，则从本地问价加载数据，否则解析MobileAPI返回的数据，同时更新本地版本号。如果MobileAPI接口调用没有成功，也直接从本地读取，从MobileAPI获取大量数据时候开启gzip压缩。</p>
<h2 id="城市列表数据增量更新机制"><a href="#城市列表数据增量更新机制" class="headerlink" title="城市列表数据增量更新机制"></a>城市列表数据增量更新机制</h2><p>cityId作为唯一标识，增量更新的数据，由增、删、改三部分组成。</p>
<p>重新定义城市列表的JSON格式，在每笔增量数据中增加一个字段type，取来区别增删改，客户端收到JSON数据后，会根据type处理本地的数据。</p>
<h1 id="App与HTML5的交互"><a href="#App与HTML5的交互" class="headerlink" title="App与HTML5的交互"></a>App与HTML5的交互</h1><p>有的团队直接使用PhoneGap来实现交互功能，作者认为PhoneGay太重了，完全可以吧这些交互操作在底层封装好，然后给开发人员使用。</p>
<p><strong>App操作HTML5页面的方法</strong></p>
<p>首先要定好通讯协议，也就是App要调用的HTML5中的JavaScript的方法名称。例如App要调用HTML5页面的changeColor(color)方法，</p>
<p>HTML5代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> &gt;</span><span class="xml"></span></div><div class="line">    function chanageColor(color) &#123;</div><div class="line">        document.body.backgroundColor = color;</div><div class="line">    &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span> &gt;</span></div><div class="line">``` </div><div class="line"></div><div class="line">Android代码如下：</div><div class="line"></div><div class="line">``` java</div><div class="line">wvAds.getSettings().setJavaScriptEnabled(true);</div><div class="line">wvAds.loadUrl("file://.../xxx.html");</div><div class="line">btnShowAlert.setOnCliceListener(new View.OnClickListener() &#123;</div><div class="line">    @Override</div><div class="line">    public void onClick(View v) &#123;</div><div class="line">    String color = "#00ee00";</div><div class="line">    wvAds.loadUrl("javascript:changeColor('"+color+"');");</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>HTML5页面操作App页面的方法</p>
<p>首先仍然是定义通讯协议，这次是定义JavaScript要调用Android种方法的名称。例如调用callAndroidMethod方法，</p>
<p>HTML5代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onClick</span>=<span class="string">"baobao.callAndroidMethod(100,100,'ccc',true)"</span>&gt;</span></div><div class="line">CallAndroidMethod<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Android代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSInterfacel</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callAndroidMethod</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">float</span> b, String c, <span class="keyword">boolean</span> d)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(d) &#123;</div><div class="line">            String strMessage = <span class="string">"fafafsadf"</span>;</div><div class="line">            <span class="keyword">new</span> AlertDialog.Builder(MainActivity.<span class="keyword">this</span>)</div><div class="line">                .setTitle(title)</div><div class="line">                .setMessage(strMessage).show(); </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同时需要注册baobao和JSInterfacel的对应关系  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wvAds.addJavascriptInterface(<span class="keyword">new</span> JSInterfacel(), <span class="string">"baobao"</span>);</div></pre></td></tr></table></figure>
<p>App和Android之间定义跳转协议,如上面的例子，事先约定格式。。</p>
<p><strong>在App中内置HTML5页面</strong></p>
<p>当有些UI不太容易在App中使用原始语言实现时，而HTML5擅长，只要调整好屏幕适配，就可以在App中应用HTML5。</p>
<p>1.首先定义两个HTML5文件，放在assets目录下<br>其中，102.html是静态页：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span>        </div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">table</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">datalDefinedByBaobao</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div><div class="line">``` </div><div class="line">datal_template.html是一个数据模板，他负责提供表格中一行的样式</div><div class="line"></div><div class="line">``` html</div><div class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">``` </div><div class="line">像name，price，datalDefinedByBaobao都是占位符</div><div class="line"></div><div class="line">2.在MovieDetailActivity中，通过遍历movieList这个集合，把数据填充到SBContent中，最终，把拼接好的字符串替换<span class="tag">&lt;<span class="name">datalDefinedByBaobao</span>&gt;</span>标签。</div><div class="line"></div><div class="line">``` java</div><div class="line">wvAds = (WebView) findViewById(R.id.wvAds);</div><div class="line">		String template = getFromAssets("data1_template.html");</div><div class="line">		StringBuilder sbContent = new StringBuilder(); </div><div class="line">		ArrayList<span class="tag">&lt;<span class="name">MovieInfo</span>&gt;</span> movieList = organizeMovieList();</div><div class="line">		for (MovieInfo movie : movieList) &#123;</div><div class="line">			String rowData;</div><div class="line">			rowData = template.replace("<span class="tag">&lt;<span class="name">name</span>&gt;</span>", movie.getName());</div><div class="line">			rowData = rowData.replace("<span class="tag">&lt;<span class="name">price</span>&gt;</span>", movie.getPrice());</div><div class="line">			sbContent.append(rowData);</div><div class="line">		&#125;</div><div class="line">		String realData = getFromAssets("102.html");</div><div class="line">		realData = realData.replace("<span class="tag">&lt;<span class="name">data1DefinedByBaobao</span>&gt;</span>", </div><div class="line">				sbContent.toString());</div><div class="line">		wvAds.loadData(realData, "text/html", "utf-8");</div></pre></td></tr></table></figure>
<p>灵活切换Native和HTML5页面的策略</p>
<p>对于经常改动的页面，我们会把它做成HTML5页面，在App中以WebView的形式加载。虽然HTML开发周期相对App而言短，但是HTML5会比较慢。</p>
<p>HTML5页面生成的步骤；</p>
<ol>
<li>从服务器动态获取数据并拼接成一个HTML，</li>
<li>返回给客户端WebView，</li>
<li>在WebView中解析并生成HTML。</li>
</ol>
<p>结合两者的优点，同时做两套页面，Native一套，HTML一套，然后在App中设置一个变量，来判断页面将显示Native还是HTML5的，这个变量可以从MobileAPI获取。App中所有的页面都可以这样做，为此，我们需要改变之前做App的思路。</p>
<ol>
<li>需要做一个后台，根据版本进行配置每个页面是使用Native页面还是HTML5页面，</li>
<li>当App启动的时候，从MobileAPI获取到每个页面是Native还是HTML5，</li>
<li>在App代码层面，页面之间要实现松耦合。</li>
</ol>
<p>页面分发器</p>
<p>对于那些来自HTML5页面，传递简单数据的页面跳转请求，我们将为其抽象一个分发器，放在BaseActivity中。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">"baobao.gotoAnyWhere(</span></span></div><div class="line">    'com.example.youngheart.MovieDetailActivity,</div><div class="line">    iOS.MovieDetailViewController:movieId=(int)123')"&gt;</div><div class="line">    gotoAnyWhere</div><div class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">``` </div><div class="line"></div><div class="line">协议的内容分成三段，第一段是Android要条转到的Activity的名称，第二段是iOS要跳转到的ViewController的名称，第三段是需要传递的参数，以key-value的形式组装。</div><div class="line"></div><div class="line">我们接下来要做的就是从协议URL中取出第1段，将其反射成一个Activity对象，取出第3段，将其解析为key-value的形式，然后从当前页面跳转到目标页面并配以正确的参数。其中，写一个辅助函数getAndroidPageName，用来获取Activity名称，</div><div class="line"></div><div class="line">``` java</div><div class="line">public class BaseActivity extends Activity &#123;</div><div class="line">	public void gotoAnyWhere(String url) &#123;</div><div class="line">		if (url != null) &#123;</div><div class="line">			if (url.startsWith("gotoMovieDetail:")) &#123;</div><div class="line">				String strMovieId = url.substring(24);</div><div class="line">				int movieId = Integer.valueOf(strMovieId);</div><div class="line">				Intent intent = new Intent(this, MovieDetailActivity.class);</div><div class="line">				intent.putExtra("movieId", movieId);</div><div class="line">				startActivity(intent);</div><div class="line">			&#125; else if (url.startsWith("gotoNewsList:")) &#123;</div><div class="line">				// as above</div><div class="line">			&#125; else if (url.startsWith("gotoPersonCenter")) &#123;</div><div class="line">				Intent intent = new Intent(this, PersonCenterActivity.class);</div><div class="line">				startActivity(intent);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	private String getAndroidPageName(String key) &#123;</div><div class="line">		String pageName = null;</div><div class="line">		int pos = key.indexOf(",");</div><div class="line">		if (pos == -1) &#123;</div><div class="line">			pageName = key;</div><div class="line">		&#125; else &#123;</div><div class="line">			pageName = key.substring(0, pos);</div><div class="line">		&#125;</div><div class="line">		return pageName;</div><div class="line">	&#125;</div><div class="line">	public void gotoAnyWhere2(String url) &#123;</div><div class="line">		if (url == null)</div><div class="line">			return;</div><div class="line">		</div><div class="line">		String pageName = getAndroidPageName(url);</div><div class="line">		if (pageName == null || pageName.trim() == "")</div><div class="line">			return;</div><div class="line">		Intent intent = new Intent();</div><div class="line">		int pos = url.indexOf(":");</div><div class="line">		if (pos &gt; 0) &#123;</div><div class="line">			String strParams = url.substring(pos);</div><div class="line">			String[] pairs = strParams.split("&amp;");</div><div class="line">			for (String strKeyAndValue : pairs) &#123;</div><div class="line">				String[] arr = strKeyAndValue.split("=");</div><div class="line">				String key = arr[0];</div><div class="line">				String value = arr[1];</div><div class="line">				if (value.startsWith("(int)")) &#123;</div><div class="line">					intent.putExtra(key, Integer.valueOf(value.substring(5)));</div><div class="line">				&#125; else if (value.startsWith("(Double)")) &#123;</div><div class="line">					intent.putExtra(key, Double.valueOf(value.substring(8)));</div><div class="line">				&#125; else &#123;</div><div class="line">					intent.putExtra(key, value);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		try &#123;</div><div class="line">			intent.setClass(this, Class.forName(pageName));</div><div class="line">		&#125; catch (ClassNotFoundException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		startActivity(intent);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="消灭全局变量"><a href="#消灭全局变量" class="headerlink" title="消灭全局变量"></a>消灭全局变量</h1><p><strong>问题的发现</strong></p>
<p>在内存不足的时候，系统会回收一部分闲置的资源，由于App被切换到后台，所以存放的全局变量很容易被回收，这时候在切回到前台继续使用，就会因为全局变量的值为空而崩溃。</p>
<p><strong>把数据作为Intent的参数传递</strong></p>
<p>即使目标Activity被系统销毁了，Intent上的数据仍然存在，所以Intent是保存数据的一个很好的地方。但是Intent能传递的数据也必须支持序列化，想JSONObject这样的数据类型，是传递不过去的。</p>
<p><strong>把全局变量序列化到本地</strong></p>
<p>另一个比较稳妥的解决方案是，我们仍然使用全局变量，在每次修改全局变量的值得时候，都要把值序列化到本地文件中，这样的话，即使内存中的全局变量被回收，本地还保存有最新的值，当我们再次使用全局变量时，就从本地文件中再反序列化到内存。但不是长远之计，以后还是要讲全局变量转换为Intent上可序列化的数据。</p>
<p><strong>序列化的缺点</strong></p>
<p>再次强调，把全局变量序列化到本地的方案只是一种过渡性的解决方案，他有以下几个硬伤：</p>
<ul>
<li>每次设置全局变量的值都要强制执行一次序列化的操作，容易造成ANR，</li>
<li>序列化生成的文件，会因为内存不够而丢失。</li>
<li>Android提供的数据类型并不全部都支持序列化。JSONObject，JSONArray，包含JSONObject或者JSONArray的List和Map，，都不支持序列化。解决方案，将JSONObject或者JSONArray转换成字符串然后再序列化，，，</li>
</ul>
<p><strong>如果Activity也被销毁了</strong></p>
<p>常见原因旋转屏幕，但是即使Activity被销毁了，Intent并不会丢失。如果需要保存页面状态则要是下面两个方法：</p>
<ul>
<li>onSaveInstanceState();</li>
<li>onRestoreInstanceState();</li>
</ul>
<p><strong>如何看待SharedPreferences</strong></p>
<p>作者认为，</p>
<blockquote>
<p>SharedPreferences是全局变量序列化到本地的另一种形式，存取数据也要支持序列化。注意不要把跳转时要传递的数据放在SharedPreferences，而是使用Intent。</p>
</blockquote>
<p><strong>User是唯一例外的全局变量</strong></p>
<p>作者看来，</p>
<blockquote>
<p>App中只有一个全局变量的存在是合理的，那就是User类。</p>
</blockquote>
</com.facebook.drawee.view.simpledraweeview...>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/12/第二章：Android网络底层框架设计/" itemprop="url">
                  第二章：Android网络底层框架设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-12T23:29:38+08:00" content="2016-09-12">
              2016-09-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Android_读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="网络底层封装"><a href="#网络底层封装" class="headerlink" title="网络底层封装"></a>网络底层封装</h1><p>网络请求的格式：    </p>
<p>对于网络请求，我们一般定义为GET和POST即可，GET为请求数据，POST为修改数据（增删改）</p>
<h2 id="Request格式："><a href="#Request格式：" class="headerlink" title="Request格式："></a>Request格式：</h2><p>所有的MobileAPI都也可以写作<a href="http://www.xxx.com/aaa.api的形式" target="_blank" rel="external">http://www.xxx.com/aaa.api的形式</a></p>
<p>对于GET，我们可以写作<a href="http://www.xxx.com/aaa.api?k1=v1&amp;ke=v2的形式，也就是说，把key-value这样的键值对存放在URL上，之所以这样设计，是为了更方便地定义数据缓存，我们尽量使GET的参数都是String，int这样的简单类型" target="_blank" rel="external">http://www.xxx.com/aaa.api?k1=v1&amp;ke=v2的形式，也就是说，把key-value这样的键值对存放在URL上，之所以这样设计，是为了更方便地定义数据缓存，我们尽量使GET的参数都是String，int这样的简单类型</a></p>
<p>对于POST，我们将key-value这样的键值对存放在From表单中，进行提交。POST经常会提交大量数据，所以有些键值对要定义成集合或者复杂的自定义实体，这时候我们就需要将这样的值转换为JSON字符串进行提交，由App传递到MobileAPI后，再将JSON字符串转换为对应的实体。</p>
<p>上述介绍只是一家之言，不同公司有不同的实现方式，这取决于服务器端的设计。</p>
<h2 id="Response格式："><a href="#Response格式：" class="headerlink" title="Response格式："></a>Response格式：</h2><p>一般使用JSON作为MobileAPI返回结果。规范的JSON数据返回格式如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">          "isError" : false,</div><div class="line">          "errorType" : 0,</div><div class="line">          "errorMessage" : " ",</div><div class="line">          "result" : &#123;</div><div class="line">                  "cinemaId" : 1,</div><div class="line">                  "cinemaName" : "name"</div><div class="line">          &#125;</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<h2 id="AsyncTask的使用和缺点"><a href="#AsyncTask的使用和缺点" class="headerlink" title="AsyncTask的使用和缺点"></a>AsyncTask的使用和缺点</h2><ol>
<li>对于耗时的操作，我们的一般方法是开启“子线程”。如果需要更新UI，则需要使用handler</li>
<li>如果耗时的操作太多，那么我们需要开启太多的子线程，这就会给系统带来巨大的负担，随之也会带来性能方面的问题。在这种情况下我们就可以考虑使用类AsyncTask来异步执行任务，不需要子线程和handler，就可以完成异步操作和刷新UI。</li>
<li>AsyncTask：对线程间的通讯做了包装，是后台线程和UI线程可以简易通讯：后台线程执行异步任务，将result告知UI线程。</li>
<li>使用方法：共分为两步，自定义AsyncTask，在耗时的地方调用自定义的AsyncTask。可以参照以下代码示例。</li>
</ol>
<p><strong>step1：继承AsyncTask<params,progress,result></params,progress,result></strong></p>
<ul>
<li>Params:输入参数。对应的是调用自定义的AsyncTask的类中调用excute()方法中传递的参数。如果不需要传递参数，则直接设为Void即可。</li>
<li>Progress：子线程执行的百分比</li>
<li>Result：返回值类型。和doInBackground（）方法的返回值类型保持一致。</li>
</ul>
<p><strong>step2：实现以下几个方法：执行时机和作用看示例代码，以下对返回值类型和参数进行说明</strong></p>
<ul>
<li>onPreExecute()：无返回值类型。不传参数</li>
<li>doInBackground(Params… params)：返回值类型和Result保持一致。参数：若无就传递Void；若有，就可用Params</li>
<li>publishProgress(Params… params)：在执行此方法的时候会直接调用onProgressUpdate(Params… values)</li>
<li>onProgressUpdate(Params… values)：无返回值类型。参数：若无就传递Void；若有，就可用Progress</li>
<li>onPostExecute(Result  result) ：无返回值类型。参数：和Result保持一致。</li>
</ul>
<p><strong>step3：在调用自定义的AsyncTask类中生成对象；</strong></p>
<p>执行  ：对象.excute(Params… params);</p>
<p>小注：</p>
<ul>
<li>Task的实例必须在UI thread中创建</li>
<li>execute方法必须在UI thread中调用</li>
<li>不要手动的调用onPreExecute(), onPostExecute(Result)，doInBackground=\’#\’” onProgressUpdate(Progress…)这几个方法</li>
<li>该task只能被执行一次，否则多次调用时将会出现异常</li>
</ul>
<p>参照连接</p>
<blockquote>
<p><a href="http://blog.csdn.net/cjjky/article/details/6684959" target="_blank" rel="external">http://blog.csdn.net/cjjky/article/details/6684959</a><br><a href="http://blog.csdn.net/zhenyongyuan123/article/details/5850389" target="_blank" rel="external">http://blog.csdn.net/zhenyongyuan123/article/details/5850389</a><br><a href="http://www.eoeandroid.com/thread-102664-1-1.html" target="_blank" rel="external">http://www.eoeandroid.com/thread-102664-1-1.html</a><br><a href="http://www.cnblogs.com/suinuaner/archive/2013/04/11/android_fifty.html" target="_blank" rel="external">http://www.cnblogs.com/suinuaner/archive/2013/04/11/android_fifty.html</a></p>
</blockquote>
<p>致命缺点，不能灵活控制其内部的线程池</p>
<ul>
<li>AsyncTast没有暴露出取消请求的方法，也就是我们熟知的CancelRequest方法，所以，一旦从A页面跳转到B页面，那么在A页面发起的请求，如果还没有返回，并不会被取消。</li>
<li>使用原生的ThreadPoolExecutor+Runnable+Handler</li>
<li>源码下载地址：<a href="http://files.cnblogs.com/files/Jax/2.1.4.zip" target="_blank" rel="external">http://files.cnblogs.com/files/Jax/2.1.4.zip</a></li>
</ul>
<h1 id="App数据缓存设计"><a href="#App数据缓存设计" class="headerlink" title="App数据缓存设计"></a>App数据缓存设计</h1><p>访问MobileAPI速度慢，主要慢在一来一回的传输速度上，</p>
<p><strong>对应措施，例如减少MobileAPI的调用次数，</strong></p>
<p>对于一个App页面，它一次性可能需要3部分数据，分别从3个MobileAPI接口获取，那么可以做一个新的MobileAPI接口，将这3部分数据都获取到一次性返回。</p>
<p>更极端的做法，APP在调用一次MobileAPI接口后，在一段时间内不再调用，仍然使用上次返回的数据，这些数据保存在APP上，我们称之为APP缓存，这个时间段我们称之为APP缓存时间。</p>
<p>App缓存智能针对GET类型接口，不适用于POST，对于GET类型接口也要看情况来设定缓存时间，或者不缓存。</p>
<p><strong>强制更新</strong></p>
<p>缓存是一把双刃剑，设置时间长了，数据长期不更新，用户体验就会不好，因此需要提供一个强制刷新的接口。</p>
<h1 id="MockService"><a href="#MockService" class="headerlink" title="MockService"></a>MockService</h1><p>（看起来像测试里面的桩模块。。。。）</p>
<p>因为App与MobileAPI之间的依赖，在MobileAPI接口还没好二APP又急等着用，或者随着App开发，App开发人员发现原来约定好的字段不够用等问题，要求MobileAPI开发人员频繁修改Mock接口并部署到测试环境。</p>
<p>为了提高效率，我们需要解除这种依赖，为此我们在App端设计自己的MockService，在App端Mock自己的数据。</p>
<h1 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h1><p><strong>登录成功后的各种场景</strong></p>
<p>情形1：点击登录按钮，进入登录页面，登陆成功后直接进入个人中心页面，一路执行startActivity即可</p>
<p>情形2：在页面A，想要跳转到页面B，并携带一些参数，却发现没有登录，于是先跳转到登录页面，登陆成功后跳转到B页面，同时仍携带那些参数</p>
<p>情形3：在页面A，执行某个操作，发现没有登录，于是跳转到登录界面，登录成功后，饭后页面A继续执行操作</p>
<p><strong>处理方法：</strong></p>
<p>1.对于情形2，在页面A，使用startActivityForResult，<br>2.在LoginActivity整合逻辑，通过判断，处理登录之后的操作，if(needCallback) setResult()，finish();<br>3.在LoginMainActivity重写onActivityResult毁掉函数switch(requestCode) </p>
<p><strong>自动登录</strong></p>
<p>最直接的做法是，登录之后，本地保存用户名和密码，重启App之后检测本地是否有保存用户名和密码，如果有，则将用户名和密码传入到登录接口，模拟用户登录行为。但是会有安全风险以及验证码的问题。</p>
<p>抛弃每次启动就进行一次登录的机制，使用在Web中很成熟的Cookie机制，也有人管Cookie叫Token，是用户身份的唯一性标志</p>
<p><strong>App端</strong></p>
<ol>
<li>每次发起MobileAPI请求时，都要把本地保存的Cookie取出来，放到HttpRequest的header中。</li>
<li>每次接受MobileAPI的响应结果是，都把HttpResponse的header中的Cookie取出来，覆盖本地保存的Cookie，不管Cookie是否有值。</li>
</ol>
<p><strong>服务器端相应操作</strong></p>
<ol>
<li>如果是用户信息相关操作，则判断HttpRequest中Cookie是否有效，如果有效，就去执行后去操作并返回结构，否则，返回Cookie过期失效的错误信息。</li>
<li>如果是用户无关的，则不需要检查HttpRequest中的Cookie，继续执行就可以了。</li>
</ol>
<p><strong>还有几个需要注意的地方</strong></p>
<ul>
<li>用户注销，清空本地保存的Cookie。</li>
<li>用户注册，因为验证码问题，不能直接调用登录接口，解决方案是，注册之后直接跳转到登录页面，让用户手动输入一次。或者把注册和登录接口绑定在一起，注册成功之后进入个人中心页面，不需要再登录一次。</li>
<li><p><strong>Cookie过期的统一处理</strong></p>
</li>
<li><p>服务器返回Cookie过期的错误消息</p>
</li>
<li>在RequestCallback中增加一种onCookieExpired回调方法，</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RequestCallback</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String conntent)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFail</span><span class="params">(String errorMessage)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCookieExpired</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在网络底层对JSON返回结果进行解析，如果发现是属于Cookie过期的错误类型，就直接回调onCookieExpired方法、</li>
</ul>
<p><strong>防止黑客刷库</strong></p>
<ul>
<li>使用验证码</li>
<li>MobileAPI发现有同一个IP短时间内频繁访问某一个MobileAPI接口是，就直接返回一段HTML5，要求用户输入验证码。App接收到这段代码时，就在页面上显示一个浮层，里面一个WebView，显示这个要求用户输入验证码的HTML5.</li>
</ul>
<h1 id="HTTP头中的奥妙"><a href="#HTTP头中的奥妙" class="headerlink" title="HTTP头中的奥妙"></a>HTTP头中的奥妙</h1><p>HTTP请求，分为HTTPRequest和HTTPResponse两种，但是无论哪种请求都由header和body两部分组成。</p>
<h2 id="HTTP-body"><a href="#HTTP-body" class="headerlink" title="HTTP body"></a>HTTP body</h2><p>对于get形式的HTTPRequest，要发送的数据都是以键值对的形式存放在URL上，比如aaa.api?k1=v1&amp;ke=v2。它的body是空的</p>
<p>对于post形式的HTTPRequest，要发送的数据都存在body里面，也是以键值对的形式。</p>
<h2 id="HTTP-header"><a href="#HTTP-header" class="headerlink" title="HTTP header"></a>HTTP header</h2><p>与body相比，header要丰富的多，它由很多键值对组成，其中有些key是标准的，兼容于各大浏览器，比如</p>
<ul>
<li>accept</li>
<li>accept-language</li>
<li>referrer</li>
<li>user-agent</li>
<li>accept-encoding</li>
</ul>
<p>此外我们还可以在MobileAPI端自定义一些键值对，然后要求App在调用MobileAPI时吧这些信息传递过来。</p>
<p><strong>时间校准</strong></p>
<p>MobileAPI端，永远使用UTC时间，包括入参合返回值，都不要使用Data格式，而是减去UTC时间1970年1月1日的差值，这是一个long型。</p>
<p>App端，每次调用MobileAPI，就取出HTTPRequest头的Data值，转换为GMT时间后，再减去本地取出的时间，得到一个差值delta。我们将这个delta保存下来，那么每次取本地时间的时候，再额外加上这个delta值，就得到服务GTM时间。</p>
<p><strong>开启gzip压缩</strong></p>
<p>使用gzip的流程如下：</p>
<ol>
<li>在App发起请求时，在HTTPRequest头中，添加要求支持gzip的key-value，这里的key是Accept-Encoding，value是gzip.</li>
<li>MobileAPI的逻辑是，检查HTTP请求头中的Accept-Encoding是否有gzip值，如果有，就会执行gzip压缩，如果执行了gzip压缩，那么返回值也就是HTTPResponse的头中，有一个content-encoding字段，会带有gzip的值；，否则，就没有这个值</li>
<li>App检查HTTPResponse头中的content-encoding字段是否包含gzip，这个值的有无，导致了App解析HTTPResponse的姿势不同。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/12/第一章：重构，夜未眠/" itemprop="url">
                  第一章：重构，夜未眠
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-12T22:34:39+08:00" content="2016-09-12">
              2016-09-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Android_读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="重新规划Android项目的目录结构"><a href="#重新规划Android项目的目录结构" class="headerlink" title="重新规划Android项目的目录结构"></a>重新规划Android项目的目录结构</h1><p>第一步：建立AndroidLib类库，将与业务无关的逻辑转移到AndroidLib</p>
<p>AndroidLib中业务无关逻辑至少包括五大部分，</p>
<ul>
<li>activity包，存放与业务无关的Activity积累，Activity基类要分两层，AndroidLib下的基类BaseActivity封装的是业务无关的公用逻辑，主项目中的AppBaseActivity基类封装的事业务相关的公用逻辑。</li>
<li>net包，存放网络底层封装，如AsyncTase</li>
<li>cache包，存放的是缓存数据和图片相关的处理</li>
<li>ui包，存放自定义控件</li>
<li>utils包，存放各种与业务逻辑无关的公用方法，比如对SharedPreferences的封装</li>
</ul>
<p>第二步：将主项目中的类分门别类的进行规划，放置在各种包中，</p>
<ul>
<li>activity包，按照模块继续拆分，将不同模块Activity划分到不同的包下</li>
<li>adapter包，所有适配器都放在一起</li>
<li>entity包，将所有实体都放在一起</li>
<li>db包，SQLLite相关逻辑的封装</li>
<li>engine包，将业务相关的类都放在一起</li>
<li>ui包，将自定义控件都放在一起</li>
<li>uitils包，将所有公用方法</li>
<li>interfaces包，真正意义上的接口，命名以“I”作为开头</li>
<li>listener包，基于Listener的接口，命名以“On”开头</li>
</ul>
<h1 id="为Activity定义新的生命周期"><a href="#为Activity定义新的生命周期" class="headerlink" title="为Activity定义新的生命周期"></a>为Activity定义新的生命周期</h1><p>例如，把onCreate方法中拆成三个子方法</p>
<ul>
<li>initVariables：初始化变量，包括Intent带的数据和Activity内的变量</li>
<li>initViews：加载Layout布局文件，初始化控件，为控件挂上事件的方法</li>
<li>loadData：获取数据</li>
</ul>
<h1 id="统一事件编程模型"><a href="#统一事件编程模型" class="headerlink" title="统一事件编程模型"></a>统一事件编程模型</h1><p><strong>方式一：实现Listener，在onClick方法中使用switch…case…，作者不建议使用</strong></p>
<blockquote>
<p>我不希望R这个类在程序中反复出现，这回扰乱面向对象编程的风格，按照我的设想，我们在initViews方法中一次性把所有的控件都初始化了，今后就再也不会私用R.id了。</p>
</blockquote>
<p><strong>方式二：匿名内部类</strong></p>
<p>作者比较推崇的方法，有以下两个有点：</p>
<ol>
<li>直接在btn按钮对象上曾经点击事件，是面向对象的写法。</li>
<li>将onClick方面的实现，封装成一个对应的方法，这样onClick事件方法就不那么臃肿了。</li>
</ol>
<h1 id="实体化编程"><a href="#实体化编程" class="headerlink" title="实体化编程"></a>实体化编程</h1><h2 id="使用fastJSON（阿里巴巴）和GSON（Google）"><a href="#使用fastJSON（阿里巴巴）和GSON（Google）" class="headerlink" title="使用fastJSON（阿里巴巴）和GSON（Google）"></a>使用fastJSON（阿里巴巴）和GSON（Google）</h2><p>作者使用fastJSON之后遇到的一个问题，表现为</p>
<ol>
<li>加了符号Annotation的实体属性，一使用就奔溃</li>
<li>当有泛型是，一使用就崩溃</li>
</ol>
<p>在调试的时候没事，每次打签名混淆包，就会出现上述问题，原因：</p>
<ul>
<li>–keepattributes Signature                //避免混淆泛型</li>
<li>–keepattributes <em>Annotation</em>            //不混淆注解</li>
</ul>
<h2 id="在页面跳转中使用实体"><a href="#在页面跳转中使用实体" class="headerlink" title="在页面跳转中使用实体"></a>在页面跳转中使用实体</h2><p>一个页面中，数据的来源有两种：</p>
<ul>
<li>调用MobileAPI获取JSON数据,使用fastJSON或者GSON</li>
<li>从上一个页面传递过来,Activity之间的数据传递</li>
</ul>
<p><strong>方法一：使用全局变量</strong></p>
<p>不建议使用，App一旦被切换到后台，当内存不足的时候，就会回收这些全局变量，从而当App再次切回到前台是，再继续使用全局变量，就会因为他们为空二崩溃</p>
<p>如果必须使用全局变量，就一定要把它们序列化到本地，这样即使全局变量味浓，也能从本地文件中恢复</p>
<p><strong>方法二：使用Intent在页面间传递数据实体</strong></p>
<p>注，如果使用Fragment可以使用Fragment来传递数据。。。（我自己加的）</p>
<h1 id="Adapter模板"><a href="#Adapter模板" class="headerlink" title="Adapter模板"></a>Adapter模板</h1><p>作者建议所有的Adapter都继承自BaseAdapter，从构造函数注入List&lt;自定义实体&gt;这样的数据集合，从而完成ListView的填充工作，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CinemaAdapter</span> <span class="keyword">extends</span> <span class="title">BaseAdapter</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;CinemaBean&gt; cinemaList;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AppBaseActivity context;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CinemaAdapter</span><span class="params">(ArrayList&lt;CinemaBean&gt; cinemaList,</span></span></div><div class="line">			AppBaseActivity context) &#123;</div><div class="line">		<span class="keyword">this</span>.cinemaList = cinemaList;</div><div class="line">		<span class="keyword">this</span>.context = context;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> cinemaList.size();</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> CinemaBean <span class="title">getItem</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> cinemaList.get(position);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getItemId</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> position;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> position, View convertView,</span></span></div><div class="line">			<span class="keyword">final</span> ViewGroup parent) &#123;</div><div class="line">		<span class="keyword">final</span> Holder holder;</div><div class="line">		<span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</div><div class="line">			holder = <span class="keyword">new</span> Holder();</div><div class="line">			convertView = context.getLayoutInflater().inflate(</div><div class="line">					R.layout.item_cinemalist, <span class="keyword">null</span>);</div><div class="line">			holder.tvCinemaName = (TextView) convertView</div><div class="line">					.findViewById(R.id.tvCinemaName);</div><div class="line">			holder.tvCinemaId = (TextView) convertView</div><div class="line">					.findViewById(R.id.tvCinemaId);</div><div class="line">			convertView.setTag(holder);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			holder = (Holder) convertView.getTag();</div><div class="line">		&#125;</div><div class="line">		CinemaBean cinema = cinemaList.get(position);</div><div class="line">		holder.tvCinemaName.setText(cinema.getCinemaName());</div><div class="line">		holder.tvCinemaId.setText(cinema.getCinemaId());</div><div class="line">		<span class="keyword">return</span> convertView;</div><div class="line">	&#125;</div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</div><div class="line">		TextView tvCinemaName;</div><div class="line">		TextView tvCinemaId;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于每个自定义的Adapter都要实现以下四个方法</p>
<ul>
<li>getCount()</li>
<li>getItem()</li>
<li>getItemId()</li>
<li>getView()<br>此外还要内置一个ViewHolder</li>
</ul>
<h1 id="类型安全转换函数"><a href="#类型安全转换函数" class="headerlink" title="类型安全转换函数"></a>类型安全转换函数</h1><p><strong>对于一个Object类型的对象，我们对其直接使用字符串操作函数toString，当其为null是就会奔溃</strong></p>
<p>比较好的做法就是，编写一个类型安全转换函数，实现如下，核心思想是，如果转换失败就返回默认值： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">convertToInt</span><span class="params">(Object value, <span class="keyword">int</span> defaultValue)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (value == <span class="keyword">null</span> || <span class="string">""</span>.equals(value.toString().trim())) &#123;</div><div class="line">		<span class="keyword">return</span> defaultValue;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="keyword">return</span> Integer.valueOf(value.toString());</div><div class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">return</span> Double.valueOf(value.toString()).intValue();</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e1) &#123;</div><div class="line">			<span class="keyword">return</span> defaultValue;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>如果长度不够，那么执行subString函数就会崩溃</strong></p>
<p>所以每次使用subString函数的时候，都要判断start和end两个参数是否越界了。</p>
<p>以上两类问题的根源，都来自MobileAPI返回的数据，由此引出另一个很严肃的问题，对于从MobileAPI返回的数据，可信度到底有多高呢？</p>
<p>首先，不能让App崩溃，应该在解析JSON数据的外面包一层try…catch…语句，将截获到的异常在catch中进行处理，例如发送错误日志给服务器。</p>
<p>其次，对数据要分级对待，例如：</p>
<p>1.对于那些不需要加工就能直接展示的数据，我们不担心，因为即使为空，页面上也就是不显示而已，不会引起逻辑的问题</p>
<p>2.对于那些很重要的数据，比如设计支付的金额不能为空的逻辑，这个时候就应该弹出提示框提示用户当前服务不可用，并停止接下里的操作</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/11/Java基础 之软引用、弱引用、虚引用/" itemprop="url">
                  Java基础 之软引用、弱引用、虚引用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-11T14:56:05+08:00" content="2016-09-11">
              2016-09-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java-基础/" itemprop="url" rel="index">
                    <span itemprop="name">java_基础</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.cnblogs.com/blogoflee/archive/2012/03/22/2411124.html" target="_blank" rel="external">TokgoLiang——转载别人的原文链接一定要写在开头</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>　　在JDK1.2以前的版本中，当一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可触及状态，程序才能使用它。这就像在日常生活中，从商店购买了某样物品后，如果有用，就一直保留它，否则就把它扔到垃圾箱，由清洁工人收走。一般说来，如果物品已经被扔到垃圾箱，想再 把它捡回来使用就不可能了。<br>　　但有时候情况并不这么简单，你可能会遇到类似鸡肋一样的物品，食之无味，弃之可惜。这种物品现在已经无用了，保留它会占空间，但是立刻扔掉它也不划算，因 为也许将来还会派用场。对于这样的可有可无的物品，一种折衷的处理办法是：如果家里空间足够，就先把它保留在家里，如果家里空间不够，即使把家里所有的垃 圾清除，还是无法容纳那些必不可少的生活用品，那么再扔掉这些可有可无的物品。<br>　　从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p>
<h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>　　平时我们编程的时候例如：Object object=new Object（）；那object就是一个强引用了。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<h2 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h2><p>　　如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只 要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 软引用可以和一个引用队列（ReferenceQueue）联 合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<h2 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h2><p>　　如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。  弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回 收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 </p>
<h2 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h2><p>　　“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在 任何时候都可能被垃圾回收。 虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队 列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 </p>
<h2 id="相关应用"><a href="#相关应用" class="headerlink" title="相关应用"></a>相关应用</h2><p>　　在java.lang.ref包中提供了三个类：SoftReference类、WeakReference类和PhantomReference类，它 们分别代表软引用、弱引用和虚引用。ReferenceQueue类表示引用队列，它可以和这三种引用类联合使用，以便跟踪Java虚拟机回收所引用的对 象的活动。</p>
<h2 id="使用软引用构建敏感数据的缓存"><a href="#使用软引用构建敏感数据的缓存" class="headerlink" title="使用软引用构建敏感数据的缓存"></a>使用软引用构建敏感数据的缓存</h2><h4 id="为什么需要使用软引用"><a href="#为什么需要使用软引用" class="headerlink" title="为什么需要使用软引用"></a>为什么需要使用软引用</h4><p>　　首先，我们看一个雇员信息查询系统的实例。我们将使用一个Java语言实现的雇员信息查询系统查询存储在磁盘文件或者数据库中的雇员人事档案信息。作为一 个用户，我们完全有可能需要回头去查看几分钟甚至几秒钟前查看过的雇员档案信息(同样，我们在浏览WEB页面的时候也经常会使用“后退”按钮)。这时我们 通常会有两种程序实现方式:一种是把过去查看过的雇员信息保存在内存中，每一个存储了雇员档案信息的Java对象的生命周期贯穿整个应用程序始终;另一种 是当用户开始查看其他雇员的档案信息的时候，把存储了当前所查看的雇员档案信息的Java对象结束引用，使得垃圾收集线程可以回收其所占用的内存空间，当 用户再次需要浏览该雇员的档案信息的时候，重新构建该雇员的信息。很显然，第一种实现方法将造成大量的内存浪费，而第二种实现的缺陷在于即使垃圾收集线程 还没有进行垃圾收集，包含雇员档案信息的对象仍然完好地保存在内存中，应用程序也要重新构建一个对象。我们知道，访问磁盘文件、访问网络资源、查询数据库 等操作都是影响应用程序执行性能的重要因素，如果能重新获取那些尚未被回收的Java对象的引用，必将减少不必要的访问，大大提高程序的运行速度。</p>
<h4 id="如果使用软引用"><a href="#如果使用软引用" class="headerlink" title="如果使用软引用"></a>如果使用软引用</h4><p>　　SoftReference的特点是它的一个实例保存对一个Java对象的软引用，该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。也就是说， 一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对这个Java对象回收前，SoftReference类所提供的 get()方法返回Java对象的强引用。另外，一旦垃圾线程回收该Java对象之后，get()方法将返回null。</p>
<h4 id="使用ReferenceQueue清除失去了软引用对象的SoftReference"><a href="#使用ReferenceQueue清除失去了软引用对象的SoftReference" class="headerlink" title="使用ReferenceQueue清除失去了软引用对象的SoftReference"></a>使用ReferenceQueue清除失去了软引用对象的SoftReference</h4><p>　　作为一个Java对象，SoftReference对象除了具有保存软引用的特殊性之外，也具有Java对象的一般性。所以，当软可及对象被回收之后， 虽然这个SoftReference对象的get()方法返回null,但这个SoftReference对象已经不再具有存在的价值，需要一个适当的清 除机制，避免大量SoftReference对象带来的内存泄漏。在java.lang.ref包里还提供了ReferenceQueue。如果在创建 SoftReference对象的时候，使用了一个ReferenceQueue对象作为参数提供给SoftReference的构造方法，如:</p>
<p>　　那么当这个SoftReference所软引用的aMyOhject被垃圾收集器回收的同时，ref所强引用的SoftReference对象被列入 ReferenceQueue。也就是说，ReferenceQueue中保存的对象是Reference对象，而且是已经失去了它所软引用的对象的 Reference对象。另外从ReferenceQueue这个名字也可以看出，它是一个队列，当我们调用它的poll()方法的时候，如果这个队列中 不是空队列，那么将返回队列前面的那个Reference对象。<br>　　<br>　　在任何时候，我们都可以调用ReferenceQueue的poll()方法来检查是否有它所关心的非强可及对象被回收。如果队列为空，将返回一个 null,否则该方法返回队列中前面的一个Reference对象。利用这个方法，我们可以检查哪个SoftReference所软引用的对象已经被回 收。于是我们可以把这些失去所软引用的对象的SoftReference对象清除掉。常用的方式为:</p>
<p>　　理解了ReferenceQueue的工作机制之后，我们就可以开始构造一个Java对象的高速缓存器了。</p>
<h4 id="通过软可及对象重获方法实现Java对象的高速缓存"><a href="#通过软可及对象重获方法实现Java对象的高速缓存" class="headerlink" title="通过软可及对象重获方法实现Java对象的高速缓存"></a>通过软可及对象重获方法实现Java对象的高速缓存</h4><p>　　利用Java2平台垃圾收集机制的特性以及前述的垃圾对象重获方法，我们通过一个雇员信息查询系统的小例子来说明如何构建一种高速缓存器来避免重复构建同一个对象带来的性能损失。我们将一个雇员的档案信息定义为一个Employee类:<br>　　<br>　　这个Employee类的构造方法中我们可以预见，如果每次需要查询一个雇员的信息。哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这是需要消耗很多时间的。下面是一个对Employee对象进行缓存的缓存器的定义:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;      </div><div class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;      </div><div class="line"><span class="keyword">import</span> java.util.Hashtable;      </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeCache</span> </span>&#123;      </div><div class="line">    <span class="keyword">static</span> <span class="keyword">private</span> EmployeeCache cache;<span class="comment">// 一个Cache实例      </span></div><div class="line">    <span class="keyword">private</span> Hashtable employeeRefs;<span class="comment">// 用于Cache内容的存储      </span></div><div class="line">    <span class="keyword">private</span> ReferenceQueue q;<span class="comment">// 垃圾Reference的队列      </span></div><div class="line">       </div><div class="line">    <span class="comment">// 继承SoftReference，使得每一个实例都具有可识别的标识。      </span></div><div class="line">    <span class="comment">// 并且该标识与其在HashMap内的key相同。      </span></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeRef</span> <span class="keyword">extends</span> <span class="title">SoftReference</span> </span>&#123;      </div><div class="line">       <span class="keyword">private</span> String _key = <span class="string">""</span>;      </div><div class="line">       </div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="title">EmployeeRef</span><span class="params">(Employee em, ReferenceQueue q)</span> </span>&#123;      </div><div class="line">           <span class="keyword">super</span>(em, q);      </div><div class="line">           _key = em.getID();      </div><div class="line">       &#125;      </div><div class="line">    &#125;      </div><div class="line">       </div><div class="line">    <span class="comment">// 构建一个缓存器实例      </span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EmployeeCache</span><span class="params">()</span> </span>&#123;      </div><div class="line">       employeeRefs = <span class="keyword">new</span> Hashtable();      </div><div class="line">       q = <span class="keyword">new</span> ReferenceQueue();      </div><div class="line">    &#125;      </div><div class="line">       </div><div class="line">    <span class="comment">// 取得缓存器实例      </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EmployeeCache <span class="title">getInstance</span><span class="params">()</span> </span>&#123;      </div><div class="line">       <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;      </div><div class="line">           cache = <span class="keyword">new</span> EmployeeCache();      </div><div class="line">       &#125;      </div><div class="line">       <span class="keyword">return</span> cache;      </div><div class="line">    &#125;      </div><div class="line">       </div><div class="line">    <span class="comment">// 以软引用的方式对一个Employee对象的实例进行引用并保存该引用      </span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheEmployee</span><span class="params">(Employee em)</span> </span>&#123;      </div><div class="line">       cleanCache();<span class="comment">// 清除垃圾引用      </span></div><div class="line">       EmployeeRef ref = <span class="keyword">new</span> EmployeeRef(em, q);      </div><div class="line">       employeeRefs.put(em.getID(), ref);      </div><div class="line">    &#125;      </div><div class="line">       </div><div class="line">    <span class="comment">// 依据所指定的ID号，重新获取相应Employee对象的实例      </span></div><div class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">getEmployee</span><span class="params">(String ID)</span> </span>&#123;      </div><div class="line">       Employee em = <span class="keyword">null</span>;      </div><div class="line">       <span class="comment">// 缓存中是否有该Employee实例的软引用，如果有，从软引用中取得。      </span></div><div class="line">       <span class="keyword">if</span> (employeeRefs.containsKey(ID)) &#123;      </div><div class="line">           EmployeeRef ref = (EmployeeRef) employeeRefs.get(ID);      </div><div class="line">           em = (Employee) ref.get();      </div><div class="line">       &#125;      </div><div class="line">       <span class="comment">// 如果没有软引用，或者从软引用中得到的实例是null，重新构建一个实例，      </span></div><div class="line">       <span class="comment">// 并保存对这个新建实例的软引用      </span></div><div class="line">       <span class="keyword">if</span> (em == <span class="keyword">null</span>) &#123;      </div><div class="line">           em = <span class="keyword">new</span> Employee(ID);      </div><div class="line">           System.out.println(<span class="string">"Retrieve From EmployeeInfoCenter. ID="</span> + ID);      </div><div class="line">           <span class="keyword">this</span>.cacheEmployee(em);      </div><div class="line">       &#125;      </div><div class="line">       <span class="keyword">return</span> em;      </div><div class="line">    &#125;      </div><div class="line">       </div><div class="line">    <span class="comment">// 清除那些所软引用的Employee对象已经被回收的EmployeeRef对象      </span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanCache</span><span class="params">()</span> </span>&#123;      </div><div class="line">       EmployeeRef ref = <span class="keyword">null</span>;      </div><div class="line">       <span class="keyword">while</span> ((ref = (EmployeeRef) q.poll()) != <span class="keyword">null</span>) &#123;      </div><div class="line">           employeeRefs.remove(ref._key);      </div><div class="line">       &#125;      </div><div class="line">    &#125;      </div><div class="line">       </div><div class="line">    <span class="comment">// 清除Cache内的全部内容      </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span> </span>&#123;      </div><div class="line">       cleanCache();      </div><div class="line">       employeeRefs.clear();      </div><div class="line">       System.gc();      </div><div class="line">       System.runFinalization();      </div><div class="line">    &#125;      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="使用弱引用构建非敏感数据的缓存"><a href="#使用弱引用构建非敏感数据的缓存" class="headerlink" title="使用弱引用构建非敏感数据的缓存"></a>使用弱引用构建非敏感数据的缓存</h2><h5 id="全局ap造成的内存泄漏"><a href="#全局ap造成的内存泄漏" class="headerlink" title="全局ap造成的内存泄漏"></a>全局ap造成的内存泄漏</h5><p>　　无意识对象保留最常见的原因是使用Map将元数据与临时对象（transient object）相关联。假定一个对象具有中等生命周期，比分配它的那个方法调用的生命周期长，但是比应用程序的生命周期短，如客户机的套接字连接。需要将 一些元数据与这个套接字关联，如生成连接的用户的标识。在创建Socket时是不知道这些信息的，并且不能将数据添加到Socket对象上，因为不能控制 Socket 类或者它的子类。这时，典型的方法就是在一个全局 Map 中存储这些信息，如下面的 SocketManager 类所示：使用一个全局 Map 将元数据关联到一个对象。</p>
<p>　　这种方法的问题是元数据的生命周期需要与套接字的生命周期挂钩，但是除非准确地知道什么时候程序不再需要这个套接字，并记住从 Map 中删除相应的映射，否则，Socket 和 User 对象将会永远留在 Map 中，远远超过响应了请求和关闭套接字的时间。这会阻止 Socket 和 User 对象被垃圾收集，即使应用程序不会再使用它们。这些对象留下来不受控制，很容易造成程序在长时间运行后内存爆满。除了最简单的情况，在几乎所有情况下找出 什么时候 Socket 不再被程序使用是一件很烦人和容易出错的任务，需要人工对内存进行管理。</p>
<h4 id="如何使用WeakHashMap"><a href="#如何使用WeakHashMap" class="headerlink" title="如何使用WeakHashMap"></a>如何使用WeakHashMap</h4><p>　　在Java集合中有一种特殊的Map类型—WeakHashMap，在这种Map中存放了键对象的弱引用，当一个键对象被垃圾回收器回收时，那么相应的值 对象的引用会从Map中删除。WeakHashMap能够节约存储空间，可用来缓存那些非必须存在的数据。关于Map接口的一般用法。</p>
<p>　　下面示例中MapCache类的main()方法创建了一个WeakHashMap对象，它存放了一组Key对象的弱引用，此外main()方法还创建了一个数组对象，它存放了部分Key对象的强引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.WeakHashMap;      </div><div class="line">       </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;      </div><div class="line">    <span class="keyword">private</span> String ident;      </div><div class="line">       </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Element</span><span class="params">(String id)</span> </span>&#123;      </div><div class="line">       ident = id;      </div><div class="line">    &#125;      </div><div class="line">       </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;      </div><div class="line">       <span class="keyword">return</span> ident;      </div><div class="line">    &#125;      </div><div class="line">       </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;      </div><div class="line">       <span class="keyword">return</span> ident.hashCode();      </div><div class="line">    &#125;      </div><div class="line">       </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;      </div><div class="line">       <span class="keyword">return</span> obj <span class="keyword">instanceof</span> Element &amp;&amp; ident.equals(((Element) obj).ident);      </div><div class="line">    &#125;      </div><div class="line">          </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span>&#123;      </div><div class="line">       System.out.println(<span class="string">"Finalizing "</span>+getClass().getSimpleName()+<span class="string">" "</span>+ident);      </div><div class="line">    &#125;      </div><div class="line">&#125;      </div><div class="line">       </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Element</span></span>&#123;      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Key</span><span class="params">(String id)</span></span>&#123;      </div><div class="line">       <span class="keyword">super</span>(id);      </div><div class="line">    &#125;      </div><div class="line">&#125;      </div><div class="line">       </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span> <span class="keyword">extends</span> <span class="title">Element</span></span>&#123;      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Value</span> <span class="params">(String id)</span></span>&#123;      </div><div class="line">       <span class="keyword">super</span>(id);      </div><div class="line">    &#125;      </div><div class="line">&#125;      </div><div class="line">       </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanonicalMapping</span> </span>&#123;      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;      </div><div class="line">       <span class="keyword">int</span> size=<span class="number">1000</span>;      </div><div class="line">       Key[] keys=<span class="keyword">new</span> Key[size];      </div><div class="line">       WeakHashMap map=<span class="keyword">new</span> WeakHashMap();      </div><div class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; SPAN&gt;    </div><div class="line">           Key k=<span class="keyword">new</span> Key(Integer.toString(i));      </div><div class="line">           Value v=<span class="keyword">new</span> Value(Integer.toString(i));      </div><div class="line">           <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>)      </div><div class="line">              keys[i]=k;      </div><div class="line">           map.put(k, v);      </div><div class="line">       &#125;      </div><div class="line">       System.gc();      </div><div class="line">    &#125;      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　从打印结果可以看出，当执行System.gc()方法后，垃圾回收器只会回收那些仅仅持有弱引用的Key对象。id可以被3整除的Key对象持有强引用，因此不会被回收。</p>
<h4 id="用-WeakHashMap-堵住泄漏"><a href="#用-WeakHashMap-堵住泄漏" class="headerlink" title="用 WeakHashMap 堵住泄漏"></a>用 WeakHashMap 堵住泄漏</h4><p>　　在 SocketManager 中防止泄漏很容易，只要用 WeakHashMap 代替 HashMap 就行了。（这里假定SocketManager不需要线程安全）。当映射的生命周期必须与键的生命周期联系在一起时，可以使用这种方法。用 WeakHashMap修复 SocketManager。</p>
<h4 id="配合使用引用队列"><a href="#配合使用引用队列" class="headerlink" title="配合使用引用队列"></a>配合使用引用队列</h4><p>　　WeakHashMap 用弱引用承载映射键，这使得应用程序不再使用键对象时它们可以被垃圾收集，get() 实现可以根据 WeakReference.get() 是否返回 null 来区分死的映射和活的映射。但是这只是防止 Map 的内存消耗在应用程序的生命周期中不断增加所需要做的工作的一半，还需要做一些工作以便在键对象被收集后从 Map 中删除死项。否则，Map 会充满对应于死键的项。虽然这对于应用程序是不可见的，但是它仍然会造成应用程序耗尽内存。 </p>
<p>　　引用队列是垃圾收集器向应用程序返回关于对象生命周期的信息的主要方法。弱引用有个构造函数取引用队列作为参数。如果用关联的引用队列创建弱引用，在弱引用对象成为 GC 候选对象时，这个引用对象就在引用清除后加入到引用队列中（具体参考上文软引用示例）。</p>
<p>　　WeakHashMap 有一个名为 expungeStaleEntries() 的私有方法，大多数 Map 操作中会调用它，它去掉引用队列中所有失效的引用，并删除关联的映射。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/11/Java输入输出流/" itemprop="url">
                  Java输入输出流
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-11T14:56:05+08:00" content="2016-09-11">
              2016-09-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java-基础/" itemprop="url" rel="index">
                    <span itemprop="name">java_基础</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://blog.csdn.net/hguisu/article/details/7418161" target="_blank" rel="external">TokgoLiang——转载别人的原文链接一定要写在开头</a></p>
<h2 id="什么是IO"><a href="#什么是IO" class="headerlink" title="什么是IO"></a>什么是IO</h2><p>　　Java中I/O操作主要是指使用Java进行输入，输出操作. Java所有的I/O机制都是基于数据流进行输入输出，这些数据流表示了字符或者字节数据的流动序列。Java的I/O流提供了读写数据的标准方法。任何Java中表示数据源的对象都会提供以数据流的方式读写它的数据的方法。  </p>
<p>　　Java.io是大多数面向数据流的输入/输出类的主要软件包。此外，Java也对块传输提供支持，在核心库 java.nio中采用的便是块IO。</p>
<p>　　IO的好处是简单易用，缺点是效率较低。块IO效率很高，但编程比较复杂。 </p>
<p>　　Java IO模型：<br>　　Java的IO模型设计非常优秀，它使用Decorator模式，按功能划分Stream，您可以动态装配这些Stream，以便获得您需要的功能。例如，您需要一个具有缓冲的文件输入流，则应当组合使用FileInputStream和BufferedInputStream。 </p>
<h2 id="数据流的基本概念"><a href="#数据流的基本概念" class="headerlink" title="数据流的基本概念"></a>数据流的基本概念</h2><p>数据流是一串连续不断的数据的集合，就象水管里的水流，在水管的一端一点一点地供水，而在水管的另一端看到的是一股连续不断的水流。数据写入程序可以是一段、一段地向数据流管道中写入数据，这些数据段会按先后顺序形成一个长的数据流。对数据读取程序来说，看不到数据流在写入时的分段情况，每次可以读取其中的任意长度的数据，但只能先读取前面的数据后，再读取后面的数据。不管写入时是将数据分多次写入，还是作为一个整体一次写入，读取时的效果都是完全一样的。 </p>
<p><strong>“流是磁盘或其它外围设备中存储的数据的源点或终点。”</strong></p>
<p>　　在电脑上的数据有三种存储方式，一种是外存，一种是内存，一种是缓存。比如电脑上的硬盘，磁盘，U盘等都是外存，在电脑上有内存条，缓存是在CPU里面的。外存的存储量最大，其次是内存，最后是缓存，但是外存的数据的读取最慢，其次是内存，缓存最快。这里总结从外存读取数据到内存以及将数据从内存写到外存中。对于内存和外存的理解，我们可以简单的理解为容器，即外存是一个容器，内存又是另外一个容器。那又怎样把放在外存这个容器内的数据读取到内存这个容器以及怎么把内存这个容器里的数据存到外存中呢？</p>
<p>　　<strong>Java类库中，IO部分的内容是很庞大的，因为它涉及的领域很广泛:</strong></p>
<p>　　<strong>标准输入输出，文件的操作，网络上的数据流，字符串流，对象流，zip文件流等等，java中将输入输出抽象称为流</strong>，就好像水管，将两个容器连接起来。将数据冲外存中读取到内存中的称为输入流，将数据从内存写入外存中的称为输出流。</p>
<p>　　流是一个很形象的概念，当程序需要读取数据的时候，就会开启一个通向数据源的流，这个数据源可以是文件，内存，或是网络连接。类似的，当程序需要写入数据的时候，就会开启一个通向目的地的流。</p>
<p>　　<strong>总结的基本概念如下：</strong></p>
<h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p>　　一组有序，有起点和终点的字节的数据序列。包括输入流和输出流。</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/1355473547_6986.jpg" alt="数据流"></p>
<h4 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h4><p>　　程序从输入流读取数据源。数据源包括外界(键盘、文件、网络…)，即是将数据源读入到程序的通信通道</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/%E8%BE%93%E5%85%A5%E6%B5%81.jpg" alt="输入流"></p>
<h4 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h4><p>　　程序向输出流写入数据。将程序中的数据输出到外界（显示器、打印机、文件、网络…）的通信通道。</p>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/%E8%BE%93%E5%87%BA%E6%B5%81.jpg" alt="输出流"></p>
<p>　　采用数据流的目的就是使得输出输入独立于设备。</p>
<ul>
<li>Input Stream不关心数据源来自何种设备（键盘，文件，网络）</li>
<li>Output Stream不关心数据的目的是何种设备（键盘，文件，网络）</li>
</ul>
<h4 id="数据流分类"><a href="#数据流分类" class="headerlink" title="数据流分类"></a>数据流分类</h4><p>　　流序列中的数据既可以是未经加工的原始二进制数据，也可以是经一定编码处理后符合某种格式规定的特定数据。因此Java中的流分为两种：</p>
<ul>
<li>字节流：数据流中最小的数据单元是字节</li>
<li>字符流：数据流中最小的数据单元是字符， Java中的字符是Unicode编码，一个字符占用两个字节。</li>
</ul>
<h2 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h2><p>　　Java程序可通过命令行参数与外界进行简短的信息交换，同时，也规定了与标准输入、输出设备，如键盘、显示器进行信息交换的方式。而通过文件可以与外界进行任意数据形式的信息交换。</p>
<h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArgs</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;  </div><div class="line">            System.out.println(<span class="string">"args["</span> + i + <span class="string">"] is &lt;"</span> + args[i] + <span class="string">"&gt;"</span>);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>运行命令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java Java C VB</div></pre></td></tr></table></figure>
<p><strong>运行结果：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">args[0] is &lt;Java&gt;</div><div class="line">args[1] is &lt;C&gt;</div><div class="line">args[2] is &lt;VB&gt;</div></pre></td></tr></table></figure>
<h4 id="标准输入，输出数据流"><a href="#标准输入，输出数据流" class="headerlink" title="标准输入，输出数据流"></a>标准输入，输出数据流</h4><p>java系统自带的标准数据流：java.lang.System:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">java.lang.System   </div><div class="line">public final class System  extends Object&#123;   </div><div class="line">   static  PrintStream  err;//标准错误流（输出）  </div><div class="line">   static  InputStream  in;//标准输入(键盘输入流)  </div><div class="line">   static  PrintStream  out;//标准输出流(显示器输出流)  </div><div class="line">&#125; </div><div class="line">``` </div><div class="line"></div><div class="line">注意：</div><div class="line">1. System类不能创建对象，只能直接使用它的三个静态成员。</div><div class="line">1. 每当main方法被执行时,就自动生成上述三个对象。</div><div class="line"></div><div class="line">###### 标准输出流 System.out</div><div class="line"></div><div class="line">System.out向标准输出设备输出数据，其数据类型为PrintStream。方法：</div><div class="line"></div><div class="line">- Void print(参数)</div><div class="line">- Void println(参数)</div><div class="line"></div><div class="line">###### 标准输入流 System.in</div><div class="line"></div><div class="line">System.in读取标准输入设备数据（从标准输入获取数据，一般是键盘），其数 据类型为InputStream。方法：</div><div class="line"></div><div class="line">- int read()  //返回ASCII码。若,返回值=-1，说明没有读取到任何字节读取工作结束。</div><div class="line">- int read(byte[] b)//读入多个字节到缓冲区b中返回值是读入的字节数</div><div class="line"></div><div class="line">例如：</div><div class="line"></div><div class="line">``` java</div><div class="line">import java.io.*;  </div><div class="line">public class StandardInputOutput &#123;  </div><div class="line">    public static void main(String args[]) &#123;  </div><div class="line">        int b;  </div><div class="line">        try &#123;  </div><div class="line">            System.out.println("please Input:");  </div><div class="line">            while ((b = System.in.read()) != -1) &#123;  </div><div class="line">                System.out.print((char) b);  </div><div class="line">            &#125;  </div><div class="line">        &#125; catch (IOException e) &#123;  </div><div class="line">            System.out.println(e.toString());  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>等待键盘输入，键盘输入什么，就打印出什么：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">please Input:</div><div class="line">tokgoliang</div><div class="line">tokgoliang</div></pre></td></tr></table></figure>
<h6 id="标准错误流"><a href="#标准错误流" class="headerlink" title="标准错误流"></a>标准错误流</h6><p>System.err输出标准错误，其数据类型为PrintStream。可查阅API获得详细说明。</p>
<p>　　标准输出通过System.out调用println方法输出参数并换行，而print方法输出参数但不换行。println或print方法都通 过重载实现了输出基本数据类型的多个方法，包括输出参数类型为boolean、char、int、long、float和double。同时，也重载实现 了输出参数类型为char[]、String和Object的方法。其中，print（Object）和println（Object）方法在运行时将调 用参数Object的toString方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.BufferedReader;  </div><div class="line"><span class="keyword">import</span> java.io.IOException;  </div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardInputOutput</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;  </div><div class="line">        String s;  </div><div class="line">        <span class="comment">// 创建缓冲区阅读器从键盘逐行读入数据  </span></div><div class="line">        InputStreamReader ir = <span class="keyword">new</span> InputStreamReader(System.in);  </div><div class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(ir);  </div><div class="line">        System.out.println(<span class="string">"Unix系统: ctrl-d 或 ctrl-c 退出"</span>  </div><div class="line">                + <span class="string">"\nWindows系统: ctrl-z 退出"</span>);  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            <span class="comment">// 读一行数据，并标准输出至显示器  </span></div><div class="line">            s = in.readLine();  </div><div class="line">            <span class="comment">// readLine()方法运行时若发生I/O错误，将抛出IOException异常  </span></div><div class="line">            <span class="keyword">while</span> (s != <span class="keyword">null</span>) &#123;  </div><div class="line">                System.out.println(<span class="string">"Read: "</span> + s);  </div><div class="line">                s = in.readLine();  </div><div class="line">            &#125;  </div><div class="line">            <span class="comment">// 关闭缓冲阅读器  </span></div><div class="line">            in.close();  </div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123; <span class="comment">// Catch any IO exceptions.  </span></div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="java-IO层次体系结构"><a href="#java-IO层次体系结构" class="headerlink" title="java.IO层次体系结构"></a>java.IO层次体系结构</h2><p>在整个Java.io包中最重要的就是5个类和一个接口。5个类指的是File、OutputStream、InputStream、Writer、Reader；一个接口指的是Serializable.掌握了这些IO的核心操作那么对于Java中的IO体系也就有了一个初步的认识了</p>
<p>Java I/O主要包括如下几个层次，包含三个部分：</p>
<ol>
<li>流式部分――IO的主体部分；</li>
<li>非流式部分――主要包含一些辅助流式部分的类，如：File类、RandomAccessFile类和FileDescriptor等类；</li>
<li>其他类–文件读取部分的与安全相关的类，如：SerializablePermission类，以及与本地操作系统相关的文件系统的类，如：FileSystem类和Win32FileSystem类和WinNTFileSystem类。</li>
</ol>
<p><strong>主要的类如下：</strong></p>
<ol>
<li>File（文件特征与管理）：用于文件或者目录的描述信息，例如生成新目录，修改文件名，删除文件，判断文件所在路径等。</li>
<li>InputStream（二进制格式操作）：抽象类，基于字节的输入操作，是所有输入流的父类。定义了所有输入流都具有的共同特征。</li>
<li>OutputStream（二进制格式操作）：抽象类。基于字节的输出操作。是所有输出流的父类。定义了所有输出流都具有的共同特征。<br><strong>Java中字符是采用Unicode标准，一个字符是16位，即一个字符使用两个字节来表示。为此，JAVA中引入了处理字符的流。</strong></li>
<li>Reader（文件格式操作）：抽象类，基于字符的输入操作。</li>
<li>Writer（文件格式操作）：抽象类，基于字符的输出操作。</li>
<li>RandomAccessFile（随机文件操作）：它的功能丰富，可以从文件的任意位置进行存取（输入输出）操作。</li>
</ol>
<p>Java中IO流的体系结构如图：<br><img src="http://7xu1cb.com1.z0.glb.clouddn.com/Java%E4%B8%ADIO%E6%B5%81%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.jpg" alt="Java中IO流的体系结构"></p>
<h2 id="非流式文件类–File类"><a href="#非流式文件类–File类" class="headerlink" title="非流式文件类–File类"></a>非流式文件类–File类</h2><p>　　在Java语言的java.io包中，由File类提供了描述文件和目录的操作与管理方法。但File类不是InputStream、OutputStream或Reader、Writer的子类，因为它不负责数据的输入输出，而专门用来管理磁盘文件与目录。</p>
<p>作用：File类主要用于命名文件、查询文件属性和处理文件目录。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Serializable</span>,<span class="title">Comparable</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>File类共提供了三个不同的构造函数，以不同的参数形式灵活地接收文件和目录名信息。构造函数：</p>
<p><strong>1）File (String   pathname)  </strong><br>　　例:File  f1=new File(“FileTest1.txt”); //创建文件对象f1，f1所指的文件是在当前目录下创建的FileTest1.txt<br><strong>2）File (String  parent  ,  String child)</strong><br>　　例:File f2=new  File(“D:\dir1”,”FileTest2.txt”) ;//  注意：D:\dir1目录事先必须存在，否则异常<br><strong>3）File (File    parent  , String child)</strong><br>　　例:File  f4=new File(“\dir3”);<br>　　File  f5=new File(f4,”FileTest5.txt”);  //在如果 \dir3目录不存在使用f4.mkdir()先创建一个对应于某磁盘文件或目录的File对象一经创建， 就可以通过调用它的方法来获得文件或目录的属性。    </p>
<ul>
<li>public boolean exists( ) 判断文件或目录是否存在</li>
<li>public boolean isFile( ) 判断是文件还是目录 </li>
<li>public boolean isDirectory( ) 判断是文件还是目录</li>
<li>public String getName( ) 返回文件名或目录名</li>
<li>public String getPath( ) 返回文件或目录的路径。</li>
<li>public long length( ) 获取文件的长度 </li>
<li>public String[ ] list ( ) 将目录中所有文件名保存在字符串数组中返回。<br>File类中还定义了一些对文件或目录进行管理、操作的方法，常用的方法有：</li>
<li>public boolean renameTo( File newFile );    重命名文件</li>
<li>public void delete( );   删除文件</li>
<li>public boolean mkdir( ); 创建目录</li>
</ul>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.File;  </div><div class="line"><span class="keyword">import</span> java.io.IOException;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFile</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;  </div><div class="line">        File dir = <span class="keyword">new</span> File(<span class="string">"\\root"</span>);  </div><div class="line">        File f1 = <span class="keyword">new</span> File(dir, <span class="string">"fileOne.txt"</span>);  </div><div class="line">        File f2 = <span class="keyword">new</span> File(dir, <span class="string">"fileTwo.java"</span>);  </div><div class="line">        <span class="comment">// 文件对象创建后，指定的文件或目录不一定物理上存在  </span></div><div class="line">        <span class="keyword">if</span> (!dir.exists())  </div><div class="line">            dir.mkdir();  </div><div class="line">        <span class="keyword">if</span> (!f1.exists())  </div><div class="line">            f1.createNewFile();  </div><div class="line">        <span class="keyword">if</span> (!f2.exists())  </div><div class="line">            f2.createNewFile();  </div><div class="line">        System.out.println(<span class="string">"f1's AbsolutePath=  "</span> + f1.getAbsolutePath());  </div><div class="line">        System.out.println(<span class="string">"f1 Canread="</span> + f1.canRead());  </div><div class="line">        System.out.println(<span class="string">"f1's len= "</span> + f1.length());  </div><div class="line">        String[] FL;  </div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;  </div><div class="line">        FL = dir.list();  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; FL.length; i++) &#123;  </div><div class="line">            count++;  </div><div class="line">            System.out.println(FL[i] + <span class="string">"is in \\root"</span>);  </div><div class="line">        &#125;  </div><div class="line">        System.out.println(<span class="string">"there are"</span> + count + <span class="string">"file in //root"</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说明：File类的方法:</p>
<ul>
<li>exists()测试磁盘中指定的文件或目录是否存在</li>
<li>mkdir()创建文件对象指定的目录（单层目录）</li>
<li>createNewFile()创建文件对象指定的文件</li>
<li>list()返回目录中所有文件名字符串</li>
</ul>
<h2 id="Java-IO流类库"><a href="#Java-IO流类库" class="headerlink" title="Java.IO流类库"></a>Java.IO流类库</h2><h4 id="io流的四个基本类"><a href="#io流的四个基本类" class="headerlink" title="io流的四个基本类"></a>io流的四个基本类</h4><p>　　java.io包中包含了流式I/O所需要的所有类。在java.io包中有四个基本类：InputStream、OutputStream及Reader、Writer类，它们分别处理字节流和字符流：</p>
<table>
<thead>
<tr>
<th>输入/输出</th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入流</td>
<td>Inputstream</td>
<td>Reader</td>
</tr>
<tr>
<td>输出流</td>
<td>OutputStream</td>
<td>Writer</td>
</tr>
</tbody>
</table>
<p><img src="http://7xu1cb.com1.z0.glb.clouddn.com/IO%E6%A1%86%E6%9E%B6.jpg" alt="IO框架"></p>
<p>　　JDK1.4版本开始引入了新I/O类库，它位于java.nio包中，新I/O类库利用通道和缓冲区等来提高I/O操作的效率。</p>
<p>　　在java.io包中， java.io.InputStream 表示字节输入流， java.io.OutputStream表示字节输出流，处于java.io包最顶层。这两个类均为抽象类，也就是说它们不能被实例化，必须生成子类之后才能实现一定的功能。</p>
<h4 id="io流的具体分类"><a href="#io流的具体分类" class="headerlink" title="io流的具体分类"></a>io流的具体分类</h4><p><strong>按I/O类型来总体分类：</strong></p>
<ul>
<li><p>Memory<br>　　1）从/向内存数组读写数据: CharArrayReader、 CharArrayWriter、ByteArrayInputStream、ByteArrayOutputStream<br>　　2）从/向内存字符串读写数据 StringReader、StringWriter、StringBufferInputStream</p>
</li>
<li><p>Pipe管道  实现管道的输入和输出（进程间通信）: PipedReader、PipedWriter、PipedInputStream、PipedOutputStream</p>
</li>
<li><p>File 文件流。对文件进行读、写操作 ：FileReader、FileWriter、FileInputStream、FileOutputStream</p>
</li>
<li><p>ObjectSerialization 对象输入、输出 ：ObjectInputStream、ObjectOutputStream</p>
</li>
<li><p>DataConversion数据流 按基本数据类型读、写（处理的数据是Java的基本类型（如布尔型，字节，整数和浮点数））：DataInputStream、DataOutputStream</p>
</li>
<li><p>Printing 包含方便的打印方法 ：PrintWriter、PrintStream</p>
</li>
<li><p>Buffering缓冲  在读入或写出时，对数据进行缓存，以减少I/O的次数：BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream</p>
</li>
<li><p>Filtering 滤流，在数据进行读或写时进行过滤：FilterReader、FilterWriter、FilterInputStream、FilterOutputStream过</p>
</li>
<li><p>Concatenation合并输入 把多个输入流连接成一个输入流 ：SequenceInputStream </p>
</li>
<li><p>Counting计数  在读入数据时对行记数 ：LineNumberReader、LineNumberInputStream</p>
</li>
<li><p>Peeking Ahead 通过缓存机制，进行预读 ：PushbackReader、PushbackInputStream</p>
</li>
<li><p>Converting between Bytes and Characters 按照一定的编码/解码标准将字节流转换为字符流，或进行反向转换（Stream到Reader,Writer的转换类）：InputStreamReader、OutputStreamWriter</p>
</li>
</ul>
<p><strong>按数据来源（去向）分类：</strong></p>
<ul>
<li>File（文件）： FileInputStream, FileOutputStream, FileReader, FileWriter </li>
<li>byte[]：ByteArrayInputStream, ByteArrayOutputStream </li>
<li>Char[]: CharArrayReader, CharArrayWriter </li>
<li>String: StringBufferInputStream, StringReader, StringWriter </li>
<li>网络数据流：InputStream, OutputStream, Reader, Writer </li>
</ul>
<h2 id="字节流InputStream-OutputStream"><a href="#字节流InputStream-OutputStream" class="headerlink" title="字节流InputStream/OutputStream"></a>字节流InputStream/OutputStream</h2><h4 id="InputStream抽象类"><a href="#InputStream抽象类" class="headerlink" title="InputStream抽象类"></a>InputStream抽象类</h4><p>　　InputStream 为字节输入流，它本身为一个抽象类，必须依靠其子类实现各种功能，此抽象类是表示字节输入流的所有类的超类。 继承自InputStream  的流都是向程序中输入数据的，且数据单位为字节（8bit）；</p>
<p>　　InputStream是输入字节数据用的类，所以InputStream类提供了3种重载的read方法.Inputstream类中的常用方法： </p>
<ul>
<li>public abstract int read( )：读取一个byte的数据，返回值是高位补0的int类型值。若返回值=-1说明没有读取到任何字节读取工作结束。</li>
<li>public int read(byte b[ ])：读取b.length个字节的数据放到b数组中。返回值是读取的字节数。该方法实际上是调用下一个方法实现的 </li>
<li>public int read(byte b[ ], int off, int len)：从输入流中最多读取len个字节的数据，存放到偏移量为off的b数组中。 </li>
<li>public int available( )：返回输入流中可以读取的字节数。注意：若输入阻塞，当前线程将被挂起，如果InputStream对象调用这个方法的话，它只会返回0，这个方法必须由继承InputStream类的子类对象调用才有用， </li>
<li>public long skip(long n)：忽略输入流中的n个字节，返回值是实际忽略的字节数, 跳过一些字节来读取 </li>
<li>public int close( ) ：我们在使用完后，必须对我们打开的流进行关闭. </li>
</ul>
<p><strong>主要的子类：</strong></p>
<ul>
<li>FileInputStream把一个文件作为InputStream，实现对文件的读取操作     </li>
<li>ByteArrayInputStream：把内存中的一个缓冲区作为InputStream使用 </li>
<li>StringBufferInputStream：把一个String对象作为InputStream </li>
<li>PipedInputStream：实现了pipe的概念，主要在线程中使用 </li>
<li>SequenceInputStream：把多个InputStream合并为一个InputStream </li>
</ul>
<h4 id="OutputStream抽象类"><a href="#OutputStream抽象类" class="headerlink" title="OutputStream抽象类"></a>OutputStream抽象类</h4><p>　　OutputStream提供了3个write方法来做数据的输出，这个是和InputStream是相对应的。 </p>
<ul>
<li>public void write(byte b[ ])：将参数b中的字节写到输出流。 </li>
<li>public void write(byte b[ ], int off, int len) ：将参数b的从偏移量off开始的len个字节写到输出流。 </li>
<li>public abstract void write(int b) ：先将int转换为byte类型，把低字节写入到输出流中。 </li>
<li>public void flush( ) : 将数据缓冲区中数据全部输出，并清空缓冲区。 </li>
<li>public void close( ) : 关闭输出流并释放与流相关的系统资源。 </li>
</ul>
<p>主要的子类：</p>
<p>ByteArrayOutputStream：把信息存入内存中的一个缓冲区中<br>FileOutputStream：把信息存入文件中<br>PipedOutputStream：实现了pipe的概念，主要在线程中使用<br>SequenceOutputStream：把多个OutStream合并为一个OutStream </p>
<p>流结束的判断：方法read()的返回值为-1时；readLine()的返回值为null时。</p>
<h4 id="文件输入流：-FileInputStream类"><a href="#文件输入流：-FileInputStream类" class="headerlink" title="文件输入流： FileInputStream类"></a>文件输入流： FileInputStream类</h4><p>　　FileInputStream可以使用read()方法一次读入一个字节，并以int类型返回，或者是使用read()方法时读入至一个byte数组，byte数组的元素有多少个，就读入多少个字节。在将整个文件读取完成或写入完毕的过程中，这么一个byte数组通常被当作缓冲区，因为这么一个byte数组通常扮演承接数据的中间角色。</p>
<p>作用：以文件作为数据输入源的数据流。或者说是打开文件，从文件读数据到内存的类。<br>使用方法(1)<br>File  fin=new File(“d:/abc.txt”);<br>FileInputStream in=new FileInputStream( fin);<br>使用方法(2)<br>FileInputStream  in=new  FileInputStream(“d: /abc.txt”);</p>
<p>程序举例：将InputFromFile.java的程序的内容显示在显示器上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.IOException;  </div><div class="line"><span class="keyword">import</span> java.io.FileInputStream;  </div><div class="line">;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFile</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;  </div><div class="line">        <span class="keyword">try</span>&#123;      </div><div class="line">               FileInputStream rf=<span class="keyword">new</span>   FileInputStream(<span class="string">"InputFromFile.java"</span>);  </div><div class="line">               <span class="keyword">int</span> n=<span class="number">512</span>;   <span class="keyword">byte</span>  buffer[]=<span class="keyword">new</span>  <span class="keyword">byte</span>[n];     </div><div class="line">               <span class="keyword">while</span>((rf.read(buffer,<span class="number">0</span>,n)!=-<span class="number">1</span>)&amp;&amp;(n&gt;<span class="number">0</span>))&#123;  </div><div class="line">                   System.out.println(<span class="keyword">new</span> String(buffer) );  </div><div class="line">                &#125;  </div><div class="line">                System.out.println();  </div><div class="line">                rf.close();  </div><div class="line">        &#125; <span class="keyword">catch</span>(IOException  IOe)&#123;        </div><div class="line">              System.out.println(IOe.toString());  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="文件输出流-FileOutputStream类"><a href="#文件输出流-FileOutputStream类" class="headerlink" title="文件输出流:FileOutputStream类"></a>文件输出流:FileOutputStream类</h4><p>作用：用来处理以文件作为数据输出目的数据流；或者说是从内存区读数据入文件</p>
<p>FileOutputStream类用来处理以文件作为数据输出目的数据流；一个表示文件名的字符串，也可以是File或FileDescriptor对象。 </p>
<p>创建一个文件流对象有两种方法：<br>方式1：<br>File   f=new  File (“d:/myjava/write.txt “);<br>FileOutputStream  out= new FileOutputStream (f);<br>　　<br>方式2：<br>FileOutputStream out=new FileOutputStream(“d:/myjava/write.txt “);<br>　　<br>方式3：构造函数将 FileDescriptor()对象作为其参数。<br>FileDescriptor() fd=new FileDescriptor();<br>FileOutputStream f2=new FileOutputStream(fd);<br>　　<br>方式4：构造函数将文件名作为其第一参数，将布尔值作为第二参数。<br>FileOutputStream f=new FileOutputStream(“d:/abc.txt”,true); </p>
<p><strong>注意： （1）文件中写数据时，若文件已经存在，则覆盖存在的文件；（2）的读/写操作结束时，应调用close方法关闭流。</strong> </p>
<p>程序举例：使用键盘输入一段文章，将文章保存在文件write.txt中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.IOException;  </div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFile</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            System.out.println(<span class="string">"please Input from      Keyboard"</span>);  </div><div class="line">            <span class="keyword">int</span> count, n = <span class="number">512</span>;  </div><div class="line">            <span class="keyword">byte</span> buffer[] = <span class="keyword">new</span> <span class="keyword">byte</span>[n];  </div><div class="line">            count = System.in.read(buffer);  </div><div class="line">            FileOutputStream wf = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:/myjava/write.txt"</span>);  </div><div class="line">            wf.write(buffer, <span class="number">0</span>, count);  </div><div class="line">            wf.close(); <span class="comment">// 当流写操作结束时，调用close方法关闭流。  </span></div><div class="line">            System.out.println(<span class="string">"Save to the write.txt"</span>);  </div><div class="line">        &#125; <span class="keyword">catch</span> (IOException IOe) &#123;  </div><div class="line">            System.out.println(<span class="string">"File Write Error!"</span>);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="FileInputStream流和FileOutputStream的应用"><a href="#FileInputStream流和FileOutputStream的应用" class="headerlink" title="FileInputStream流和FileOutputStream的应用"></a>FileInputStream流和FileOutputStream的应用</h4><p>利用程序将文件file1.txt 拷贝到file2.txt中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.File;  </div><div class="line"><span class="keyword">import</span> java.io.IOException;  </div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;  </div><div class="line"><span class="keyword">import</span> java.io.FileInputStream;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFile</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            File inFile = <span class="keyword">new</span> File(<span class="string">"copy.java"</span>);  </div><div class="line">            File outFile = <span class="keyword">new</span> File(<span class="string">"copy2.java"</span>);  </div><div class="line">            FileInputStream finS = <span class="keyword">new</span> FileInputStream(inFile);  </div><div class="line">            FileOutputStream foutS = <span class="keyword">new</span> FileOutputStream(outFile);  </div><div class="line">            <span class="keyword">int</span> c;  </div><div class="line">            <span class="keyword">while</span> ((c = finS.read()) != -<span class="number">1</span>) &#123;  </div><div class="line">                foutS.write(c);  </div><div class="line">            &#125;  </div><div class="line">            finS.close();  </div><div class="line">            foutS.close();  </div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </div><div class="line">            System.err.println(<span class="string">"FileStreamsTest: "</span> + e);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="缓冲输入输出流-BufferedInputStream-BufferedOutputStream"><a href="#缓冲输入输出流-BufferedInputStream-BufferedOutputStream" class="headerlink" title="缓冲输入输出流 BufferedInputStream/ BufferedOutputStream"></a>缓冲输入输出流 BufferedInputStream/ BufferedOutputStream</h4><p>　　计算机访问外部设备非常耗时。访问外存的频率越高，造成CPU闲置的概率就越大。为了减少访问外存的次数，应该在一次对外设的访问中，读写更多的数据。为此，除了程序和流节点间交换数据必需的读写机制外，还应该增加缓冲机制。缓冲流就是每一个数据流分配一个缓冲区，一个缓冲区就是一个临时存储数据的内存。这样可以减少访问硬盘的次数,提高传输效率。</p>
<p>　　BufferedInputStream:当向缓冲流写入数据时候，数据先写到缓冲区，待缓冲区写满后，系统一次性将数据发送给输出设备。</p>
<p>　　BufferedOutputStream :当从向缓冲流读取数据时候，系统先从缓冲区读出数据，待缓冲区为空时，系统再从输入设备读取数据到缓冲区。</p>
<p>1）将文件读入内存：<br>将BufferedInputStream与FileInputStream相接<br>FileInputStream in=new  FileInputStream( “file1.txt ” );<br>BufferedInputStream bin=new  BufferedInputStream( in); </p>
<p>2）将内存写入文件：<br>将BufferedOutputStream与 FileOutputStream相接<br>FileOutputStreamout=new FileOutputStream(“file1.txt”);<br>BufferedOutputStream  bin=new BufferedInputStream(out);</p>
<p>3）键盘输入流读到内存<br>将BufferedReader与标准的数据流相接<br>InputStreamReader sin=new InputStreamReader (System.in) ；<br>BufferedReader bin=new             BufferedReader(sin);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteToFile</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;  </div><div class="line">        InputStreamReader sin = <span class="keyword">new</span> InputStreamReader(System.in);  </div><div class="line">        BufferedReader bin = <span class="keyword">new</span> BufferedReader(sin);  </div><div class="line">        FileWriter out = <span class="keyword">new</span> FileWriter(<span class="string">"myfile.txt"</span>);  </div><div class="line">        BufferedWriter bout = <span class="keyword">new</span> BufferedWriter(out);  </div><div class="line">        String s;  </div><div class="line">        <span class="keyword">while</span> ((s = bin.readLine()).length() &gt; <span class="number">0</span>) &#123;  </div><div class="line">            bout.write(s, <span class="number">0</span>, s.length());  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序说明：<br>从键盘读入字符，并写入到文件中BufferedReader类的方法：String readLine()<br>作用：读一行字符串，以回车符为结束。<br>BufferedWriter类的方法：bout.write(String s,offset,len)<br>作用：从缓冲区将字符串s从offset开始，len长度的字符串写到某处。</p>
<h2 id="字符流Writer-Reader"><a href="#字符流Writer-Reader" class="headerlink" title="字符流Writer/Reader"></a>字符流Writer/Reader</h2><p>　　Java中字符是采用Unicode标准，一个字符是16位，即一个字符使用两个字节来表示。为此，JAVA中引入了处理字符的流。</p>
<h4 id="Reader抽象类"><a href="#Reader抽象类" class="headerlink" title="Reader抽象类"></a>Reader抽象类</h4><p>　　用于读取字符流的抽象类。子类必须实现的方法只有 read(char[], int, int) 和 close()。但是，多数子类将重写此处定义的一些方法，以提供更高的效率和/或其他功能。</p>
<p>1) FileReader :与FileInputStream对应<br>主要用来读取字符文件，使用缺省的字符编码，有三种构造函数：<br>(1）将文件名作为字符串 ：FileReader f=new FileReader(“c:/temp.txt”);<br>(2）构造函数将File对象作为其参数。<br>File f=new file(“c:/temp.txt”);<br>FileReader f1=new FileReader(f);<br>(3) 构造函数将FileDescriptor对象作为参数<br>FileDescriptor() fd=new FileDescriptor()<br>FileReader f2=new FileReader(fd);<br>(1) 用指定字符数组作为参数：CharArrayReader(char[])<br>(2) 将字符数组作为输入流:CharArrayReader(char[], int, int)<br>读取字符串，构造函数如下： public StringReader(String s);<br>2) CharArrayReader：与ByteArrayInputStream对应<br>3) StringReader : 与StringBufferInputStream对应<br>4) InputStreamReader<br>从输入流读取字节，在将它们转换成字符:Public inputstreamReader(inputstream is);<br>5) FilterReader: 允许过滤字符流<br>protected filterReader(Reader r);<br>6) BufferReader :接受Reader对象作为参数，并对其添加字符缓冲器，使用readline()方法可以读取一行。<br>Public BufferReader(Reader r); </p>
<p>主要方法：</p>
<ul>
<li>public int read() throws IOException; //读取一个字符，返回值为读取的字符 </li>
<li>public int read(char cbuf[]) throws IOException; /<em>读取一系列字符到数组cbuf[]中，返回值为实际读取的字符的数量</em>/ </li>
<li>public abstract int read(char cbuf[],int off,int len) throws IOException; /<em>读取len个字符，从数组cbuf[]的下标off处开始存放，返回值为实际读取的字符数量，该方法必须由子类实现</em>/ </li>
</ul>
<h4 id="Writer抽象类"><a href="#Writer抽象类" class="headerlink" title="Writer抽象类"></a>Writer抽象类</h4><p>　　写入字符流的抽象类。子类必须实现的方法仅有 write(char[], int, int)、flush() 和 close()。但是，多数子类将重写此处定义的一些方法，以提供更高的效率和/或其他功能。 其子类如下：</p>
<p>1） FileWrite: 与FileOutputStream对应<br>　　将字符类型数据写入文件，使用缺省字符编码和缓冲器大小。<br>　　Public FileWrite(file f);<br>2)  chararrayWrite:与ByteArrayOutputStream对应 ,将字符缓冲器用作输出。<br>　　    Public CharArrayWrite();<br>3) PrintWrite:生成格式化输出<br>　　    public PrintWriter(outputstream os);<br>4) filterWriter:用于写入过滤字符流<br>　　    protected FilterWriter(Writer w);<br>5) PipedWriter：与PipedOutputStream对应<br>6) StringWriter：无与之对应的以字节为导向的stream  </p>
<p>主要方法：</p>
<ul>
<li>public void write(int c) throws IOException； //将整型值c的低16位写入输出流 </li>
<li>public void write(char cbuf[]) throws IOException； //将字符数组cbuf[]写入输出流 </li>
<li>public abstract void write(char cbuf[],int off,int len) throws IOException； //将字符数组cbuf[]中的从索引为off的位置处开始的len个字符写入输出流 </li>
<li>public void write(String str) throws IOException； //将字符串str中的字符写入输出流 </li>
<li>public void write(String str,int off,int len) throws IOException； //将字符串str 中从索引off开始处的len个字符写入输出流 </li>
<li>flush( ) //刷空输出流，并输出所有被缓存的字节。 </li>
<li>close()   关闭流 public abstract void close() throws IOException</li>
</ul>
<h4 id="InputStream与Reader差别-OutputStream与Writer差别"><a href="#InputStream与Reader差别-OutputStream与Writer差别" class="headerlink" title="InputStream与Reader差别 OutputStream与Writer差别"></a>InputStream与Reader差别 OutputStream与Writer差别</h4><p>　　InputStream和OutputStream类处理的是字节流，数据流中的最小单位是字节(8个bit)<br>Reader与Writer处理的是字符流，在处理字符流时涉及了字符编码的转换问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncodeTest</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readBuff</span><span class="params">(<span class="keyword">byte</span> [] buff)</span> <span class="keyword">throws</span> IOException </span>&#123;  </div><div class="line">       ByteArrayInputStream in =<span class="keyword">new</span> ByteArrayInputStream(buff);  </div><div class="line">        <span class="keyword">int</span> data;  </div><div class="line">        <span class="keyword">while</span>((data=in.read())!=-<span class="number">1</span>)   System.out.print(data+<span class="string">"  "</span>);  </div><div class="line">        System.out.println();     in.close();     &#125;  </div><div class="line">  </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;  </div><div class="line">       System.out.println(<span class="string">"内存中采用unicode字符编码："</span> );  </div><div class="line">       <span class="keyword">char</span>   c=<span class="string">'好'</span>;  </div><div class="line">       <span class="keyword">int</span> lowBit=c&amp;<span class="number">0xFF</span>;     <span class="keyword">int</span> highBit=(c&amp;<span class="number">0xFF00</span>)&gt;&gt;<span class="number">8</span>;  </div><div class="line">       System.out.println(<span class="string">""</span>+lowBit+<span class="string">"   "</span>+highBit);  </div><div class="line">       String s=<span class="string">"好"</span>;  </div><div class="line">       System.out.println(<span class="string">"本地操作系统默认字符编码："</span>);  </div><div class="line">       readBuff(s.getBytes());  </div><div class="line">       System.out.println(<span class="string">"采用GBK字符编码："</span>);  </div><div class="line">       readBuff(s.getBytes(<span class="string">"GBK"</span>));  </div><div class="line">       System.out.println(<span class="string">"采用UTF-8字符编码："</span>);        </div><div class="line">       readBuff(s.getBytes(<span class="string">"UTF-8"</span>));      &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Reader类能够将输入流中采用其他编码类型的字符转换为Unicode字符，然后在内存中为其分配内存<br>Writer类能够将内存中的Unicode字符转换为其他编码类型的字符，再写到输出流中。</p>
<h2 id="IOException异常类的子类"><a href="#IOException异常类的子类" class="headerlink" title="IOException异常类的子类"></a>IOException异常类的子类</h2><ul>
<li>public class EOFException：非正常到达文件尾或输入流尾时，抛出这种类型的异常。</li>
<li>public class FileNotFoundException：当文件找不到时，抛出的异常。</li>
<li>public class InterruptedIOException：当I/O操作被中断时，抛出这种类型的异常。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://7xu1cb.com1.z0.glb.clouddn.com/IMG_0273.JPG"
               alt="TokgoLiang" />
          <p class="site-author-name" itemprop="name">TokgoLiang</p>
          <p class="site-description motion-element" itemprop="description">In me the tiger sniffs the rose.</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">14</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://qiushao.net/" title="qiushao的博客" target="_blank">qiushao的博客</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TokgoLiang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
